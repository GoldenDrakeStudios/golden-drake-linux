#!/bin/bash
#
# Golden Drake Linux (GDL): an Arch installer for gamers and game developers!
# Copyright (C) 2020-2021 Golden Drake Studios: goldendrakestudios.com
# Forked originally from the Anarchy installer: anarchyinstaller.gitlab.io
#
# shellcheck disable=SC1090,SC2154,SC2034,SC2155

readonly DEFAULT_BACKTITLE="Golden Drake Linux v1.0.0"
readonly GDL_DIR='/usr/share/gdl'
readonly LOG_FILE='/root/gdl.log'
readonly SSL_KEY="$(openssl rand -base64 32)"
readonly VM_TYPE="$(systemd-detect-virt)"
readonly BLACK='\e[0;30m' # color constants for use with 'echo'
readonly RED='\e[0;31m'
readonly GREEN='\e[0;32m'
readonly YELLOW='\e[0;33m'
readonly BLUE='\e[0;34m'
readonly MAGENTA='\e[0;35m'
readonly CYAN='\e[0;36m'
readonly WHITE='\e[0;37m'
readonly BOLD_BLACK='\e[1;30m'
readonly BOLD_RED='\e[1;31m'
readonly BOLD_GREEN='\e[1;32m'
readonly BOLD_YELLOW='\e[1;33m'
readonly BOLD_BLUE='\e[1;34m'
readonly BOLD_MAGENTA='\e[1;35m'
readonly BOLD_CYAN='\e[1;36m'
readonly BOLD_WHITE='\e[1;37m'
readonly COLOR_RESET='\e[m'
readonly I='\Z3*\Zn' # item (to mark unordered list items in dialogs)
TITLE=''
BACKTITLE=''
INCLUDE_BACKTITLE='true'
NEW_HOSTNAME=''
NEW_USERNAME=''
NEW_USER_FULL_NAME=''
NEW_PW=''
RELOAD_LANG_TEXT='false'
WIFI_AVAILABLE='false'
BLUETOOTH_AVAILABLE='false'
USB='none'
BATTERY=''
DRIVE=''
SWAP_SIZE=''
ROOT=''
BOOT=''
ESP_MNT=''
MOUNTED='false'
ENCRYPTED='false'
GPT=''
UEFI=''
KEYMAP=''
ZONE=''
LANG_FILE="${GDL_DIR}/lang/english.conf"

# Color scheme for installer
tput civis
echo -en '\e]P0000000' #darkblack (black)
echo -en '\e]P1800000' #darkred (maroon)
echo -en '\e]P200A86B' #darkgreen (jade)
echo -en '\e]P3DA9100' #darkyellow/brown (harvest gold)
echo -en '\e]P4082567' #darkblue (sapphire)
echo -en '\e]P5AB274F' #darkmagenta (amaranth purple)
echo -en '\e]P63AA8C1' #darkcyan (moonstone)
echo -en '\e]P7C0C0C0' #darkwhite/lightgrey (silver)
echo -en '\e]P8555555' #lightblack/darkgrey (Davy's gray)
echo -en '\e]P9FF2400' #lightred (scarlet)
echo -en '\e]PA50C878' #lightgreen (emerald)
echo -en '\e]PBD4AF37' #lightyellow (metallic gold)
echo -en '\e]PC318CE7' #lightblue (bleu de France)
echo -en '\e]PDE0115F' #lightmagenta (ruby)
echo -en '\e]PE7FFFD4' #lightcyan (aquamarine)
echo -en '\e]PFE5E4E2' #lightwhite (platinum)
setterm -background black -foreground yellow -store
tput cnorm

# Default non-AUR packages to install
BASE_PACKAGES='
  acpi
  alsa-utils
  arch-wiki-docs
  arch-wiki-lite
  asciiquarium
  atril
  audacious
  base-devel
  bash
  bash-completion
  btrfs-progs
  bzip2
  cheese
  celluloid
  cmatrix
  cool-retro-term
  coreutils
  cowsay
  cpupower
  dhcpcd
  dialog
  dosfstools
  e2fsprogs
  ffmpegthumbnailer
  file-roller
  fortune-mod
  figlet
  file
  filesystem
  findutils
  galculator
  gamemode lib32-gamemode
  gawk
  gcc-libs
  gcolor2
  gettext
  git
  git-lfs
  glibc
  gnome-characters
  gnome-keyring
  grep
  grub
  gst-libav
  gst-plugins-base
  gst-plugins-good
  gst-plugins-bad
  gst-plugins-ugly
  gufw
  gvfs
  gvfs-mtp
  gvfs-smb
  gvim
  gzip
  inetutils
  iproute2
  iputils
  jp2a
  libreoffice-fresh
  libsecret
  licenses
  lightdm
  lightdm-gtk-greeter
  lightdm-gtk-greeter-settings
  linux
  linux-firmware
  linux-headers
  lolcat
  lvm2
  man-db
  man-pages
  mesa lib32-mesa
  neofetch
  networkmanager
  network-manager-applet
  noto-fonts
  noto-fonts-emoji
  noto-fonts-extra
  ntfs-3g
  openssh
  p7zip
  pacman
  pacman-contrib
  pavucontrol
  pciutils
  pipewire
  poppler-data
  procps-ng
  ps_mem
  psmisc
  pulseaudio
  pulseaudio-alsa
  redshift
  reflector
  sed
  shadow
  sl
  soundfont-fluid
  sudo
  systemd
  systemd-sysvcompat
  tar
  terminator
  texinfo
  tree
  ttf-dejavu
  ufw
  unrar
  unzip
  util-linux
  vi
  vkd3d lib32-vkd3d
  wget
  wtf
  xdg-user-dirs
  xfce4
  xfce4-goodies
  xorg-apps
  xorg-server
  xorg-xinit
  xterm
  xz
  zip '

# If Lutris is selected, all these will be installed as they're often necessary
# or helpful for running non-Steam Windows games/apps (such as Battle.net).
# Main source: https://github.com/lutris/docs/blob/master/WineDependencies.md
LUTRIS_PACKAGES='
  lutris
  wine-staging
  giflib lib32-giflib
  libpng lib32-libpng
  libldap lib32-libldap
  gnutls lib32-gnutls
  mpg123 lib32-mpg123
  openal lib32-openal
  v4l-utils lib32-v4l-utils
  libpulse lib32-libpulse
  libgpg-error lib32-libgpg-error
  alsa-plugins lib32-alsa-plugins
  alsa-lib lib32-alsa-lib
  libjpeg-turbo lib32-libjpeg-turbo
  sqlite lib32-sqlite
  libxcomposite lib32-libxcomposite
  libxinerama lib32-libxinerama
  libgcrypt lib32-libgcrypt
  ncurses lib32-ncurses
  opencl-icd-loader lib32-opencl-icd-loader
  libxslt lib32-libxslt
  libva lib32-libva
  gtk3 lib32-gtk3
  gst-plugins-base-libs lib32-gst-plugins-base-libs
  vulkan-icd-loader lib32-vulkan-icd-loader
  wine-gecko
  wine-mono
  winetricks
  samba
  sdl lib32-sdl
  fluidsynth lib32-fluidsynth
  libva-vdpau-driver lib32-libva-vdpau-driver
  libcanberra-pulse lib32-libcanberra-pulse '

# Packages to install after the base install (esp. AUR software)
AUR_AND_OPTIONAL_PACKAGES='
  boxes
  cbonsai
  matcha-gtk-theme
  mugshot
  no-more-secrets
  surfn-icons-git
  toilet
  xcursor-breeze
  xfce-superkey-git '

# Appends a given string or command output stream to the log file
log() {
  if [[ -n "$1" ]]; then # manual logging
    echo "[$(date '+%H:%M:%S')]: $1" >>"${LOG_FILE}"
  else # command output
    while read -r output; do
      echo "${output}" >>"${LOG_FILE}"
    done
  fi
}

# Enables a given systemd service
enable_service() {
  if arch-chroot /mnt systemctl enable "$1"; then
    log "Enabled systemd service '$1'"
  else
    log "ERROR: Failed to enable systemd service '$1'"
  fi
}

# Custom cowsay function
dragonsay() {
  if "${INCLUDE_BACKTITLE}"; then
    cowsay -f dragon "$1"
  else
    echo -e "$1\n"
  fi
}

# Custom dialog function
dialog() {
  if "${INCLUDE_BACKTITLE}"; then
    BACKTITLE="${DEFAULT_BACKTITLE}"
    if [[ -n "${BATTERY}" ]]; then
      BACKTITLE+=" | Battery: $(cat "${BATTERY}"/capacity)%"
    fi
    /usr/bin/dialog --stdout --colors --backtitle "${BACKTITLE}" --title \
      " ${TITLE} " "$@"
  else
    /usr/bin/dialog --stdout --colors --title " ${TITLE} " "$@"
  fi
}

# Displays a simple 'OK' message dialog
message() {
  dialog --ok-button "${ok}" --msgbox "\n$1" 0 0
}

# Displays a yes/no dialog
yesno() {
  local body="$1" yes_button="$2" no_button="$3"

  if (( $# == 4 )); then
    dialog --defaultno --yes-label "${yes_button}" --no-label "${no_button}" \
      --yesno "\n${body}" 0 0
  else
    dialog --yes-label "${yes_button}" --no-label "${no_button}" \
      --yesno "\n${body}" 0 0
  fi
  return $?
}

# Displays a gauge (loading bar) dialog
load_bar() {
  {
    local -i progress=1

    # shellcheck disable=SC2009
    while [[ -n $! ]] && ps | grep -q $!; do
      sleep 0.1
      echo "${progress}"
      if (( progress < 100 )); then
        (( ++progress ))
      fi
    done
    echo 100
    sleep 0.5
  } | dialog --gauge "\n$1" 9 79 0
}

# Handles a sudden exit caused by the user pressing Ctrl+C
force_quit() {
  log "User force quit the installation"
  TITLE="Force Quit"
  message "${force_quit_msg}"
  clear
  dragonsay "${shell_prompt_msg1}"
  echo -e "${shell_prompt_msg2}"
  exit 1
}

initialize() {
  source "${LANG_FILE}"
  if (( $(id -u) != 0 )); then
    dragonsay "Sorry, this script requires root privileges (e.g., sudo)."
    exit 1
  elif [[ ! -f "${LOG_FILE}" ]]; then # first (automatic) launch of gdl
    touch "${LOG_FILE}"
    sed -i 's/^#Color$/Color/' /etc/pacman.conf
    sed -i 's/^#CheckSpace$/CheckSpace/' /etc/pacman.conf
    sed -i '/^#VerbosePkgLists$/ a ILoveCandy' /etc/pacman.conf
    sed -i '/\[multilib]$/ {
      N
      /Include/s/#//g}' /etc/pacman.conf
    clear
    dragonsay "${intro_msg}"
    echo -e "${shell_prompt_msg2}"
    exit # let user run other commands, if desired, before install truly begins
  fi
  log "Initializing installer"
  set -o pipefail # ensure $? remembers failures from piped commands
  [[ -d /tmp/gdl ]] || mkdir /tmp/gdl
  if (( $(tput lines) < 25 )) || grep -q 'accessibility=' /proc/cmdline; then
    INCLUDE_BACKTITLE='false'
  fi
  if lsblk | grep 'run' | grep -qo 'sd.'; then
    USB="$(lsblk | grep 'run' | grep -o 'sd.')"
  fi
  if dmesg | grep -qi 'blue'; then
    BLUETOOTH_AVAILABLE='true'
  fi
  if [[ -d /sys/class/power_supply/BAT0 ]]; then
    BATTERY='/sys/class/power_supply/BAT0'
  elif [[ -d /sys/class/power_supply/BAT1 ]]; then
    BATTERY='/sys/class/power_supply/BAT1'
  fi
  if [[ -n "$(ip addr | grep -E 'wlp|wlo|wlan' | awk '{print $2}' |
        sed 's/://' | head -n 1)" ]]; then
    WIFI_AVAILABLE='true'
  fi
  if [[ "${VM_TYPE}" == 'none' ]]; then
    if lspci | grep VGA | grep -iq 'nvidia'; then
      readonly DEFAULT_GPU_DRIVER='nvidia'
      readonly GPU_CHIPSET='NVIDIA'
    elif lspci | grep VGA | grep -Eq 'ATI|AMD'; then
      readonly DEFAULT_GPU_DRIVER='xf86-video-ati'
      readonly GPU_CHIPSET='AMD/ATI'
    elif lspci | grep VGA | grep -q 'Intel'; then
      readonly DEFAULT_GPU_DRIVER='xf86-video-intel'
      readonly GPU_CHIPSET='Intel'
    else
      readonly DEFAULT_GPU_DRIVER='xf86-video-vesa'
      readonly GPU_CHIPSET='Unknown'
    fi
  fi
  trap force_quit SIGINT # execute trap when Ctrl+C is pressed (SIGINT)
  systemctl start NetworkManager.service
}

set_language() {
  TITLE="Language Selection"
  local language

  while true; do
    if language="$(dialog --no-cancel --menu "\n${set_language_msg}" 20 60 10 \
        'English' '-' \
        'Bulgarian' 'Български' \
        'Dutch' 'Nederlands' \
        'French' 'Français' \
        'German' 'Deutsch' \
        'Greek' 'Greek' \
        'Hungarian' 'Magyar' \
        'Indonesian' 'bahasa Indonesia' \
        'Italian' 'Italiano' \
        'Latvian' 'Latviešu' \
        'Lithuanian' 'Lietuvių' \
        'Polish' 'Polski' \
        'Portuguese' 'Português' \
        'Portuguese-Brazilian' 'Português do Brasil' \
        'Romanian' 'Română' \
        'Russian' 'Russian' \
        'Spanish' 'Español' \
        'Swedish' 'Svenska')"; then
      break
    fi
  done
  case "${language}" in
    Bulgarian) LANG_FILE="${GDL_DIR}/lang/bulgarian.conf" lib='bg' bro='bg' ;;
    Dutch) LANG_FILE="${GDL_DIR}/lang/dutch.conf" lib='nl' bro='nl' ;;
    French) LANG_FILE="${GDL_DIR}/lang/french.conf" lib='fr' bro='fr' ;;
    German) LANG_FILE="${GDL_DIR}/lang/german.conf" lib='de' bro='de' ;;
    Greek) LANG_FILE="${GDL_DIR}/lang/greek.conf" lib='el' bro='el' ;;
    Hungarian) LANG_FILE="${GDL_DIR}/lang/hungarian.conf" lib='hu' bro='hu' ;;
    Indonesian) LANG_FILE="${GDL_DIR}/lang/indonesia.conf" lib='id' bro='id' ;;
    Italian) LANG_FILE="${GDL_DIR}/lang/italian.conf" lib='it' bro='it' ;;
    Latvian) LANG_FILE="${GDL_DIR}/lang/latvian.conf" lib='lv' bro='lv' ;;
    Lithuanian) LANG_FILE="${GDL_DIR}/lang/lithuanian.conf" lib='lt' bro='lt' ;;
    Polish) LANG_FILE="${GDL_DIR}/lang/polish.conf" lib='pl' bro='pl' ;;
    Portuguese)
      LANG_FILE="${GDL_DIR}/lang/portuguese.conf" lib='pt' bro='pt-pt' ;;
    Portuguese-Brazilian)
      LANG_FILE="${GDL_DIR}/lang/portuguese-br.conf" lib='pt-br' bro='pt-br' ;;
    Romanian) LANG_FILE="${GDL_DIR}/lang/romanian.conf" lib='ro' bro='ro' ;;
    Russian) LANG_FILE="${GDL_DIR}/lang/russian.conf" lib='ru' bro='ru' ;;
    Spanish) LANG_FILE="${GDL_DIR}/lang/spanish.conf" lib='es' bro='es-es' ;;
    Swedish) LANG_FILE="${GDL_DIR}/lang/swedish.conf" lib='sv' bro='sv-se' ;;
    *) LANG_FILE="${GDL_DIR}/lang/english.conf" ;;
  esac
  source "${LANG_FILE}"
  RELOAD_LANG_TEXT='true'
  log "Set language to: ${language}"
}

set_keymap() {
  TITLE="${key_op_msg}"
  local keymap_list
  keymap_list="$(find /usr/share/kbd/keymaps -type f | sed -n -e 's!^.*/!!p' |
    grep '.map.gz' | sed 's/.map.gz//g' | sed 's/$/ ->/g' | sort)"

  while true; do
    # shellcheck disable=SC2086
    if KEYMAP="$(dialog --no-cancel --ok-button "${ok}" --menu \
        "\n${keys_msg}" 18 60 10 \
        "us" "United States" \
        "uk" "United Kingdom" \
        "sv" "Swedish" \
        "slovene" "Slovenian" \
        "ru" "Russian" \
        "ro" "Romanian" \
        "pt-latin9" "Portugal" \
        "it" "Italian" \
        "hu" "Hungarian" \
        "fr" "French" \
        "es" "Spanish" \
        "el" "Greek" \
        "de" "German" \
        "${other}" "${other}-keymaps")"; then
      if [[ "${KEYMAP}" != "${other}" ]] ||
          KEYMAP="$(dialog --ok-button "${ok}" --cancel-button "${cancel}" \
          --menu "\n${keys_msg}" 19 60 10 ${keymap_list})"; then
        break
      fi
    fi
  done
  localectl set-keymap "${KEYMAP}"
  loadkeys "${KEYMAP}"
  log "Set keymap to: ${KEYMAP}"
}

update_mirrors() {
  TITLE="${mirror_op_msg}"
  local mirrors_option editor

  if ! nc -zw1 1.1.1.1 443; then
    nmtui # attempt to connect to Wi-Fi if not already connected to the internet
  fi
  timedatectl set-ntp true # ensure system clock is accurate
  while true; do
    if mirrors_option="$(dialog --no-cancel --ok-button "${ok}" --menu \
        "\n${mirror_msg0}" 12 60 3 \
        "${skip_mirrors_msg}" '->' \
        "${update_mirrors_msg}" '->' \
        "${manual_mirrors_msg}" '->')"; then
      case "${mirrors_option}" in
        "${update_mirrors_msg}") # update mirrors automatically via reflector
          clear
          dragonsay "Updating mirrors..."
          reflector --verbose --latest 20 --protocol https --sort rate --save \
            /etc/pacman.d/mirrorlist
          log "Mirrors updated automatically"
          break
          ;;
        "${manual_mirrors_msg}") # update mirrors manually via text editor
          if editor="$(dialog --ok-button "${ok}" --cancel-button "${cancel}" \
              --menu "\n${mirror_editor_msg}" 11 60 2 \
              'nano' "${nano_msg}" \
              'vim' "${vim_msg}")"; then
            "${editor}" /etc/pacman.d/mirrorlist
            log "Mirrors updated manually"
            break
          fi
          ;;
        *) break ;;
      esac
    fi
  done
}

set_locale() {
  TITLE="${locale_op_msg}"
  local locale_list
  locale_list="$(grep -E "^#?[a-z].*UTF-8" /etc/locale.gen | sed 's/#//' |
    awk '{print $1" ->"}')"

  while true; do
    # shellcheck disable=SC2086
    if LOCALE="$(dialog --no-cancel --ok-button "${ok}" --menu \
        "\n${locale_msg}" 18 60 10 \
        "de_DE.UTF-8" "German" \
        "el_GR.UTF-8" "Greek" \
        "en_AU.UTF-8" "English (Australia)" \
        "en_CA.UTF-8" "English (Canada)" \
        "en_GB.UTF-8" "English (UK)" \
        "en_US.UTF-8" "English (US)" \
        "es_ES.UTF-8" "Spanish (Spain)" \
        "es_MX.UTF-8" "Spanish (Mexico)" \
        "fr_FR.UTF-8" "French" \
        "hu_HU.UTF-8" "Hungarian" \
        "it_IT.UTF-8" "Italian" \
        "lv_LV.UTF-8" "Latvian" \
        "pt_BR.UTF-8" "Portuguese (Brazil)" \
        "pt_PT.UTF-8" "Portuguese (Portugal)" \
        "ro_RO.UTF-8" "Romanian" \
        "ru_RU.UTF-8" "Russian" \
        "sv_SE.UTF-8" "Swedish" \
        "${other}" "${other}-locale")"; then
      if [[ "${LOCALE}" != "${other}" ]] ||
          LOCALE="$(dialog --ok-button "${ok}" --cancel-button "${cancel}" \
          --menu "\n${locale_msg}" 19 60 10 ${locale_list})"; then
        break
      fi
    fi
  done
  log "Set locale to: ${LOCALE}"
}

set_time_zone() {
  TITLE="${zone_op_msg}"
  local zonelist sublist subzone subsubzone
  zonelist="$(find /usr/share/zoneinfo -maxdepth 1 | sed -n -e 's!^.*/!!p' |
    grep -Ev 'posix|posixrules|right|zoneinfo|.*tab|W-SU|WET|MST7MDT|CST6CDT' |
    sort | sed 's/$/ ->/g')"

  while true; do
    # shellcheck disable=SC2086
    ZONE="$(dialog --no-cancel --ok-button "${ok}" --menu "\n${zone_msg0}" \
      18 60 10 ${zonelist})"
    if find /usr/share/zoneinfo -maxdepth 1 -type d | sed -n -e 's!^.*/!!p' |
        grep -q "${ZONE}"; then
      sublist="$(find /usr/share/zoneinfo/"${ZONE}" -maxdepth 1 |
        sed -n -e 's!^.*/!!p' | sort | sed 's/$/ ->/g' | grep -v "${ZONE}")"
      # shellcheck disable=SC2086
      if subzone="$(dialog --ok-button "${ok}" --cancel-button "${back}" \
          --menu "\n${zone_msg1}" 18 60 10 ${sublist})"; then
        if find /usr/share/zoneinfo/"${ZONE}" -maxdepth 1 -type d |
            sed -n -e 's!^.*/!!p' | grep -q "${subzone}"; then
          sublist="$(find /usr/share/zoneinfo/"${ZONE}/${subzone}" \
            -maxdepth 1 | sed -n -e 's!^.*/!!p' | sort | sed 's/$/ ->/g' |
            grep -v "${subzone}")"
          # shellcheck disable=SC2086
          if subsubzone="$(dialog --ok-button "${ok}" --cancel-button \
              "${back}" --menu "\n${zone_msg1}" 15 60 7 ${sublist})"; then
            ZONE="${ZONE}/${subzone}/${subsubzone}"
            break
          fi
        else
          ZONE="${ZONE}/${subzone}"
          break
        fi
      fi
    else
      break
    fi
  done
  log "Set time zone to: ${ZONE}"
}

prepare_drives() {
  TITLE="${part_op_msg}"
  local partition_method partition_prefix drive_bytes drive_mib drive_gib \
    drive_menu_header='              Device    Size    Type'

  log "Initial partition layout:"
  lsblk -o NAME,SIZE,TYPE,MOUNTPOINTS,FSTYPE,FSVER,FSUSE% | log
  if df | grep -q '/mnt'; then
    (
      umount -R /mnt
      swapoff -a
    ) &>/dev/null &
    load_bar "${wait_load}\n\n \Z1> \Z2umount -R /mnt\Zn"
  fi

  until "${MOUNTED}"; do
    GPT='false'
    UEFI='false'
    DRIVE=''
    ROOT=''
    BOOT=''
    ESP_MNT=''

    # Present the main partitioning menu
    if ! partition_method="$(dialog --no-cancel --ok-button "${ok}" --menu \
        "\n${part_msg}" 15 64 3 \
        "${method_auto}" '->' \
        "${method_auto_encrypt}" '->' \
        "${method_manual}" '->')"; then
      continue

    # If an auto-partitioning option is selected, prepare drive-selection menu
    elif [[ "${partition_method}" != "${method_manual}" ]]; then
      rm /tmp/gdl/part.sh &>/dev/null # remove old temp file (if one exists)
      # shellcheck disable=SC2028
      if "${INCLUDE_BACKTITLE}"; then
        echo "dialog --stdout --colors --backtitle \"${BACKTITLE}\" --title \" \
${TITLE} \" --ok-button \"${ok}\" --cancel-button \"${cancel}\" --menu \
\"\n${drive_msg}\n\n ${drive_menu_header}\" 16 60 5 \\" >/tmp/gdl/part.sh
      else
        echo "dialog --stdout --colors --title \" ${TITLE} \" --ok-button \
\"${ok}\" --cancel-button \"${cancel}\" --menu \"\n${drive_msg}\n\n \
${drive_menu_header}\" 16 60 5 \\" >/tmp/gdl/part.sh
      fi
      lsblk -nio NAME,SIZE,TYPE | grep -E "disk|raid[0-9]+$" |
        sed 's/[^[:alnum:]_., ]//g' | column -t | sort -k 1,1 | uniq |
        awk '{print "\""$1"\"""  ""\"| "$2" | "$3"     \""" \\"}' |
        column -t >>/tmp/gdl/part.sh

      # Present the drive-selection and filesystem-selection menus
      DRIVE="$(bash /tmp/gdl/part.sh)" || continue
      FS="$(get_filesystem)" || continue

      # Check the selected drive's properties
      if grep -Eq 'nvme|mmc|md' <<<"${DRIVE}"; then
        partition_prefix='p'
      else
        partition_prefix=''
      fi
      drive_bytes="$(lsblk -nibo NAME,SIZE | grep -w "${DRIVE}" |
        awk '{print $2}')"
      drive_mib=$(( drive_bytes / 1024 / 1024 ))
      drive_gib=$(( drive_mib / 1024 ))
      log "Drive size in MiB: ${drive_mib}"
      if efivar -l &>/dev/null && yesno "${efi_msg0}" "${yes}" "${no}"; then
        GPT='true'
        UEFI='true'
        log "UEFI boot and GPT partition scheme activated"
      fi
      if ! "${UEFI}" && yesno "${gpt_msg}" "${yes}" "${no}" 'defaultno'; then
        GPT='true'
        log "GPT partition scheme activated"
      fi

      # Set swap size
      SWAP_SIZE='0'
      if yesno "${swap_msg0}" "${yes}" "${no}" 'defaultno'; then
        while true; do
          SWAP_SIZE=$(dialog --ok-button "${ok}" --cancel-button "${cancel}" \
            --inputbox "\n${swap_msg1}" 11 55 '512M') || break
          if grep -q 'M$' <<<"${SWAP_SIZE}"; then
            SWAP_SIZE="$(sed 's/M//;s/\..*//' <<<"${SWAP_SIZE}")"
          elif grep -q 'G$' <<<"${SWAP_SIZE}"; then
            SWAP_SIZE="$(echo "${SWAP_SIZE/G} * 1024" | bc | sed 's/\..*//')"
          else
            message "${swap_err_msg1}"
            continue
          fi
          if (( SWAP_SIZE > drive_mib - 9216 )); then
            message "${swap_err_msg0}"
          else
            break
          fi
        done
      fi
      log "Swap size set to: ${SWAP_SIZE} MiB"

      # Format the selected drive (or go back to the main partitioning menu)
      source "${LANG_FILE}"
      if yesno "${drive_var_msg}" "${write}" "${cancel}" 'defaultno'; then
        (
          sgdisk --zap-all /dev/"${DRIVE}"
          wipefs -a /dev/"${DRIVE}"
        ) &>/dev/null &
        load_bar "${frmt_load}\n\n \Z1> \Z2sgdisk --zap-all /dev/${DRIVE}\Zn"
        log "Device formatted: /dev/${DRIVE}"
      else
        continue # back to the top of 'prepare_drives'
      fi
    fi

    # Go to the appropriate sub-function
    case "${partition_method}" in
      "${method_auto}")
        log "User chose automatic partitioning"
        auto_partition
        if ! "${MOUNTED}"; then
          message "${part_err_msg}"
        fi
        ;;
      "${method_auto_encrypt}")
        log "User chose automatic partitioning with encrypted LVM"
        auto_partition_with_encryption
        if ! "${MOUNTED}"; then
          message "${part_err_msg}"
        fi
        ;;
      "${method_manual}")
        log "User chose manual partitioning"
        manual_partition_menu
        ;;
    esac
  done
  log "Final partition layout:"
  lsblk -o NAME,SIZE,TYPE,MOUNTPOINTS,FSTYPE,FSVER,FSUSE% | log
}

auto_partition() {
  TITLE="${partload_op_msg}"

  # Create partitions
  if "${GPT}"; then
    if "${UEFI}"; then # UEFI/GPT
      if (( SWAP_SIZE > 0 )); then
        echo -e \
          "n\n\n\n512M\nef00\nn\n3\n\n+${SWAP_SIZE}M\n8200\nn\n\n\n\n\nw\ny" |
          gdisk /dev/"${DRIVE}" &>/dev/null &
        load_bar "${load_var0}\n\n \Z1> \Z2gdisk /dev/${DRIVE}\Zn"
        format_swap_partition "${DRIVE}${partition_prefix}3"
      else # no swap
        echo -e "n\n\n\n512M\nef00\nn\n\n\n\n\nw\ny" |
          gdisk /dev/"${DRIVE}" &>/dev/null &
        load_bar "${load_var0}\n\n \Z1> \Z2gdisk /dev/${DRIVE}\Zn"
      fi
      BOOT="${DRIVE}${partition_prefix}1"
      ROOT="${DRIVE}${partition_prefix}2"
    else # BIOS/GPT
      if (( SWAP_SIZE > 0 )); then
        echo -e "o\ny\nn\n1\n\n+212M\n\nn\n2\n\n+1M\nEF02\nn\n4\n\n+\
${SWAP_SIZE}M\n8200\nn\n3\n\n\n\nw\ny" | gdisk /dev/"${DRIVE}" &>/dev/null &
        load_bar "${load_var0}\n\n \Z1> \Z2gdisk /dev/${DRIVE}\Zn"
        format_swap_partition "${DRIVE}${partition_prefix}4"
      else # no swap
        echo -e "o\ny\nn\n1\n\n+212M\n\nn\n2\n\n+1M\nef02\nn\n3\n\n\n\nw\ny" |
          gdisk /dev/"${DRIVE}" &>/dev/null &
        load_bar "${load_var0}\n\n \Z1> \Z2gdisk /dev/${DRIVE}\Zn"
      fi
      BOOT="${DRIVE}${partition_prefix}1"
      ROOT="${DRIVE}${partition_prefix}3"
    fi
  else # BIOS/MBR
    if (( SWAP_SIZE > 0 )); then
      echo -e "o\nn\np\n1\n\n+212M\nn\np\n3\n\n+${SWAP_SIZE}M\nt\n\n82\nn\np\n2\
\n\n\nw" | fdisk /dev/"${DRIVE}" &>/dev/null &
      load_bar "${load_var0}\n\n \Z1> \Z2fdisk /dev/${DRIVE}\Zn"
      format_swap_partition "${DRIVE}${partition_prefix}3"
    else # no swap
      echo -e "o\nn\np\n1\n\n+212M\nn\np\n2\n\n\nw" |
        fdisk /dev/"${DRIVE}" &>/dev/null &
      load_bar "${load_var0}\n\n \Z1> \Z2fdisk /dev/${DRIVE}\Zn"
    fi
    BOOT="${DRIVE}${partition_prefix}1"
    ROOT="${DRIVE}${partition_prefix}2"
  fi
  log "Created boot partition: ${BOOT}"
  log "Created root partition: ${ROOT}"

  # Format partitions
  if "${UEFI}"; then
    (
      sgdisk --zap-all /dev/"${BOOT}"
      wipefs -a /dev/"${BOOT}"
      mkfs.vfat -F32 /dev/"${BOOT}"
    ) &>/dev/null &
    load_bar "${efi_load}\n\n \Z1> \Z2mkfs.vfat -F32 /dev/${BOOT}\Zn"
    ESP_MNT='/boot'
    log "EFI system partition (ESP): ${BOOT}"
    log "ESP mount point: ${ESP_MNT}"
    log "Created boot filesystem: vfat"
  else # BIOS
    (
      sgdisk --zap-all /dev/"${BOOT}"
      wipefs -a /dev/"${BOOT}"
      # shellcheck disable=SC1001
      mkfs.ext4 -O \^64bit /dev/"${BOOT}"
    ) &>/dev/null &
    load_bar "${boot_load}\n\n \Z1> \Z2mkfs.ext4 /dev/${BOOT}\Zn"
    log "Boot mount point set to: /boot"
    log "Created boot filesystem: ext4"
  fi
  (
    sgdisk --zap-all /dev/"${ROOT}"
    wipefs -a /dev/"${ROOT}"
    mkfs."${FS}" /dev/"${ROOT}"
  ) &>/dev/null &
  load_bar "${load_var1}\n\n \Z1> \Z2mkfs.${FS} /dev/${ROOT}\Zn"
  log "Created root filesystem: ${FS}"

  # Mount partitions
  if mount /dev/"${ROOT}" /mnt &>/dev/null; then
    log "Mounted /dev/${ROOT} at /mnt"
    mkdir /mnt/boot
    if mount /dev/"${BOOT}" /mnt/boot &>/dev/null; then
      log "Mounted /dev/${BOOT} at /mnt/boot"
      MOUNTED='true'
    else
      log "ERROR: Mounting /dev/${BOOT} at /mnt/boot failed"
    fi
  else
    log "ERROR: Mounting /dev/${ROOT} at /mnt failed"
  fi
}

auto_partition_with_encryption() {
  TITLE="${partload_op_msg}"
  local input input_check

  # Set encryption password
  if yesno "${encrypt_var0}" "${yes}" "${no}" 'defaultno'; then
    while true; do
      if ! input="$(dialog --no-cancel --clear --insecure --passwordbox \
          "\n${encrypt_var1}" 12 55)" ||
          ! input_check="$(dialog --no-cancel --clear --insecure --passwordbox \
          "\n${encrypt_var2}" 12 55)" ||
          [[ -z "${input}" ]]; then
        message "${passwd_msg0}"
      elif [[ "${input}" != "${input_check}" ]]; then
        message "${passwd_msg1}"
      else
        break
      fi
    done
  else
    return # back to 'prepare_drives'
  fi

  # Set up physical partitions
  if "${GPT}"; then
    if "${UEFI}"; then # UEFI/GPT
      echo -e "n\n\n\n512M\nef00\nn\n\n\n\n\nw\ny" |
        gdisk /dev/"${DRIVE}" &>/dev/null &
      load_bar "${load_var0}\n\n \Z1> \Z2gdisk /dev/${DRIVE}\Zn"
      BOOT="${DRIVE}${partition_prefix}1"
      ROOT="${DRIVE}${partition_prefix}2"
    else # BIOS/GPT
      echo -e "o\ny\nn\n1\n\n+512M\n\nn\n2\n\n+1M\nef02\nn\n3\n\n\n\nw\ny" |
        gdisk /dev/"${DRIVE}" &>/dev/null &
      load_bar "${load_var0}\n\n \Z1> \Z2gdisk /dev/${DRIVE}\Zn"
      BOOT="${DRIVE}${partition_prefix}1"
      ROOT="${DRIVE}${partition_prefix}3"
    fi
  else # BIOS/MBR
    echo -e "o\nn\np\n1\n\n+512M\nn\np\n2\n\n\nw" |
      fdisk /dev/"${DRIVE}" &>/dev/null &
    load_bar "${load_var0}\n\n \Z1> \Z2fdisk /dev/${DRIVE}\Zn"
    BOOT="${DRIVE}${partition_prefix}1"
    ROOT="${DRIVE}${partition_prefix}2"
  fi
  log "Created boot partition: ${BOOT}"
  log "Created root partition: ${ROOT}"
  (
    sgdisk --zap-all /dev/"${ROOT}"
    sgdisk --zap-all /dev/"${BOOT}"
    wipefs -a /dev/"${ROOT}"
    wipefs -a /dev/"${BOOT}"
  ) &>/dev/null &
  load_bar "${frmt_load}\n\n \Z1> \Z2wipefs -a /dev/${ROOT}\Zn"
  log "Wiped boot and root partitions"
  (
    lvm pvcreate /dev/"${ROOT}"
    lvm vgcreate lvm /dev/"${ROOT}"
  ) &>/dev/null &
  load_bar "${pv_load}\n\n \Z1> \Z2lvm pvcreate /dev/${ROOT}\Zn"
  log "Created physical root volume: /dev/${ROOT}"

  # Set up logical volumes
  if (( SWAP_SIZE > 0 )); then
    lvm lvcreate -L "${SWAP_SIZE}M" -n swap lvm &>/dev/null &
    load_bar \
      "${swap_load}\n\n \Z1> \Z2lvm lvcreate -L ${SWAP_SIZE}M -n swap lvm\Zn"
    log "Created logical swap space"
  fi
  (
    lvm lvcreate -L 500M -n tmp lvm
    lvm lvcreate -l 100%FREE -n lvroot lvm
  ) &>/dev/null &
  load_bar "${lv_load}\n\n \Z1> \Z2lvm lvcreate -l 100%FREE -n lvroot lvm\Zn"
  log "Created logical root volume: lvroot"
  log "Created logical tmp filesystem: tmp"
  (
    printf "%s" "${input}" |
      cryptsetup luksFormat -c aes-xts-plain64 -s 512 /dev/lvm/lvroot -
    printf "%s" "${input}" | cryptsetup open --type luks /dev/lvm/lvroot root -
  ) &>/dev/null &
  load_bar "${encrypt_load}\n\n \Z1> \Z2cryptsetup luksFormat -c \
aes-xts-plain64 -s 512 /dev/lvm/lvroot\Zn"
  unset input input_check
  log "Encrypted logical volume: lvroot"
  (
    wipefs -a /dev/mapper/root
    mkfs."${FS}" /dev/mapper/root
  ) &>/dev/null &
  load_bar "${load_var1}\n\n \Z1> \Z2mkfs.${FS} /dev/mapper/root\Zn"
  log "Created root filesystem: ${FS}"

  # Format boot partition (unencrypted)
  if "${UEFI}"; then
    mkfs.vfat -F32 /dev/"${BOOT}" &>/dev/null &
    load_bar "${efi_load}\n\n \Z1> \Z2mkfs.vfat -F32 /dev/${BOOT}\Zn"
    ESP_MNT='/boot'
    log "EFI system partition (ESP): ${BOOT}"
    log "ESP mount point: ${ESP_MNT}"
    log "Created boot filesystem: vfat"
  else # BIOS
    # shellcheck disable=SC1001
    mkfs.ext4 -O \^64bit /dev/"${BOOT}" &>/dev/null &
    load_bar "${boot_load}\n\n \Z1> \Z2mkfs.ext4 /dev/${BOOT}\Zn"
    log "Created boot filesystem: ext4"
  fi

  # Mount partitions
  if mount /dev/mapper/root /mnt &>/dev/null; then
    log "Mounted /dev/mapper/root at /mnt"
    mkdir /mnt/boot
    if mount /dev/"${BOOT}" /mnt/boot &>/dev/null; then
      log "Mounted /dev/${BOOT} at /mnt/boot"
      MOUNTED='true'
      ENCRYPTED='true'
    else
      log "ERROR: Mounting /dev/${BOOT} at /mnt/boot failed"
    fi
  else
    log "ERROR: Mounting /dev/mapper/root at /mnt failed"
  fi
}

manual_partition_menu() {
  local -i counter device_count
  local device dev_list dev_size dev_type dev_fs dev_mnt dev_used dev_parent \
    dev_menu_header='           Device   Size   Used   FS   Mount   Type' \
    part part_size part_type part_fs part_mount part_final disk_util \
    empty_value='----'

  while true; do
    # Prepare the manual partitioning menu via temp files part.sh/part.list
    TITLE="${manual_op_msg}"
    rm /tmp/gdl/part.sh /tmp/gdl/part.list &>/dev/null # rm old files (if any)
    dev_list="$(lsblk -no NAME,SIZE,TYPE,FSTYPE |
      grep -Ev "${USB}|loop[0-9]+|sr[0-9]+|fd[0-9]+" |
      sed 's/[^[:alnum:]_., -]//g' | column -t | sort -k 1,1 | uniq)"
    device_count="$(wc -l <<<"${dev_list}")"
    if "${INCLUDE_BACKTITLE}"; then
      # shellcheck disable=SC2028
      echo "dialog --stdout --colors --backtitle \"${BACKTITLE}\" --title \
\" ${TITLE} \" --ok-button \"${edit}\" --cancel-button \"${cancel}\" --menu \
\"\n${manual_part_msg}\n\n${dev_menu_header}\" 21 68 9 \\" >/tmp/gdl/part.sh
    else
      # shellcheck disable=SC2028
      echo "dialog --stdout --colors --title \" ${TITLE} \" --ok-button \
\"${edit}\" --cancel-button \"${cancel}\" --menu \"\n${manual_part_msg}\n
${dev_menu_header}\" 20 68 8 \\" >/tmp/gdl/part.sh
    fi
    counter=1
    until (( counter > device_count )); do
      device="$(awk <<<"${dev_list}" '{print $1}' | awk "NR==${counter}")"
      dev_size="$(grep -w "${device}" <<<"${dev_list}" | awk '{print $2}')"
      dev_type="$(grep -w "${device}" <<<"${dev_list}" | awk '{print $3}')"
      dev_fs="$(grep -w "${device}" <<<"${dev_list}" | awk '{print $4}')"
      dev_mnt="$(df | grep -w "${device}" | awk '{print $6}' |
        sed 's/mnt\/\?//')"
      if grep -q '/' <<<"${dev_mnt}"; then
        dev_used="$(df -T | grep -w "${device}" | awk '{print $6}')"
      else
        dev_used=$(swapon -s | grep -w "${device}" | awk '{print $4}')
        if [[ -n "${dev_used}" ]]; then
          dev_used="${dev_used}%"
        fi
      fi
      [[ -z "${dev_fs}" || "${dev_fs}" == "linux_raid_member" ]] &&
        dev_fs="${empty_value}"
      [[ -z "${dev_used}" ]] && dev_used="${empty_value}"
      [[ -z "${dev_mnt}" ]] && dev_mnt="${empty_value}"
      dev_parent="$(lsblk -dnro PKNAME /dev/"${device/-//}")"
      if [[ -z "${dev_parent}" ]]; then
        dev_type="$(grep -w "${device}" <<<"${dev_list}" | awk '{print $3}')"
      else
        dev_type="$(fdisk -lo Device,Type /dev/"${dev_parent}" |
          grep -w "${device}" | cut -d ' ' -f 2- |
          sed -e 's/^[[:space:]]*//;s/[[:space:]]*$//;s/ /_/g')"
      fi
      echo "\"${device}\" \"${dev_size} ${dev_used} ${dev_fs} ${dev_mnt} \
${dev_type}\" \\" >>/tmp/gdl/part.list
      (( ++counter ))
    done
    column </tmp/gdl/part.list -t >>/tmp/gdl/part.sh
    echo -e "\"${done_msg}\" \"${write}\"" >>/tmp/gdl/part.sh

    # Present the manual partitioning menu and get user input
    if ! part="$(bash /tmp/gdl/part.sh | sed 's/^\s\+//g;s/\s\+$//g')" ||
        [[ -z "${part}" ]]; then
      MOUNTED='false'
      return # back to 'prepare_drives'
    fi
    log "Manual partitioning menu selection: ${part}"

    # If user selected 'done', attempt to finish the partitioning process
    if [[ "${part}" == "${done_msg}" ]]; then
      if ! "${MOUNTED}"; then
        message "${root_err_msg1}"
        continue # back to the top of 'manual_partition_menu'
      elif "${GPT}" && ! "${UEFI}" && ! fdisk -l | grep -q 'BIOS boot'; then
        message "${gpt_bios_err_msg}"
        continue
      elif [[ -z "${BOOT}" ]]; then
        BOOT="${ROOT}"
      fi
      part_final="$( (df -h | grep '/mnt' | awk '{print $1,$2,$6 "\\n"}' |
        sed 's/mnt\/\?//'; swapon | awk 'NR==2 {print $1,$3,"SWAP"}') |
        column -t)"
      yesno "${write_confirm_msg}\n\n${partition}  ${size}  ${mountpoint}\n
${part_final}" "${ok}" "${cancel}" 'defaultno' || continue
      return # all done: return to 'prepare_drives'
    fi

    # If not 'done', prepare and present a disk/partition editing menu
    TITLE="${edit_op_msg}"
    part_size="$(grep -w "${part}" <<<"${dev_list}" | awk '{print $2}')"
    part_type="$(grep -w "${part}" <<<"${dev_list}" | awk '{print $3}')"
    part_fs="$(grep -w "${part}" <<<"${dev_list}" | awk '{print $4}')"
    part_mount="$(df | grep -w "${part}" | awk '{print $6}' |
      sed 's/mnt\/\?//')"
    if [[ "${part_fs}" == "linux_raid_member" ]]; then
      continue # back to the top of 'manual_partition_menu'
    elif [[ "${part_type}" == "lvm" ]]; then
      part="${part/-//}"
    fi

    # If user selected an entire disk, facilitate disk partitioning
    if [[ "${part_type}" == "disk" ]] ||
        (grep -Eq 'raid[0-9]+' <<<"${part_type}" && [[ -z "${part_fs}" ]]); then
      source "${LANG_FILE}"
      if df | grep -w "${part}" | grep -q '/mnt' &&
          yesno "${mount_warn_var}" "${edit}" "${cancel}" 'defaultno'; then
        (
          umount -R /mnt
          swapoff -a
        ) &>/dev/null &
        load_bar "${wait_load}\n\n \Z1> \Z2umount -R /mnt\Zn"
        MOUNTED='false'
        DRIVE=''
        if disk_util="$(get_disk_util)"; then
          clear
          "${disk_util}" /dev/"${part}"
          log "Disk /dev/${part} edited via ${disk_util}"
          clear
        fi
      elif yesno "${manual_part_var3}" "${edit}" "${cancel}" &&
          disk_util="$(get_disk_util)"; then
        clear
        "${disk_util}" /dev/"${part}"
        log "Disk /dev/${part} edited via ${disk_util}"
        clear
      fi

    # If user selected a partition or md device, facilitate mounting/formatting
    else
      source "${LANG_FILE}"
      # The root '/' mount point must be established before others
      if [[ -z "${ROOT}" ]]; then
        case "${part_size}" in
          [1-9]T | 9G | [1-9][0-9]*[GT] | 9.*[GT] | 9,*[GT])
            # shellcheck disable=SC2015
            yesno "${root_var}" "${yes}" "${no}" 'defaultno' &&
              FS="$(get_filesystem)" || continue # back to top if either fails
            source "${LANG_FILE}"
            if yesno "${root_confirm_var}" "${write}" "${cancel}" 'defaultno'
            then
              (
                sgdisk --zap-all /dev/"${part}"
                wipefs -a /dev/"${part}"
                mkfs."${FS}" /dev/"${part}"
              ) &>/dev/null &
              load_bar "${load_var1}\n\n \Z1> \Z2mkfs.${FS} /dev/${part}\Zn"
              if mount /dev/"${part}" /mnt &>/dev/null; then
                log "Mounted /dev/${part} at /mnt"
                MOUNTED='true'
                ROOT="${part}"
                if [[ "${part_type}" == "lvm" ]]; then
                  lvm_pv="$(lvdisplay -m | grep -A 20 /dev/"${part}" |
                    grep 'Physical volume' | sed 's/^\s\+//g;s/\s\+/ /g' |
                    cut -d ' ' -f 3)"
                  DRIVE="$(lsblk -dnro PKNAME "${lvm_pv}")"
                else
                  DRIVE="$(lsblk -dnro PKNAME /dev/"${part}")"
                fi
                if parted /dev/"${DRIVE}" print | grep -q 'Table: gpt'; then
                  GPT='true'
                else
                  GPT='false'
                fi
              else
                MOUNTED='false'
                log "ERROR: Mounting /dev/${part} at /mnt failed"
                message "${part_err_msg1}"
                return # back to 'prepare_drives'
              fi
            fi
            ;;
          *) message "${root_err_msg}" ;;
        esac
      # If the partition's already mounted, provide suitable options
      elif [[ -n "${part_mount}" ]]; then
        if yesno "${manual_part_var0}" "${edit}" "${back}" 'defaultno'; then
          if [[ "${part}" == "${ROOT}" ]]; then
            if yesno "${manual_part_var2}" "${yes}" "${no}" 'defaultno'; then
              MOUNTED='false'
              ROOT=''
              DRIVE=''
              umount -R /mnt &>/dev/null &
              load_bar "${wait_load}\n\n \Z1> \Z2umount -R /mnt\Zn"
            fi
          else
            if [[ "${part_mount}" == "[SWAP]" ]] &&
                yesno "${manual_swap_var}" "${yes}" "${no}" 'defaultno'; then
              swapoff /dev/"${part}" &>/dev/null &
              load_bar "${wait_load}\n\n \Z1> \Z2swapoff /dev/${part}\Zn"
            elif yesno "${manual_part_var1}" "${yes}" "${no}" 'defaultno'; then
              umount /mnt/"${part_mount}" &>/dev/null &
              load_bar "${wait_load}\n\n \Z1> \Z2umount /mnt/${part_mount}\Zn"
              rm -r /mnt/"${part_mount:?}"
              if [[ "${part}" == "${BOOT}" ]]; then
                BOOT=''
              fi
            fi
          fi
        fi
      # If it's a swap partition, optionally format and attempt to 'swapon'
      elif (( $(fdisk -l | grep -w "${part}" | sed 's/\*//' |
              awk '{print $6}') == 82 )) ||
          (fdisk -l /dev/"$(lsblk -dnro PKNAME /dev/"${part}")" |
           grep -q 'gpt' && [[ "$(fdisk -l -o Device,Size,Type-UUID |
           grep -w "${part}" | awk '{print $3}')" == \
           "0657FD6D-A4AB-43C4-84E5-0933C84B4F4F" ]]); then
        if yesno "${swap_frmt_msg}" "${yes}" "${no}"; then
          format_swap_partition "${part}"
        elif ! swapon /dev/"${part}" &>/dev/null; then
          message "${swap_err_msg2}"
        fi
      # If the partition's not yet mounted, provide mount point options
      elif yesno "${manual_new_part_var}" "${edit}" "${back}"; then
        mnt="$(dialog --ok-button "${ok}" --cancel-button "${cancel}" \
          --menu "\n${mnt_var0}" 15 60 6 \
          '/home' '->' \
          '/boot' '->' \
          '/efi' '->' \
          '/opt' '->' \
          '/usr' '->' \
          '/var' '->' \
          '/tmp' '->' \
          "${custom}" '->')" || continue # back to the top if user cancels
        if [[ "${mnt}" == "${custom}" ]]; then
          while true; do
            mnt="$(dialog --ok-button "${ok}" --cancel-button "${cancel}" \
              --inputbox "\n${custom_msg}" 10 50 '/')" || continue 2
            if grep -q "[\[\$\!\'\"\`\\|%&#@()+=<>~;:?.,^{}]\|]" <<<"${mnt}"
            then
              message "${custom_err_msg0}"
            elif [[ "${mnt}" == '/' ]]; then
              message "${custom_err_msg1}"
            else
              [[ "${mnt}" =~ ^/.+ ]] || mnt="/${mnt}"
              break
            fi
          done
        fi
        # Provide formatting options
        if yesno "${part_frmt_msg}" "${yes}" "${no}" 'defaultno'; then
          if grep -q '/efi$' <<<"${mnt}" ||
              fdisk -l | grep "${part}" | grep -q 'EFI'; then
            FS="$(dialog --menu "\n${vfat_msg}" 12 65 1 'vfat' "${fs_fat}")" ||
              continue # back to the top if user cancels
            UEFI='true'
            ESP_MNT="${mnt}"
          else
            FS="$(get_filesystem)" || continue # back to top if user cancels
          fi
          log "Selected filesystem for ${mnt}: ${FS}"
          source "${LANG_FILE}"
          yesno "${part_confirm_var}" "${write}" "${cancel}" 'defaultno' ||
            continue # back to the top if user cancels
          (
            sgdisk --zap-all /dev/"${part}"
            wipefs -a /dev/"${part}"
            case "${FS}" in
              vfat) mkfs.vfat -F32 /dev/"${part}" ;;
              *) mkfs."${FS}" /dev/"${part}" ;;
            esac
          ) &>/dev/null &
          load_bar "${load_var1}\n\n \Z1> \Z2mkfs.${FS} /dev/${part}\Zn"
        fi
        if grep -q '/boot$' <<<"${mnt}"; then
          BOOT="${part}"
        fi
        # Attempt to mount the partition at the given mount point
        if mkdir -p /mnt"${mnt}" &&
            mount /dev/"${part}" /mnt"${mnt}" &>/dev/null; then
          log "Mounted /dev/${part} at /mnt${mnt}"
        else
          log "ERROR: Mounting /dev/${part} at /mnt${mnt} failed"
          message "${part_err_msg2}"
        fi
      fi
    fi
  done
}

get_filesystem() {
  dialog --no-cancel --menu "\n${fs_msg}" 12 60 3 \
    'ext4' "${fs_ext4}" \
    'btrfs' "${fs_btrfs}" \
    'xfs' "${fs_xfs}"
}

get_disk_util() {
  # shellcheck disable=SC2005
  dialog --menu "\n${part_util_msg}" 12 60 3 \
    'cfdisk' "${part_util0}" \
    'fdisk' "${part_util1}" \
    'gdisk' "${part_util2}"
}

format_swap_partition() {
  if (( $# == 0 )); then
    log "ERROR: No argument passed to 'format_swap_partition'"
  elif (( $# > 1 )); then
    log "ERROR: Multiple arguments passed to 'format_swap_partition' ($*)"
  else
    (
      wipefs -a /dev/"$1"
      mkswap /dev/"$1"
      swapon /dev/"$1"
    ) &>/dev/null &
    load_bar "${swap_load}\n\n \Z1> \Z2mkswap /dev/$1\Zn"
    log "Created and activated swap space: $1"
  fi
}

prepare_base() {
  TITLE="${install_op_msg}"
  local additional_packages

  if grep -q 'AuthenticAMD' /proc/cpuinfo; then
    BASE_PACKAGES+="amd-ucode "
    log "Added AMD microcode"
  elif grep -q 'GenuineIntel' /proc/cpuinfo; then
    BASE_PACKAGES+="intel-ucode "
    log "Added Intel microcode"
  fi
  if "${WIFI_AVAILABLE}" ||
      yesno "${wifi_option_msg}" "${yes}" "${no}" 'defaultno'; then
    BASE_PACKAGES+="wireless_tools wpa_supplicant "
    log "Added wireless utilities"
  fi
  if "${BLUETOOTH_AVAILABLE}"; then
    BASE_PACKAGES+="blueman bluez bluez-utils pulseaudio-bluetooth "
    log "Added bluetooth support"
  fi
  if yesno "${touchpad_msg}" "${yes}" "${no}" 'defaultno'; then
    BASE_PACKAGES+="xf86-input-libinput "
    log "Added touchpad support"
  fi
  if yesno "${os_prober_msg}" "${yes}" "${no}" 'defaultno'; then
    BASE_PACKAGES+="os-prober "
    log "Added os-prober"
  fi
  if "${UEFI}"; then
    BASE_PACKAGES+="efibootmgr "
    log "Added efibootmgr"
  fi

  # Graphics and VM packages
  source "${LANG_FILE}"
  if [[ "${VM_TYPE}" != 'none' ]]; then
    case "${VM_TYPE}" in
      qemu)
        additional_packages="spice-vdagent"
        log "Added QEMU guest utils: ${additional_packages}"
        ;;
      oracle)
        additional_packages="virtualbox-guest-utils"
        log "Added VirtualBox guest utils: ${additional_packages}"
        ;;
      vmware)
        additional_packages="xf86-video-vmware xf86-input-vmmouse open-vm-tools
          net-tools gtkmm"
        log "Added VMware guest utils: ${additional_packages}"
        ;;
      *)
        additional_packages="xf86-video-fbdev"
        log "Added generic VM guest utils: ${additional_packages}"
        ;;
    esac
  else
    if [[ "${GPU_CHIPSET}" == 'NVIDIA' ]]; then
      until additional_packages="$(dialog --ok-button "${ok}" --no-cancel \
          --menu "\n${graphics_msg}" 18 60 7 \
          "${default}" "${graphics_default}" \
          'nvidia' "${graphics_nvidia}" \
          'xf86-video-nouveau' "${graphics_nouveau}" \
          'xf86-video-intel' "${graphics_intel}" \
          'xf86-video-vesa' "${graphics_vesa}" \
          'xf86-video-ati' "${graphics_ati}" \
          'xf86-video-amdgpu' "${graphics_amd}")"; do
        continue
      done
    else
      until additional_packages="$(dialog --ok-button "${ok}" --no-cancel \
          --menu "\n${graphics_msg}" 17 60 6 \
          "${default}" "${graphics_default}" \
          'xf86-video-ati' "${graphics_ati}" \
          'xf86-video-amdgpu' "${graphics_amd}" \
          'xf86-video-intel' "${graphics_intel}" \
          'xf86-video-nouveau' "${graphics_nouveau}" \
          'xf86-video-vesa' "${graphics_vesa}")"; do
        continue
      done
    fi
    if [[ "${additional_packages}" == "${default}" ]]; then
      additional_packages="${DEFAULT_GPU_DRIVER}"
    fi
    if [[ "${additional_packages}" == 'nvidia' ]]; then
      additional_packages+=" nvidia-dkms nvidia-utils lib32-nvidia-utils
        nvidia-settings nvidia-libgl nvidia-prime"
    elif [[ "${additional_packages}" == 'xf86-video-ati' ||
            "${additional_packages}" == 'xf86-video-amdgpu' ]]; then
      additional_packages+=" vulkan-radeon lib32-vulkan-radeon"
    elif [[ "${additional_packages}" == 'xf86-video-intel' ]]; then
      additional_packages+=" vulkan-intel lib32-vulkan-intel
        lib32-libva-intel-driver"
    fi
    log "Added graphics driver packages: ${additional_packages}"
  fi
  BASE_PACKAGES+="${additional_packages} "
}

set_hostname() {
  TITLE="${host_op_msg}"
  while true; do
    if NEW_HOSTNAME="$(dialog --ok-button "${ok}" --no-cancel --inputbox \
        "\n${host_msg}" 12 55 "golden" | sed 's/ //g')" &&
        [[ -n "${NEW_HOSTNAME}" ]]; then
      # Check for a starting number or any unallowed characters
      if grep -q "^[0-9]\|[\[\$\!\'\"\`\\|%&#@()+=<>~;:/?.,^{}]\|]" \
          <<<"${NEW_HOSTNAME}"; then
        message "${host_err_msg}"
      else
        break
      fi
    fi
  done
}

set_user() {
  TITLE="${user_op_msg}"
  while true; do
    # Prompt for username
    if ! NEW_USERNAME="$(dialog --cancel-button "${cancel}" --ok-button \
        "${ok}" --inputbox "\n${user_msg1}" 12 55)" ||
        [[ -z "${NEW_USERNAME}" ]]; then
      message "${user_err_msg2}"
    elif grep -q "^[0-9]\|[A-Z]\|[]:/?#@\!\$&'()*+,;=%[]" <<<"${NEW_USERNAME}"
    then
      message "${user_err_msg}"
    else
      log "Username set: ${NEW_USERNAME}"
      while true; do
        # Prompt for full name
        if NEW_USER_FULL_NAME="$(dialog --cancel-button "${cancel}" \
            --ok-button "${ok}" --inputbox "\n${user_msg2}" 12 55)"; then
          if grep -q ',' <<<"${NEW_USER_FULL_NAME}"; then
            message "${full_name_err_msg}"
          else
            # Prompt for password ('root' will use the same password)
            set_password
            break
          fi
        fi
      done
      break
    fi
  done
}

set_password() {
  TITLE="${passwd_op_msg}"
  local input input_check

  source "${LANG_FILE}"
  while true; do
    if ! input="$(dialog --no-cancel --clear --insecure --passwordbox \
        "\n${user_var0}" 11 55)" ||
        ! input_check="$(dialog --no-cancel --clear --insecure --passwordbox \
        "\n${user_var1}" 11 55)" ||
        [[ -z "${input}" ]]; then
      message "${passwd_msg0}"
    elif [[ "${input}" != "${input_check}" ]]; then
      message "${passwd_msg1}"
    else
      break
    fi
  done
  NEW_PW="$(echo "${input}" | openssl enc -aes-256-cbc -a -salt -pbkdf2 \
    -iter 1000 -pass pass:"${SSL_KEY}")"
  unset input input_check
  log "Password set for user: ${NEW_USERNAME}"
}

select_additional_software() {
  local software=''

  # Misc. Games
  TITLE="Misc. ${games_software_title}"
  software+="$(dialog --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "lutris" "${software_lutris}" OFF \
    "steam" "${software_steam}" OFF \
    "itch" "(AUR) ${software_itch}" OFF \
    "legendary" "(AUR) ${software_legendary}" OFF \
    "playonlinux" "${software_playonlinux}" OFF \
    "libretro" "${software_libretro}" OFF \
    "dosbox" "${software_dosbox}" OFF \
    "scummvm" "${software_scummvm}" OFF) "
  if grep -q 'lutris' <<<"${software}"; then
    BASE_PACKAGES+="${LUTRIS_PACKAGES} " # install with base
  fi
  if grep -q 'steam' <<<"${software}"; then
    BASE_PACKAGES+='steam steam-native-runtime ' # install with base
  fi

  # Action Games
  TITLE="Action ${games_software_title}"
  software+="$(dialog --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "supertux" "${software_supertux}" OFF \
    "frogatto" "${software_frogatto}" OFF \
    "alex4" "${software_alex4}" OFF \
    "asciiportal" "${software_asciiportal}" OFF \
    "mari0" "${software_mari0}" OFF \
    "xonotic" "${software_xonotic}" OFF \
    "warsow" "${software_warsow}" OFF \
    "sauerbraten" "${software_sauerbraten}" OFF \
    "assaultcube-reloaded" "(AUR) ${software_assaultcube_reloaded}" OFF \
    "openarena" "(AUR) ${software_openarena}" OFF \
    "astromenace" "${software_astromenace}" OFF \
    "chromium-bsu" "${software_chromium_bsu}" OFF \
    "starfighter" "(AUR) ${software_starfighter}" OFF \
    "teeworlds" "${software_teeworlds}" OFF \
    "bzflag" "(AUR) ${software_bzflag}" OFF) "

  # Adventure Games
  TITLE="Adventure ${games_software_title}"
  software+="$(dialog --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "bass" "${software_bass}" OFF \
    "fotaq" "(AUR) ${software_fotaq}" OFF \
    "lure" "(AUR) ${software_lure}" OFF \
    "drascula" "(AUR) ${software_drascula}" OFF \
    "zsdx" "(AUR) ${software_zsdx}" OFF \
    "sdlpop" "(AUR) ${software_sdlpop}" OFF \
    "zork1" "(AUR) ${software_zork1}" OFF \
    "zork2" "(AUR) ${software_zork2}" OFF \
    "zork3" "(AUR) ${software_zork3}" OFF \
    "open-adventure" "(AUR) ${software_open_adventure}" OFF) "
  if grep -q 'drascula' <<<"${software}"; then
    software+='drascula-audio '
  fi

  # Roleplaying Games (RPGs)
  TITLE="Roleplaying ${games_software_title} (RPGs)"
  software+="$(dialog --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "openmw" "${software_openmw}" OFF \
    "openmw-tes3mp" "(AUR) ${software_openmw_tes3mp}" OFF \
    "daggerfall-unity-aur-bin" "(AUR) ${software_daggerfall_unity_aur_bin}" OFF\
    "freedroidrpg" "${software_freedroidrpg}" OFF \
    "flare-game" "(AUR) ${software_flare_game}" OFF \
    "naev" "${software_naev}" OFF \
    "rogue" "${software_rogue}" OFF \
    "angband" "${software_angband}" OFF \
    "umoria" "(AUR) ${software_umoria}" OFF \
    "nethack" "${software_nethack}" OFF \
    "tome4" "(AUR) ${software_tome4}" OFF \
    "stone-soup" "${software_stone_soup}" OFF \
    "cataclysm-dda-tiles" "${software_cataclysm_dda_tiles}" OFF \
    "doomrl" "(AUR) ${software_doomrl}" OFF \
    "planeshift" "(AUR) ${software_planeshift}" OFF \
    "runescape-launcher" "(AUR) ${software_runescape_launcher}" OFF \
    "runelite" "(AUR) ${software_runelite}" OFF \
    "manaplus" "${software_manaplus}" OFF) "

  # Strategy Games
  TITLE="Strategy ${games_software_title}"
  software+="$(dialog --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "0ad" "${software_0ad}" OFF \
    "widelands" "${software_widelands}" OFF \
    "megaglest" "${software_megaglest}" OFF \
    "warzone2100" "${software_warzone2100}" OFF \
    "boswars" "(AUR) ${software_boswars}" OFF \
    "curseofwar" "${software_curseofwar}" OFF \
    "pingus" "${software_pingus}" OFF \
    "wesnoth" "${software_wesnoth}" OFF \
    "hedgewars" "${software_hedgewars}" OFF \
    "warmux" "(AUR) ${software_warmux}" OFF \
    "freeciv" "${software_freeciv}" OFF \
    "singularity" "${software_singularity}" OFF) "

  # Racing Games
  TITLE="Racing ${games_software_title}"
  software+="$(dialog --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "supertuxkart" "${software_supertuxkart}" OFF \
    "extremetuxracer" "${software_extremetuxracer}" OFF \
    "armagetronad" "${software_armagetronad}" OFF \
    "gltron" "(AUR) ${software_gltron}" OFF \
    "torcs" "(AUR) ${software_torcs}" OFF) "

  # Simulation/Construction/Management Games
  TITLE="Simulation/Construction/Management ${games_software_title}"
  software+="$(dialog --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "dwarffortress" "${software_dwarffortress}" OFF \
    "lincity-ng" "${software_lincity_ng}" OFF \
    "simutrans" "${software_simutrans}" OFF \
    "flightgear" "(AUR) ${software_flightgear}" OFF \
    "minetest" "${software_minetest}" OFF \
    "minecraft-launcher" "(AUR) ${software_minecraft_launcher}" OFF) "

  # Development/Programming Software
  TITLE="Game Dev & ${programming_software_title}"
  software+="$(dialog --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "godot" "${software_godot}" OFF \
    "love" "${software_love}" OFF \
    "solarus" "(AUR) ${software_solarus}" OFF \
    "spring" "${software_spring}" OFF \
    "unityhub" "(AUR) ${software_unityhub}" OFF \
    "unreal-engine" "(AUR) ${software_unreal_engine}" OFF \
    "tiled" "${software_tiled}" OFF \
    "android-studio" "(AUR) ${software_android_studio}" OFF \
    "allegro" "${software_allegro}" OFF \
    "python-pygame" "${software_python_pygame}" OFF \
    "panda3d" "(AUR) ${software_panda3d}" OFF \
    "pygtk" "(AUR) ${software_pygtk}" OFF \
    "scratch" "${software_scratch}" OFF \
    "atom" "${software_atom}" OFF \
    "code" "${software_code}" OFF \
    "geany" "${software_geany}" OFF \
    "emacs" "${software_emacs}" OFF) "

  # Graphics/Drawing/Modeling Software
  TITLE="${graphics_software_title}"
  software+="$(dialog --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "gimp" "${software_gimp}" OFF \
    "inkscape" "${software_inkscape}" OFF \
    "blender" "${software_blender}" OFF \
    "goxel" "(AUR) ${software_goxel}" OFF \
    "magicavoxel" "(AUR) ${software_magicavoxel}" OFF \
    "libresprite" "(AUR) ${software_libresprite}" OFF \
    "aseprite" "(AUR) ${software_aseprite}" OFF \
    "mtpaint" "${software_mtpaint}" OFF \
    "mypaint" "${software_mypaint}" OFF \
    "krita" "${software_krita}" OFF) "

  # Multimedia Software
  TITLE="${multimedia_software_title}"
  software+="$(dialog --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "obs-studio" "${software_obs_studio}" OFF \
    "openshot" "${software_openshot}" OFF \
    "kdenlive" "${software_kdenlive}" OFF \
    "simplescreenrecorder" "${software_simplescreenrecorder}" OFF \
    "youtube-dl" "${software_youtube_dl}" OFF \
    "vlc" "${software_vlc}" OFF \
    "spotify" "(AUR) ${software_spotify}" OFF \
    "audacity" "${software_audacity}" OFF \
    "lmms" "${software_lmms}" OFF \
    "pulseaudio-equalizer" "${software_pulseaudio_equalizer}" OFF) "

  # Internet Software
  TITLE="${internet_software_title}"
  software+="$(dialog --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "firefox" "${software_firefox}" OFF \
    "chromium" "${software_chromium}" OFF \
    "google-chrome" "(AUR) ${software_google_chrome}" OFF \
    "opera" "${software_opera}" OFF \
    "discord" "${software_discord}" OFF \
    "slack-desktop" "(AUR) ${software_slack_desktop}" OFF \
    "hexchat" "${software_hexchat}" OFF \
    "transmission-gtk" "${software_transmission_gtk}" OFF \
    "piavpn-bin" "(AUR) ${software_piavpn_bin}" OFF \
    "w3m" "${software_w3m}" OFF \
    "lynx" "${software_lynx}" OFF \
    "minitube" "${software_minitube}" OFF \
    "filezilla" "${software_filezilla}" OFF \
    "evolution" "${software_evolution}" OFF \
    "thunderbird" "${software_thunderbird}" OFF) "
  if grep -q 'firefox' <<<"${software}" && [[ -n "${bro}" ]]; then
    software+="firefox-i18n-${bro} "
  fi
  if grep -q 'thunderbird' <<<"${software}" &&
      [[ -n "${bro}" && "${bro}" != 'lv' ]]; then
    software+="thunderbird-i18n-${bro} "
  fi

  # Fonts and Language Input
  TITLE="${fonts_and_language_input_software_title}, etc."
  software+="$(dialog --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "bdf-unifont" "${software_bdf_unifont}" OFF \
    "noto-fonts-cjk" "${software_noto_fonts_cjk}" OFF \
    "ibus-libpinyin" "${software_ibus_libpinyin}" OFF \
    "ibus-anthy" "${software_ibus_anthy}" OFF \
    "ibus-hangul" "${software_ibus_hangul}" OFF) "
  if grep -q 'ibus' <<<"${software}"; then
    echo -e "export GTK_IM_MODULE=ibus\nexport QT_IM_MODULE=ibus\nexport \
XMODIFIERS=@im=ibus\nibus-daemon -drx" >>"${GDL_DIR}"/extra/skel/.xprofile
  fi

  # Utilities
  TITLE="${utilities_software_title}"
  software+="$(dialog --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "htop" "${software_htop}" OFF \
    "gtop" "${software_gtop}" OFF \
    "bashtop" "${software_bashtop}" OFF \
    "mangohud" "(AUR) ${software_mangohud}" OFF \
    "gparted" "${software_gparted}" OFF \
    "gnome-disk-utility" "${software_gnome_disk_utility}" OFF \
    "baobab" "${software_baobab}" OFF \
    "innoextract" "${software_innoextract}" OFF \
    "tmux" "${software_tmux}" OFF \
    "ranger" "${software_ranger}" OFF \
    "virtualbox" "${software_virtualbox}" OFF \
    "vmware-workstation" "(AUR) ${software_vmware_workstation}" OFF \
    "insync" "(AUR) ${software_insync}" OFF \
    "pcloud-drive" "(AUR) ${software_pcloud_drive}" OFF \
    "timeshift" "(AUR) ${software_timeshift}" OFF \
    "luckybackup" "(AUR) ${software_luckybackup}" OFF \
    "authy" "(AUR) ${software_authy}" OFF \
    "clamav" "${software_clamav}" OFF \
    "bleachbit" "${software_bleachbit}" OFF) "
  if grep -q 'mangohud' <<<"${software}"; then
    software+='lib32-mangohud '
  fi

  AUR_AND_OPTIONAL_PACKAGES+="${software} "
}

install_base() {
  TITLE="${install_op_msg}"
  while ! yesno "${install_confirmation_msg}" "${yes}" "${no}" 'defaultno'; do
    if yesno "${exit_confirmation_msg}" "${yes}" "${no}" 'defaultno'; then
      log "User chose to exit installer: installation cancelled"
      clear
      dragonsay "${shell_prompt_msg1}"
      echo -e "${shell_prompt_msg2}"
      exit
    fi
  done
  if [[ -n "${lib}" ]]; then
    BASE_PACKAGES+="libreoffice-fresh-${lib} "
  fi
  if mount | grep -q 'type btrfs'; then
    BASE_PACKAGES+="grub-btrfs "
  fi
  BASE_PACKAGES="$(tr <<<"${BASE_PACKAGES}" " " "\n" | sort | uniq |
    tr "\n" " ")"
  log "Base package list: ${BASE_PACKAGES}"
  clear
  dragonsay "Installing base packages..." |& tee -a "${LOG_FILE}"
  pacman -Sy
  # shellcheck disable=SC2086
  if pacstrap /mnt ${BASE_PACKAGES} |& tee -a "${LOG_FILE}"; then
    log "Completed base installation"
  else
    local log_url
    log_url="$(nc termbin.com 9999 </root/gdl.log)"
    log "ERROR: Installation failed. Log uploaded to termbin.com: ${log_url}"
    message "${failed_msg} ${log_url}"
    clear
    dragonsay "${shell_prompt_msg1}"
    echo -e "${shell_prompt_msg2}"
    exit 1
  fi
}

configure_system() {
  local fstab='/mnt/etc/fstab' grub='/mnt/etc/default/grub' \
    grub_theme='/boot/grub/themes/gdl'

  # Initial fstab config
  genfstab -U /mnt >>"${fstab}"
  log "Generated fstab"

  # GRUB config
  mkdir -p /mnt"${grub_theme}"
  cp -r "${GDL_DIR}"/extra/grub-theme/* /mnt"${grub_theme}"
  if ! mount | grep -q 'type btrfs' ||
      (mount | grep -q ' /boot ' &&
       mount | grep ' /boot ' | grep -vq 'type btrfs'); then
    sed -i 's/GRUB_DEFAULT=0/GRUB_DEFAULT=saved/' "${grub}"
    sed -i 's/#GRUB_SAVEDEFAULT/GRUB_SAVEDEFAULT/' "${grub}"
  fi
  sed -i 's/GRUB_TIMEOUT=5/GRUB_TIMEOUT=3/' "${grub}"
  sed -i "s:#GRUB_COLOR_N.*$:GRUB_COLOR_NORMAL=\"red/black\":" "${grub}"
  sed -i "s:#GRUB_COLOR_H.*$:GRUB_COLOR_HIGHLIGHT=\"yellow/black\":" "${grub}"
  sed -i "s:#GRUB_THEME.*$:GRUB_THEME=\"${grub_theme}/theme.txt\":" "${grub}"
  if "${ENCRYPTED}"; then
    sed -i "s!quiet!cryptdevice=/dev/lvm/lvroot:root:allow-discards \
root=/dev/mapper/root transparent_hugepage=never!" "${grub}"
  else
    sed -i 's/quiet/transparent_hugepage=never/' "${grub}"
  fi
  if grep -q 'nvidia' <<<"${BASE_PACKAGES}"; then
    sed -i '/GRUB_CMDLINE_LINUX_DEFAULT=/ s/.$/ nvidia-drm.modeset=1"/;s/" /"/'\
      "${grub}"
  fi
  if "${UEFI}"; then
    arch-chroot /mnt grub-install --efi-directory="${ESP_MNT}" \
      --target=x86_64-efi --bootloader-id=boot |& tee -a "${LOG_FILE}"
    cp /mnt"${ESP_MNT}"/EFI/boot/grubx64.efi \
      /mnt"${ESP_MNT}"/EFI/boot/bootx64.efi
    if ! "${ENCRYPTED}"; then
      arch-chroot /mnt mkinitcpio -P |& tee -a "${LOG_FILE}"
    fi
  else
    arch-chroot /mnt grub-install /dev/"${DRIVE}" |& tee -a "${LOG_FILE}"
  fi
  arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg |& tee -a "${LOG_FILE}"
  log "Configured grub"

  # NVIDIA GPU config
  if grep -q 'nvidia' <<<"${BASE_PACKAGES}"; then
    sed -i \
      '/^MODULES=/ s/.$/ nvidia nvidia_modeset nvidia_uvm nvidia_drm )/;s/" /"/'
    sed -i 's!FILES=""!FILES="/etc/modprobe.d/nvidia.conf"!' \
      /mnt/etc/mkinitcpio.conf
    echo "options nvidia_drm modeset=1" >/mnt/etc/modprobe.d/nvidia.conf
    if grep -q 'nvidia' <<<"${BASE_PACKAGES}"; then
      echo "blacklist nouveau" >>/mnt/etc/modprobe.d/nvidia.conf
    fi
    if [[ ! -d /mnt/etc/pacman.d/hooks ]]; then
      mkdir /mnt/etc/pacman.d/hooks
    fi
    # https://wiki.archlinux.org/index.php/NVIDIA#Pacman_hook
    echo -e "[Trigger]\nOperation=Install\nOperation=Upgrade\nOperation=Remove\
\nType=Package\nTarget=nvidia\nTarget=linux\n\n[Action]\nDescription=Update \
Nvidia module in initcpio\nDepends=mkinitcpio\nWhen=PostTransaction\nNeeds\
Targets\nExec=/bin/sh -c 'while read -r trg; do case \$trg in linux) exit 0; \
esac; done; /usr/bin/mkinitcpio -P'\n" >/mnt/etc/pacman.d/hooks/nvidia.hook
    if ! "${ENCRYPTED}"; then
      arch-chroot /mnt mkinitcpio -P |& tee -a "${LOG_FILE}"
    fi
    log "Enabled Nvidia DRM (Direct Rendering Manager)"
  fi

  # XFS config
  if mount | grep -q 'type xfs'; then
    sed -i '/^MODULES=/ s/.$/ xfs )/;s/" /"/' /mnt/etc/mkinitcpio.conf
    if ! "${ENCRYPTED}"; then
      arch-chroot /mnt mkinitcpio -P |& tee -a "${LOG_FILE}"
    fi
    log "Configured system for xfs"
  fi

  # NVMe config
  if grep -q 'nvme' <<<"${BOOT}"; then
    sed -i '/^MODULES=/ s/.$/ nvme )/;s/" /"/' /mnt/etc/mkinitcpio.conf
    if ! "${ENCRYPTED}"; then
      arch-chroot /mnt mkinitcpio -P |& tee -a "${LOG_FILE}"
    fi
    log "Configured system for nvme"
  fi

  # Additional fstab, mkinitcpio, etc., config
  if "${ENCRYPTED}"; then
    if "${UEFI}"; then
      echo "/dev/${BOOT} ${ESP_MNT} vfat rw,relatime,fmask=0022,dmask=0022,code\
page=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro 0 2" >"${fstab}"
    else
      echo "/dev/${BOOT} /boot ext4 defaults 0 2" >"${fstab}"
    fi
    echo "/dev/mapper/root / ${FS} defaults 0 1" >>"${fstab}"
    echo "/dev/mapper/tmp /tmp tmpfs defaults 0 0" >>"${fstab}"
    echo "tmp /dev/lvm/tmp /dev/urandom tmp,cipher=aes-xts-plain64,size=256" \
      >>/mnt/etc/crypttab
    if (( SWAP_SIZE > 0 )); then
      echo "/dev/mapper/swap none swap defaults 0 0" >>"${fstab}"
      echo "swap /dev/lvm/swap /dev/urandom \
swap,cipher=aes-xts-plain64,size=256" >>/mnt/etc/crypttab
    fi
    # shellcheck disable=SC1004
    sed -i 's/^HOOKS=.*/HOOKS="base udev autodetect keyboard keymap consolefont\
modconf block encrypt lvm2 filesystems fsck"/' /mnt/etc/mkinitcpio.conf
    arch-chroot /mnt mkinitcpio -P |& tee -a "${LOG_FILE}"
    log "Configured system for encryption"
  else
    # shellcheck disable=SC1004
    sed -i 's/^HOOKS=.*/HOOKS="base udev autodetect keyboard keymap consolefont\
modconf block lvm2 filesystems fsck"/' /mnt/etc/mkinitcpio.conf
    arch-chroot /mnt mkinitcpio -P |& tee -a "${LOG_FILE}"
    log "Configured system with default mkinitcpio hooks"
  fi

  # Locale config
  sed -i -e "s/#${LOCALE}/${LOCALE}/" /mnt/etc/locale.gen
  echo "LANG=${LOCALE}" >/mnt/etc/locale.conf
  arch-chroot /mnt locale-gen
  log "Set system locale: ${LOCALE}"

  # Keyboard config
  echo "KEYMAP=${KEYMAP}" >/mnt/etc/vconsole.conf
  echo -e "Section \"InputClass\"\nIdentifier \"system-keyboard\"\nMatchIs\
Keyboard \"on\"\nOption \"XkbLayout\" \"${KEYMAP}\"\nEndSection" \
    >/mnt/etc/X11/xorg.conf.d/00-keyboard.conf
  arch-chroot /mnt localectl set-x11-keymap "${KEYMAP}"
  log "Set system keymap: ${KEYMAP}"

  # Time zone and hardware clock config
  arch-chroot /mnt ln -sf /usr/share/zoneinfo/"${ZONE}" /etc/localtime
  arch-chroot /mnt hwclock --systohc # to generate /etc/adjtime
  log "Set system time zone: ${ZONE}"

  # Firewall, network, and bluetooth config
  arch-chroot /mnt ufw enable
  enable_service ufw.service
  enable_service NetworkManager.service
  enable_service dhcpcd.service
  if "${BLUETOOTH_AVAILABLE}"; then
    enable_service bluetooth.service
  fi

  # VM config
  case "${VM_TYPE}" in
    oracle) enable_service vboxservice.service ;;
    vmware)
      cat /mnt/proc/version >/mnt/etc/arch-release
      enable_service vmtoolsd.service
      enable_service vmware-vmblock-fuse.service
      local -i x
      for x in {0..6}; do mkdir -p /mnt/etc/init.d/rc"${x}".d; done
      ;;
  esac

  # Desktop config
  arch-chroot /mnt fc-cache -f # build font information cache files
  cp "${GDL_DIR}"/extra/gdl.png /mnt/usr/share/pixmaps
  cp "${GDL_DIR}"/extra/gdl.png /mnt/usr/share/icons
  cp -r "${GDL_DIR}"/extra/Breeze_Amber /mnt/usr/share/icons
  cp -rT "${GDL_DIR}"/extra/wallpapers /mnt/usr/share/backgrounds/xfce
  cp -rT "${GDL_DIR}"/extra/skel /mnt/etc/skel
  cp -rT "${GDL_DIR}"/extra/root /mnt/root
  cp /mnt/etc/skel/.bash_profile /mnt/root/
  cp /mnt/etc/skel/.vimrc /mnt/root/
  cp /mnt/etc/skel/.xinitrc /mnt/root/
  cp "${GDL_DIR}"/extra/gdl.png /mnt/root/.face
  log "Configured desktop environment"

  # Display manager (login manager) config
  cp -rT "${GDL_DIR}"/extra/lightdm /mnt/etc/lightdm
  enable_service lightdm.service

  # Pacman config
  if [[ -f /mnt/var/lib/pacman/db.lck ]]; then
    rm /mnt/var/lib/pacman/db.lck &>/dev/null
  fi
  sed -i 's/^#Color$/Color/' /mnt/etc/pacman.conf
  sed -i 's/^#CheckSpace$/CheckSpace/' /mnt/etc/pacman.conf
  sed -i 's/^#VerbosePkgLists$/VerbosePkgLists/' /mnt/etc/pacman.conf
  sed -i '/^VerbosePkgLists$/ a ILoveCandy' /mnt/etc/pacman.conf
  sed -i '/\[multilib]$/ {
    N
    /Include/s/#//g}' /mnt/etc/pacman.conf
  log "Customized pacman.conf"

  # Hostname and root user config
  echo "${NEW_HOSTNAME}" >/mnt/etc/hostname
  echo -e "127.0.0.1 localhost\n::1 localhost\n127.0.1.1 \
${NEW_HOSTNAME}.localdomain ${NEW_HOSTNAME}" >>/mnt/etc/hosts
  log "Hostname set: ${NEW_HOSTNAME}"
  local pw
  pw="$(echo "${NEW_PW}" | openssl enc -aes-256-cbc -a -d -salt -pbkdf2 -iter \
    1000 -pass pass:"${SSL_KEY}")"
  printf "%s\n%s" "${pw}" "${pw}" | arch-chroot /mnt passwd root
  unset pw
  log "Password set for user: root"

  # CPU frequency scaling
  enable_service cpupower.service

  # Periodic (weekly) TRIM for any attached drives that support 'discard'
  enable_service fstrim.timer

  # Decrease swappiness
  echo "vm.swappiness=10" >/mnt/etc/sysctl.d/99-swappiness.conf

  # Ensure proper MIDI support for GStreamer-based media players
  mkdir -p /mnt/usr/share/sounds/sf2
  arch-chroot /mnt sh -c "ln -s /usr/share/soundfonts/FluidR3_GM.sf2 \
    /usr/share/sounds/sf2/"

  log "System configuration complete"
}

install_additional_software() {
  local pw package failed_packages try='y'

  # Create a special temporary user for installing and using yay (AUR helper)
  dragonsay "Setting up AUR support..." |& tee -a "${LOG_FILE}"
  log "Creating temporary user: 'yaybuilder'"
  pw="$(< /dev/urandom tr -dc "@#*%&_A-Z-a-z-0-9" | head -c16)"
  arch-chroot /mnt mkdir -v yaytemp
  arch-chroot /mnt chmod 777 yaytemp
  arch-chroot /mnt useradd -rNM -d /yaytemp -s /usr/bin/nologin yaybuilder
  arch-chroot /mnt sh -c "echo -e '${pw}\n${pw}\n' | passwd yaybuilder"
  log "Adding 'yaybuilder' to sudoers.d"
  arch-chroot /mnt sh -c "echo 'yaybuilder ALL=(ALL) NOPASSWD: ALL' |
    tee /etc/sudoers.d/yaybuilder"
  arch-chroot /mnt sh -c "echo 'root ALL=(yaybuilder) NOPASSWD: ALL' |
    tee -a /etc/sudoers.d/yaybuilder"

  # Install yay, update, then install additional packages using yay
  log "Installing yay (AUR helper)"
  arch-chroot /mnt sh -c "cd yaytemp &&
    sudo -u yaybuilder git clone https://aur.archlinux.org/yay-bin.git &&
    cd yay-bin && sudo -u yaybuilder makepkg -si --noconfirm" |&
    tee -a "${LOG_FILE}"
  arch-chroot /mnt sudo -u yaybuilder yay --noconfirm |& tee -a "${LOG_FILE}"
  AUR_AND_OPTIONAL_PACKAGES="$(tr <<<"${AUR_AND_OPTIONAL_PACKAGES}" " " "\n" |
    sort | uniq | tr "\n" " ")"
  log "AUR and optional software package list: ${AUR_AND_OPTIONAL_PACKAGES}"
  dragonsay "Installing additional software..." |& tee -a "${LOG_FILE}"
  while [[ -n "${AUR_AND_OPTIONAL_PACKAGES}" ]] && grep -iq '^y' <<<"${try}"; do
    failed_packages=''
    for package in ${AUR_AND_OPTIONAL_PACKAGES}; do
      log "Installing ${package}..."
      if ! arch-chroot /mnt sudo -u yaybuilder yay -S "${package}" --needed \
          --noconfirm; then
        log "ERROR: Installation of ${package} failed"
        failed_packages+="${package} "
      fi
    done
    if [[ -n "${failed_packages}" ]]; then
      echo "${error} $(wc -w <<<"${failed_packages}") package(s) failed to \
install: ${failed_packages}"
      while true; do
        read -rp "Try again? (y/n) " try
        if grep -Eiq '^n|^y' <<<"${try}"; then
          break
        fi
      done
    fi
    AUR_AND_OPTIONAL_PACKAGES="${failed_packages}"
  done
  if [[ -n "${failed_packages}" ]]; then
    log "$(wc -w <<<"${failed_packages}") failed package(s): ${failed_packages}"
  else
    log "All packages successfully installed"
  fi

  # Clean things up
  log "Cleaning up..."
  arch-chroot /mnt sudo -u yaybuilder yay -Yc --noconfirm |&
    tee -a "${LOG_FILE}"
  arch-chroot /mnt userdel -f yaybuilder |& tee -a "${LOG_FILE}"
  log "User 'yaybuilder' deleted"
  arch-chroot /mnt rm /etc/passwd- /etc/sudoers.d/yaybuilder
  arch-chroot /mnt rm -r yaytemp
  log "Cleanup complete"
}

add_user() {
  if [[ -z "${NEW_USER_FULL_NAME}" ]]; then
    arch-chroot /mnt useradd -m -G audio,network,power,storage,optical -s \
      /bin/bash "${NEW_USERNAME}"
  else
    arch-chroot /mnt useradd -m -G audio,network,power,storage,optical -c \
      "${NEW_USER_FULL_NAME}" -s /bin/bash "${NEW_USERNAME}"
  fi
  local pw
  pw="$(echo "${NEW_PW}" | openssl enc -aes-256-cbc -a -d -salt -pbkdf2 -iter \
    1000 -pass pass:"${SSL_KEY}")"
  printf "%s\n%s" "${pw}" "${pw}" | arch-chroot /mnt passwd "${NEW_USERNAME}"
  unset pw
  sed -i '/%wheel ALL=(ALL) ALL/s/^#//' /mnt/etc/sudoers
  arch-chroot /mnt usermod -a -G wheel "${NEW_USERNAME}"
  # Add shortcut for installing Battle.net if Lutris was installed
  if grep -q 'lutris' <<<"${BASE_PACKAGES}"; then
    mkdir /mnt/home/"${NEW_USERNAME}"/Desktop
    echo -e "[Desktop Entry]\nVersion=1.0\nType=Link\nName=Install Battle.net
Comment=Install the Blizzard Battle.net app via Lutris\nIcon=user-bookmarks
URL=lutris:blizzard-battlenet-standard" \
      >/mnt/home/"${NEW_USERNAME}"/Desktop/blizzard.desktop
    arch-chroot /mnt chown -R "${NEW_USERNAME}:${NEW_USERNAME}" \
      /home/"${NEW_USERNAME}"/Desktop
  fi
  log "User added: ${NEW_USERNAME}"
}

main() {
  initialize
  set_language
  set_keymap
  TITLE="${about_gdl_title}"
  dialog --ok-button "${ok}" --msgbox "\n${about_gdl_msg}" 22 80
  update_mirrors
  set_locale
  set_time_zone
  prepare_drives
  prepare_base
  set_hostname
  set_user
  select_additional_software
  install_base
  configure_system
  install_additional_software
  add_user
  clear
  dragonsay "${install_complete_msg1}" |& tee -a "${LOG_FILE}"
  echo -e "${install_complete_msg2}"
  cp "${LOG_FILE}" /mnt/root
}

main
