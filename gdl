#!/bin/bash
#
# Installer script for Golden Drake Linux (GDL): Arch for gamers and game devs!
#
# Copyright (C) 2020-2021 Golden Drake Studios: goldendrakestudios.com
# Forked originally from the Anarchy installer: anarchyinstaller.gitlab.io
#
# shellcheck disable=SC1090,SC2154,SC2034,SC2086,SC2153,SC2155

source /etc/gdl.conf

initialize() {
  # Set initial language-specific globals based on 'LANG' environment variable
  set_lang_file "${LANG}"

  # Check for root privileges (this should never be an issue)
  if (( $(id -u) != 0 )); then
    dragonsay "Sorry, this script requires root privileges (e.g., sudo)."
    exit 1
  fi

  # First (automatic) 'gdl' run
  if [[ ! -f "${LOG_FILE}" ]]; then
    # Create installation log file
    touch "${LOG_FILE}"

    # Start network manager
    systemctl start NetworkManager.service

    # Customize installer's pacman.conf
    sed -i 's/#Color/Color\nILoveCandy/' /etc/pacman.conf
    sed -i 's/#ParallelDownloads/ParallelDownloads/' /etc/pacman.conf
    sed -zi 's/#\[multilib]\n#Include/[multilib]\nInclude/' /etc/pacman.conf

    # Exit so user can run other commands before (or instead of) installing GDL
    return_to_shell_prompt
  fi

  # Second (or later) 'gdl' run: prepare for installation
  log "Initializing installer..."
  trap force_quit SIGINT # call 'force_quit' when Ctrl+C is pressed
  set -o pipefail # ensure $? remembers failures from piped commands
  [[ -d /tmp/gdl ]] || mkdir /tmp/gdl
  if (( $(tput lines) < 25 )) || grep -q 'accessibility=' /proc/cmdline; then
    REDUCE_EXTRANEOUS_TEXT='true'
  fi
  if ! ip addr | grep -Eq 'wlp|wlo|wlan'; then
    WIFI_AVAILABLE='false'
  fi
  if dmesg | grep -qi 'blue'; then
    BLUETOOTH_AVAILABLE='true'
  fi
  if lsblk | grep 'run' | grep -qo 'sd.'; then
    USB="$(lsblk | grep 'run' | grep -o 'sd.')"
  fi
  if [[ -d /sys/class/power_supply/BAT0 ]]; then
    BATTERY='/sys/class/power_supply/BAT0'
  elif [[ -d /sys/class/power_supply/BAT1 ]]; then
    BATTERY='/sys/class/power_supply/BAT1'
  fi
  if [[ "${VM_TYPE}" == 'none' ]]; then
    if lspci | grep VGA | grep -iq 'nvidia'; then
      GRAPHICS_CHIPSET='NVIDIA'
      DEFAULT_GRAPHICS_DRIVER='nvidia'
    elif lspci | grep VGA | grep -Eq 'ATI|AMD'; then
      GRAPHICS_CHIPSET='AMD/ATI'
      DEFAULT_GRAPHICS_DRIVER='xf86-video-ati'
    elif lspci | grep VGA | grep -q 'Intel'; then
      GRAPHICS_CHIPSET='Intel'
      DEFAULT_GRAPHICS_DRIVER='xf86-video-intel'
    fi
  fi
}

return_to_shell_prompt() {
  clear
  dragonsay "${SHELL_PROMPT_WELCOME}"
  echo -e "${SHELL_PROMPT_HELP}"
  exit
}

force_quit() {
  log "User force quit the installation"
  TITLE="Force Quit"
  message "${FORCE_QUIT_MSG}"
  return_to_shell_prompt
}

set_language() {
  TITLE="${SET_LANG_TITLE}"
  local language

  while ! language="$(dialog --no-cancel --menu "\n${SET_LANG_MSG}" 20 60 10 \
      'English' '->' \
      'Bulgarian' 'Български' \
      'Dutch' 'Nederlands' \
      'French' 'Français' \
      'German' 'Deutsch' \
      'Greek' 'Greek' \
      'Hungarian' 'Magyar' \
      'Indonesian' 'bahasa Indonesia' \
      'Italian' 'Italiano' \
      'Latvian' 'Latviešu' \
      'Lithuanian' 'Lietuvių' \
      'Polish' 'Polski' \
      'Portuguese' 'Português' \
      'Portuguese-Brazilian' 'Português do Brasil' \
      'Romanian' 'Română' \
      'Russian' 'Russian' \
      'Spanish' 'Español' \
      'Swedish' 'Svenska')"; do
    continue
  done
  set_lang_file "${language}"
}

set_lang_file() {
  local language="${1:-English}"

  case "${language}" in
    Bulgarian|bg_*) LANG_FILE='/usr/share/gdl/lang/bulgarian.conf' ;;
    Dutch|nl_*) LANG_FILE='/usr/share/gdl/lang/dutch.conf' ;;
    French|fr_*) LANG_FILE='/usr/share/gdl/lang/french.conf' ;;
    German|de_*) LANG_FILE='/usr/share/gdl/lang/german.conf' ;;
    Greek|el_*) LANG_FILE='/usr/share/gdl/lang/greek.conf' ;;
    Hungarian|hu_*) LANG_FILE='/usr/share/gdl/lang/hungarian.conf' ;;
    Indonesian|id_*) LANG_FILE='/usr/share/gdl/lang/indonesia.conf' ;;
    Italian|it_*) LANG_FILE='/usr/share/gdl/lang/italian.conf' ;;
    Latvian|lv_*) LANG_FILE='/usr/share/gdl/lang/latvian.conf' ;;
    Lithuanian|lt_*) LANG_FILE='/usr/share/gdl/lang/lithuanian.conf' ;;
    Polish|pl_*) LANG_FILE='/usr/share/gdl/lang/polish.conf' ;;
    Portuguese|pt_PT*) LANG_FILE='/usr/share/gdl/lang/portuguese.conf' ;;
    Portuguese-B*|pt_BR*) LANG_FILE='/usr/share/gdl/lang/portuguese-br.conf' ;;
    Romanian|ro_*) LANG_FILE='/usr/share/gdl/lang/romanian.conf' ;;
    Russian|ru_*) LANG_FILE='/usr/share/gdl/lang/russian.conf' ;;
    Spanish|es_*) LANG_FILE='/usr/share/gdl/lang/spanish.conf' ;;
    Swedish|sv_*) LANG_FILE='/usr/share/gdl/lang/swedish.conf' ;;
    *) LANG_FILE='/usr/share/gdl/lang/english.conf' ;;
  esac
  source "${LANG_FILE}"
  log "Set language to: ${language}"
}

set_keymap() {
  TITLE="${SET_KEYMAP_TITLE}"
  local keymap_list
  keymap_list="$(find /usr/share/kbd/keymaps -type f | sed -n -e 's!^.*/!!p' |
    grep '.map.gz' | sed 's/.map.gz//g' | sed 's/$/ ->/g' | sort)"

  while true; do
    if KEYMAP="$(dialog --no-cancel --ok-button "${OK}" --menu \
        "\n${SET_KEYMAP_MSG}" 18 60 10 \
        'us' 'United States' \
        'uk' 'United Kingdom' \
        'sv' 'Swedish' \
        'slovene' 'Slovenian' \
        'ru' 'Russian' \
        'ro' 'Romanian' \
        'pt-latin9' 'Portugal' \
        'it' 'Italian' \
        'hu' 'Hungarian' \
        'fr' 'French' \
        'es' 'Spanish' \
        'el' 'Greek' \
        'de' 'German' \
        "${OTHER}" '->')"; then
      if [[ "${KEYMAP}" != "${OTHER}" ]] ||
          KEYMAP="$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
          --menu "\n${SET_KEYMAP_MSG}" 19 60 10 ${keymap_list})"; then
        break
      fi
    fi
  done
  localectl set-keymap "${KEYMAP}"
  loadkeys "${KEYMAP}"
  log "Set keymap to: ${KEYMAP}"
}

update_mirrors() {
  TITLE="${UPDATE_MIRRORS_TITLE}"
  local mirrors_option editor

  # Ensure an internet connection is established before continuing
  while ! nc -zw 1 1.1.1.1 443; do
    log "Internet connection not yet established..."
    if "${WIFI_AVAILABLE}" && [[ -n "${WIFI_SSID}" ]] &&
        nmcli dev wifi connect "${WIFI_SSID}" password "${WIFI_PASSWORD}"; then
      log "Using nmcli..."
    else
      log "Using nmtui..."
      nmtui
    fi
    sleep 1
  done
  timedatectl set-ntp true # ensure system clock is accurate
  log "Internet connection established"

  # Present options for updating mirrors
  while true; do
    if mirrors_option="$(dialog --no-cancel --ok-button "${OK}" --menu \
        "\n${UPDATE_MIRRORS_MSG}" 12 60 3 \
        "${SKIP_UPDATING_MIRRORS}" '->' \
        "${AUTO_UPDATE_MIRRORS}" '->' \
        "${MANUALLY_UPDATE_MIRRORS}" '->')"; then
      case "${mirrors_option}" in
        "${AUTO_UPDATE_MIRRORS}")
          clear
          dragonsay "Updating mirrors..."
          reflector --verbose --latest 20 --protocol https --sort rate --save \
            /etc/pacman.d/mirrorlist
          log "Mirrors updated automatically"
          break
          ;;
        "${MANUALLY_UPDATE_MIRRORS}")
          if editor="$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
              --menu "\n${MIRRORS_EDITOR_MSG}" 11 60 2 \
              'nano' "${NANO_MSG}" \
              'vim' "${VIM_MSG}")"; then
            "${editor}" /etc/pacman.d/mirrorlist
            log "Mirrors updated manually"
            break
          fi
          ;;
        *) break ;;
      esac
    fi
  done
}

set_locale() {
  TITLE="${SET_LOCALE_TITLE}"
  local locale_list
  locale_list="$(grep -E "^#?[a-z].*UTF-8" /etc/locale.gen | sed 's/#//' |
    awk '{print $1" ->"}')"

  while true; do
    if LOCALE="$(dialog --no-cancel --ok-button "${OK}" --menu \
        "\n${SET_LOCALE_MSG}" 18 60 10 \
        'de_DE.UTF-8' 'German' \
        'el_GR.UTF-8' 'Greek' \
        'en_AU.UTF-8' 'English (Australia)' \
        'en_CA.UTF-8' 'English (Canada)' \
        'en_GB.UTF-8' 'English (UK)' \
        'en_US.UTF-8' 'English (US)' \
        'es_ES.UTF-8' 'Spanish (Spain)' \
        'es_MX.UTF-8' 'Spanish (Mexico)' \
        'fr_FR.UTF-8' 'French' \
        'hu_HU.UTF-8' 'Hungarian' \
        'it_IT.UTF-8' 'Italian' \
        'lv_LV.UTF-8' 'Latvian' \
        'pt_BR.UTF-8' 'Portuguese (Brazil)' \
        'pt_PT.UTF-8' 'Portuguese (Portugal)' \
        'ro_RO.UTF-8' 'Romanian' \
        'ru_RU.UTF-8' 'Russian' \
        'sv_SE.UTF-8' 'Swedish' \
        "${OTHER}" '->')"; then
      if [[ "${LOCALE}" != "${OTHER}" ]] ||
          LOCALE="$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
          --menu "\n${SET_LOCALE_MSG}" 19 60 10 ${locale_list})"; then
        break
      fi
    fi
  done
  log "Set locale to: ${LOCALE}"
}

set_time_zone() {
  TITLE="${SET_TIME_ZONE_TITLE}"
  local zonelist sublist subzone subsubzone
  zonelist="$(find /usr/share/zoneinfo -maxdepth 1 | sed -n -e 's!^.*/!!p' |
    grep -Ev 'posix|posixrules|right|zoneinfo|.*tab|W-SU|WET|MST7MDT|CST6CDT' |
    sort | sed 's/$/ ->/g')"

  while true; do
    TIME_ZONE="$(dialog --no-cancel --ok-button "${OK}" --menu \
      "\n${SET_TIME_ZONE_MSG}" 18 60 10 ${zonelist})"
    if find /usr/share/zoneinfo -maxdepth 1 -type d | sed -n -e 's!^.*/!!p' |
        grep -q "${TIME_ZONE}"; then
      sublist="$(find /usr/share/zoneinfo/"${TIME_ZONE}" -maxdepth 1 |
        sed -n -e 's!^.*/!!p' | sort | sed 's/$/ ->/g' |
        grep -v "${TIME_ZONE}")"
      if subzone="$(dialog --ok-button "${OK}" --cancel-button "${BACK}" \
          --menu "\n${SET_TIME_SUBZONE_MSG}" 18 60 10 ${sublist})"; then
        if find /usr/share/zoneinfo/"${TIME_ZONE}" -maxdepth 1 -type d |
            sed -n -e 's!^.*/!!p' | grep -q "${subzone}"; then
          sublist="$(find /usr/share/zoneinfo/"${TIME_ZONE}/${subzone}" \
            -maxdepth 1 | sed -n -e 's!^.*/!!p' | sort | sed 's/$/ ->/g' |
            grep -v "${subzone}")"
          if subsubzone="$(dialog --ok-button "${OK}" --cancel-button "${BACK}"\
              --menu "\n${SET_TIME_SUBZONE_MSG}" 15 60 7 ${sublist})"; then
            TIME_ZONE="${TIME_ZONE}/${subzone}/${subsubzone}"
            break
          fi
        else
          TIME_ZONE="${TIME_ZONE}/${subzone}"
          break
        fi
      fi
    else
      break
    fi
  done
  log "Set time zone to: ${TIME_ZONE}"
}

prepare_drives() {
  TITLE="${PREPARE_DRIVES_TITLE}"
  local partition_method partition_prefix drive_bytes drive_mib drive_gib \
    drive_menu_header='               Device    Size    Type'

  log "Initial partition layout:"
  lsblk -o NAME,SIZE,TYPE,MOUNTPOINTS,FSTYPE,FSVER,FSUSE% | log
  if df | grep -q '/mnt'; then
    (
      umount -R /mnt
      swapoff -a
    ) &>/dev/null &
    load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2umount -R /mnt\Zn"
  fi

  until "${SYSTEM_MOUNTED}"; do
    GPT='false'
    UEFI='false'
    DRIVE=''
    ROOT=''
    BOOT=''
    ESP_MNT=''

    # Present the main partitioning menu
    if ! partition_method="$(dialog --no-cancel --ok-button "${OK}" --menu \
        "\n${PART_METHOD_MSG}" 15 64 3 \
        "${PART_METHOD_AUTO}" '->' \
        "${PART_METHOD_AUTO_ENCRYPT}" '->' \
        "${PART_METHOD_MANUAL}" '->')"; then
      continue

    # If an auto-partitioning option is selected, prepare drive-selection menu
    elif [[ "${partition_method}" != "${PART_METHOD_MANUAL}" ]]; then
      rm /tmp/gdl/part.sh &>/dev/null # remove old temp file (if one exists)
      # shellcheck disable=SC2028
      if "${REDUCE_EXTRANEOUS_TEXT}"; then
        echo "dialog --stdout --colors --title \" ${TITLE} \" --ok-button \
\"${OK}\" --cancel-button \"${CANCEL}\" --menu \"\n${SELECT_DRIVE_MSG}\n\n\
${drive_menu_header}\" 16 60 5 \\" >/tmp/gdl/part.sh
      else
        echo "dialog --stdout --colors --backtitle \"${BACKTITLE}\" --title \" \
${TITLE} \" --ok-button \"${OK}\" --cancel-button \"${CANCEL}\" --menu \"\n\
${SELECT_DRIVE_MSG}\n\n${drive_menu_header}\" 16 60 5 \\" >/tmp/gdl/part.sh
      fi
      lsblk -nio NAME,SIZE,TYPE | grep -E "disk|raid[0-9]+$" |
        sed 's/[^[:alnum:]_., ]//g' | column -t | sort -k 1,1 | uniq |
        awk '{print "\""$1"\"""  ""\"| "$2" | "$3"     \""" \\"}' |
        column -t >>/tmp/gdl/part.sh

      # Present the drive-selection and filesystem-selection menus
      DRIVE="$(bash /tmp/gdl/part.sh)" || continue
      FS="$(get_filesystem)" || continue

      # Check the selected drive's properties
      if grep -Eq 'nvme|mmc|md' <<<"${DRIVE}"; then
        partition_prefix='p'
      else
        partition_prefix=''
      fi
      drive_bytes="$(lsblk -nibo NAME,SIZE | grep -w "${DRIVE}" |
        awk '{print $2}')"
      drive_mib=$(( drive_bytes / 1024 / 1024 ))
      drive_gib=$(( drive_mib / 1024 ))
      log "Drive size in MiB: ${drive_mib}"
      if efivar -l &>/dev/null && yesno "${UEFI_MSG}" "${YES}" "${NO}"; then
        GPT='true'
        UEFI='true'
        log "UEFI boot and GPT partition scheme activated"
      fi
      if ! "${UEFI}" && yesno "${GPT_MSG}" "${YES}" "${NO}" 'defaultno'; then
        GPT='true'
        log "GPT partition scheme activated"
      fi

      # Set swap size
      SWAP_SIZE='0'
      if yesno "${CREATE_SWAP_MSG}" "${YES}" "${NO}" 'defaultno'; then
        while true; do
          SWAP_SIZE=$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
            --inputbox "\n${SET_SWAP_SIZE_MSG}" 11 55 '512M') || break
          if grep -q 'M$' <<<"${SWAP_SIZE}"; then
            SWAP_SIZE="$(sed 's/M//;s/\..*//' <<<"${SWAP_SIZE}")"
          elif grep -q 'G$' <<<"${SWAP_SIZE}"; then
            SWAP_SIZE="$(echo "${SWAP_SIZE/G} * 1024" | bc | sed 's/\..*//')"
          else
            message "${SWAP_INPUT_ERROR_MSG}"
            continue
          fi
          if (( SWAP_SIZE > drive_mib - 9216 )); then
            message "${SWAP_SIZE_ERROR_MSG}"
          else
            break
          fi
        done
      fi
      log "Swap size set to: ${SWAP_SIZE} MiB"

      # Format the selected drive (or go back to the main partitioning menu)
      if yesno "$(eval echo \"${FORMAT_DRIVE_CONFIRM}\")" "${WRITE_CHANGES}" \
          "${CANCEL}" 'defaultno'; then
        (
          sgdisk --zap-all /dev/"${DRIVE}"
          wipefs -a /dev/"${DRIVE}"
        ) &>/dev/null &
        load_bar "${WIPEFS_LOAD_MSG}\n\n \Z1> \Z2wipefs -a /dev/${DRIVE}\Zn"
        log "Device formatted: /dev/${DRIVE}"
      else
        continue
      fi
    fi

    # Go to the appropriate sub-function
    case "${partition_method}" in
      "${PART_METHOD_AUTO}")
        log "User chose automatic partitioning"
        auto_partition
        if ! "${SYSTEM_MOUNTED}"; then
          message "${PART_ERROR_MSG}"
        fi
        ;;
      "${PART_METHOD_AUTO_ENCRYPT}")
        log "User chose automatic partitioning with encrypted LVM"
        auto_partition_with_encryption
        if ! "${SYSTEM_MOUNTED}"; then
          message "${PART_ERROR_MSG}"
        fi
        ;;
      "${PART_METHOD_MANUAL}")
        log "User chose manual partitioning"
        manually_partition
        ;;
    esac
  done
  log "Final partition layout:"
  lsblk -o NAME,SIZE,TYPE,MOUNTPOINTS,FSTYPE,FSVER,FSUSE% | log
}

get_filesystem() {
  dialog --no-cancel --menu "\n${SELECT_FS_MSG}" 12 60 3 \
    'ext4' "${FS_EXT4_MSG}" \
    'btrfs' "${FS_BTRFS_MSG}" \
    'xfs' "${FS_XFS_MSG}"
}

auto_partition() {
  TITLE="${AUTO_PART_TITLE}"

  # Create partitions
  if "${GPT}"; then
    if "${UEFI}"; then # UEFI/GPT
      if (( SWAP_SIZE > 0 )); then
        echo -e \
          "n\n\n\n512M\nef00\nn\n3\n\n+${SWAP_SIZE}M\n8200\nn\n\n\n\n\nw\ny" |
          gdisk /dev/"${DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
        format_swap_partition "${DRIVE}${partition_prefix}3"
      else # no swap
        echo -e "n\n\n\n512M\nef00\nn\n\n\n\n\nw\ny" |
          gdisk /dev/"${DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
      fi
      BOOT="${DRIVE}${partition_prefix}1"
      ROOT="${DRIVE}${partition_prefix}2"
    else # BIOS/GPT
      if (( SWAP_SIZE > 0 )); then
        echo -e "o\ny\nn\n1\n\n+212M\n\nn\n2\n\n+1M\nEF02\nn\n4\n\n+\
${SWAP_SIZE}M\n8200\nn\n3\n\n\n\nw\ny" | gdisk /dev/"${DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
        format_swap_partition "${DRIVE}${partition_prefix}4"
      else # no swap
        echo -e "o\ny\nn\n1\n\n+212M\n\nn\n2\n\n+1M\nef02\nn\n3\n\n\n\nw\ny" |
          gdisk /dev/"${DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
      fi
      BOOT="${DRIVE}${partition_prefix}1"
      ROOT="${DRIVE}${partition_prefix}3"
    fi
  else # BIOS/MBR
    if (( SWAP_SIZE > 0 )); then
      echo -e "o\nn\np\n1\n\n+212M\nn\np\n3\n\n+${SWAP_SIZE}M\nt\n\n82\nn\np\n2\
\n\n\nw" | fdisk /dev/"${DRIVE}" &>/dev/null &
      load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2fdisk \
/dev/${DRIVE}\Zn"
      format_swap_partition "${DRIVE}${partition_prefix}3"
    else # no swap
      echo -e "o\nn\np\n1\n\n+212M\nn\np\n2\n\n\nw" |
        fdisk /dev/"${DRIVE}" &>/dev/null &
      load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2fdisk \
/dev/${DRIVE}\Zn"
    fi
    BOOT="${DRIVE}${partition_prefix}1"
    ROOT="${DRIVE}${partition_prefix}2"
  fi
  log "Created boot partition: ${BOOT}"
  log "Created root partition: ${ROOT}"

  # Format partitions
  if "${UEFI}"; then
    (
      sgdisk --zap-all /dev/"${BOOT}"
      wipefs -a /dev/"${BOOT}"
      mkfs.vfat -F32 /dev/"${BOOT}"
    ) &>/dev/null &
    load_bar "${EFI_LOAD_MSG}\n\n \Z1> \Z2mkfs.vfat -F32 /dev/${BOOT}\Zn"
    ESP_MNT='/boot'
    log "EFI system partition (ESP): ${BOOT}"
    log "ESP mount point: ${ESP_MNT}"
    log "Created boot filesystem: vfat"
  else # BIOS
    (
      sgdisk --zap-all /dev/"${BOOT}"
      wipefs -a /dev/"${BOOT}"
      # shellcheck disable=SC1001
      mkfs.ext4 -O \^64bit /dev/"${BOOT}"
    ) &>/dev/null &
    load_bar "${BOOT_LOAD_MSG}\n\n \Z1> \Z2mkfs.ext4 /dev/${BOOT}\Zn"
    log "Boot mount point set to: /boot"
    log "Created boot filesystem: ext4"
  fi
  (
    sgdisk --zap-all /dev/"${ROOT}"
    wipefs -a /dev/"${ROOT}"
    mkfs."${FS}" /dev/"${ROOT}"
  ) &>/dev/null &
  load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${FS} \
/dev/${ROOT}\Zn"
  log "Created root filesystem: ${FS}"

  # Mount partitions
  if mount /dev/"${ROOT}" /mnt &>/dev/null; then
    log "Mounted /dev/${ROOT} at /mnt"
    mkdir /mnt/boot
    if mount /dev/"${BOOT}" /mnt/boot &>/dev/null; then
      log "Mounted /dev/${BOOT} at /mnt/boot"
      SYSTEM_MOUNTED='true'
    else
      log "ERROR: Mounting /dev/${BOOT} at /mnt/boot failed"
    fi
  else
    log "ERROR: Mounting /dev/${ROOT} at /mnt failed"
  fi
}

auto_partition_with_encryption() {
  TITLE="${AUTO_PART_TITLE}"
  local input input_check

  # Set encryption password
  if yesno "$(eval echo \"${ENCRYPTION_CONFIRM}\")" "${YES}" "${NO}" \
      'defaultno'; then
    while true; do
      if ! input="$(dialog --no-cancel --clear --insecure --passwordbox \
          "\n$(eval echo \"${ENCRYPTION_PASSWORD_MSG}\")" 12 55)" ||
          ! input_check="$(dialog --no-cancel --clear --insecure --passwordbox \
          "\n$(eval echo \"${ENCRYPTION_PASSWORD_CONFIRM}\")" 12 55)" ||
          [[ -z "${input}" ]]; then
        message "${PASSWORD_EMPTY_MSG}"
      elif [[ "${input}" != "${input_check}" ]]; then
        message "${PASSWORD_MISMATCH_MSG}"
      else
        break
      fi
    done
  else
    return # back to 'prepare_drives'
  fi

  # Set up physical partitions
  if "${GPT}"; then
    if "${UEFI}"; then # UEFI/GPT
      echo -e "n\n\n\n512M\nef00\nn\n\n\n\n\nw\ny" |
        gdisk /dev/"${DRIVE}" &>/dev/null &
      load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
      BOOT="${DRIVE}${partition_prefix}1"
      ROOT="${DRIVE}${partition_prefix}2"
    else # BIOS/GPT
      echo -e "o\ny\nn\n1\n\n+512M\n\nn\n2\n\n+1M\nef02\nn\n3\n\n\n\nw\ny" |
        gdisk /dev/"${DRIVE}" &>/dev/null &
      load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
      BOOT="${DRIVE}${partition_prefix}1"
      ROOT="${DRIVE}${partition_prefix}3"
    fi
  else # BIOS/MBR
    echo -e "o\nn\np\n1\n\n+512M\nn\np\n2\n\n\nw" |
      fdisk /dev/"${DRIVE}" &>/dev/null &
    load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2fdisk \
/dev/${DRIVE}\Zn"
    BOOT="${DRIVE}${partition_prefix}1"
    ROOT="${DRIVE}${partition_prefix}2"
  fi
  log "Created boot partition: ${BOOT}"
  log "Created root partition: ${ROOT}"
  (
    sgdisk --zap-all /dev/"${ROOT}"
    sgdisk --zap-all /dev/"${BOOT}"
    wipefs -a /dev/"${ROOT}"
    wipefs -a /dev/"${BOOT}"
  ) &>/dev/null &
  load_bar "${WIPEFS_LOAD_MSG}\n\n \Z1> \Z2wipefs -a /dev/${ROOT}\Zn"
  log "Wiped boot and root partitions"
  (
    lvm pvcreate /dev/"${ROOT}"
    lvm vgcreate lvm /dev/"${ROOT}"
  ) &>/dev/null &
  load_bar "${PVCREATE_LOAD_MSG}\n\n \Z1> \Z2lvm pvcreate /dev/${ROOT}\Zn"
  log "Created physical root volume: /dev/${ROOT}"

  # Set up logical volumes
  if (( SWAP_SIZE > 0 )); then
    lvm lvcreate -L "${SWAP_SIZE}M" -n swap lvm &>/dev/null &
    load_bar "${SWAP_LOAD_MSG}\n\n \Z1> \Z2lvm lvcreate -L ${SWAP_SIZE}M -n \
swap lvm\Zn"
    log "Created logical swap space"
  fi
  (
    lvm lvcreate -L 500M -n tmp lvm
    lvm lvcreate -l 100%FREE -n lvroot lvm
  ) &>/dev/null &
  load_bar "${LVCREATE_LOAD_MSG}\n\n \Z1> \Z2lvm lvcreate -l 100%FREE -n \
lvroot lvm\Zn"
  log "Created logical root volume: lvroot"
  log "Created logical tmp filesystem: tmp"
  (
    printf "%s" "${input}" |
      cryptsetup luksFormat -c aes-xts-plain64 -s 512 /dev/lvm/lvroot -
    printf "%s" "${input}" | cryptsetup open --type luks /dev/lvm/lvroot root -
  ) &>/dev/null &
  load_bar "${ENCRYPTION_LOAD_MSG}\n\n \Z1> \Z2cryptsetup luksFormat -c \
aes-xts-plain64 -s 512 /dev/lvm/lvroot\Zn"
  unset input input_check
  log "Encrypted logical volume: lvroot"
  (
    wipefs -a /dev/mapper/root
    mkfs."${FS}" /dev/mapper/root
  ) &>/dev/null &
  load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${FS} \
/dev/mapper/root\Zn"
  log "Created root filesystem: ${FS}"

  # Format boot partition (unencrypted)
  if "${UEFI}"; then
    mkfs.vfat -F32 /dev/"${BOOT}" &>/dev/null &
    load_bar "${EFI_LOAD_MSG}\n\n \Z1> \Z2mkfs.vfat -F32 /dev/${BOOT}\Zn"
    ESP_MNT='/boot'
    log "EFI system partition (ESP): ${BOOT}"
    log "ESP mount point: ${ESP_MNT}"
    log "Created boot filesystem: vfat"
  else # BIOS
    # shellcheck disable=SC1001
    mkfs.ext4 -O \^64bit /dev/"${BOOT}" &>/dev/null &
    load_bar "${BOOT_LOAD_MSG}\n\n \Z1> \Z2mkfs.ext4 /dev/${BOOT}\Zn"
    log "Created boot filesystem: ext4"
  fi

  # Mount partitions
  if mount /dev/mapper/root /mnt &>/dev/null; then
    log "Mounted /dev/mapper/root at /mnt"
    mkdir /mnt/boot
    if mount /dev/"${BOOT}" /mnt/boot &>/dev/null; then
      log "Mounted /dev/${BOOT} at /mnt/boot"
      SYSTEM_MOUNTED='true'
      SYSTEM_AUTO_ENCRYPTED='true'
    else
      log "ERROR: Mounting /dev/${BOOT} at /mnt/boot failed"
    fi
  else
    log "ERROR: Mounting /dev/mapper/root at /mnt failed"
  fi
}

manually_partition() {
  local -i counter device_count
  local device dev_list dev_size dev_type dev_fs dev_mnt dev_used dev_parent \
    dev_menu_header='       Device    Size    Used    FS    Mount    Type' \
    part part_size part_type part_fs part_mount part_final disk_util \
    empty_value='----'

  while true; do
    # Prepare the manual partitioning menu via temp files part.sh/part.list
    TITLE="${MANUAL_PART_TITLE}"
    rm /tmp/gdl/part.sh /tmp/gdl/part.list &>/dev/null # rm old files (if any)
    dev_list="$(lsblk -no NAME,SIZE,TYPE,FSTYPE |
      grep -Ev "${USB}|loop[0-9]+|sr[0-9]+|fd[0-9]+" |
      sed 's/[^[:alnum:]_., -]//g' | column -t | sort -k 1,1 | uniq)"
    device_count="$(wc -l <<<"${dev_list}")"
    if "${REDUCE_EXTRANEOUS_TEXT}"; then
      # shellcheck disable=SC2028
      echo "dialog --stdout --colors --title \" ${TITLE} \" --ok-button \
\"${EDIT}\" --cancel-button \"${CANCEL}\" --menu \"\n${MANUAL_PART_MSG}\n
${dev_menu_header}\" 20 68 8 \\" >/tmp/gdl/part.sh
    else
      # shellcheck disable=SC2028
      echo "dialog --stdout --colors --backtitle \"${BACKTITLE}\" --title \
\" ${TITLE} \" --ok-button \"${EDIT}\" --cancel-button \"${CANCEL}\" --menu \
\"\n${MANUAL_PART_MSG}\n\n${dev_menu_header}\" 21 68 9 \\" >/tmp/gdl/part.sh
    fi
    counter=1
    until (( counter > device_count )); do
      device="$(awk <<<"${dev_list}" '{print $1}' | awk "NR==${counter}")"
      dev_size="$(grep -w "${device}" <<<"${dev_list}" | awk '{print $2}')"
      dev_type="$(grep -w "${device}" <<<"${dev_list}" | awk '{print $3}')"
      dev_fs="$(grep -w "${device}" <<<"${dev_list}" | awk '{print $4}')"
      dev_mnt="$(df | grep -w "${device}" | awk '{print $6}' |
        sed 's/mnt\/\?//')"
      if grep -q '/' <<<"${dev_mnt}"; then
        dev_used="$(df -T | grep -w "${device}" | awk '{print $6}')"
      else
        dev_used=$(swapon -s | grep -w "${device}" | awk '{print $4}')
        if [[ -n "${dev_used}" ]]; then
          dev_used="${dev_used}%"
        fi
      fi
      [[ -z "${dev_fs}" || "${dev_fs}" == "linux_raid_member" ]] &&
        dev_fs="${empty_value}"
      [[ -z "${dev_used}" ]] && dev_used="${empty_value}"
      [[ -z "${dev_mnt}" ]] && dev_mnt="${empty_value}"
      dev_parent="$(lsblk -dnro PKNAME /dev/"${device/-//}")"
      if [[ -z "${dev_parent}" ]]; then
        dev_type="$(grep -w "${device}" <<<"${dev_list}" | awk '{print $3}')"
      else
        dev_type="$(fdisk -lo Device,Type /dev/"${dev_parent}" |
          grep -w "${device}" | cut -d ' ' -f 2- |
          sed -e 's/^[[:space:]]*//;s/[[:space:]]*$//;s/ /_/g')"
      fi
      echo "\"${device}\" \"${dev_size} ${dev_used} ${dev_fs} ${dev_mnt} \
${dev_type}\" \\" >>/tmp/gdl/part.list
      (( ++counter ))
    done
    column </tmp/gdl/part.list -t >>/tmp/gdl/part.sh
    echo -e "\"${DONE}\" \"${WRITE_CHANGES}\"" >>/tmp/gdl/part.sh

    # Present the manual partitioning menu and get user input
    if ! part="$(bash /tmp/gdl/part.sh | sed 's/^\s\+//g;s/\s\+$//g')" ||
        [[ -z "${part}" ]]; then
      SYSTEM_MOUNTED='false'
      return # back to 'prepare_drives'
    fi
    log "Manual partitioning menu selection: ${part}"

    # If user selected 'done', attempt to finish the partitioning process
    if [[ "${part}" == "${DONE}" ]]; then
      if ! "${SYSTEM_MOUNTED}"; then
        message "${ROOT_UNMOUNTED_ERROR_MSG}"
        continue
      elif "${GPT}" && ! "${UEFI}" && ! fdisk -l | grep -q 'BIOS boot'; then
        message "${GPT_BIOS_ERROR_MSG}"
        continue
      elif [[ -z "${BOOT}" ]]; then
        BOOT="${ROOT}"
      fi
      part_final="$( (df -h | grep '/mnt' | awk '{print $1,$2,$6 "\\n"}' |
        sed 's/mnt\/\?//'; swapon | awk 'NR==2 {print $1,$3,"SWAP"}') |
        column -t)"
      yesno "${WRITE_CONFIRM}\n\n${PARTITION}  ${SIZE}  ${MOUNT_POINT}\n\n\
${part_final}" "${OK}" "${CANCEL}" 'defaultno' || continue
      return # all done: return to 'prepare_drives'
    fi

    # If not 'done', prepare and present a disk/partition editing menu
    part_size="$(grep -w "${part}" <<<"${dev_list}" | awk '{print $2}')"
    part_type="$(grep -w "${part}" <<<"${dev_list}" | awk '{print $3}')"
    part_fs="$(grep -w "${part}" <<<"${dev_list}" | awk '{print $4}')"
    part_mount="$(df | grep -w "${part}" | awk '{print $6}' |
      sed 's/mnt\/\?//')"
    if [[ "${part_fs}" == "linux_raid_member" ]]; then
      continue
    elif [[ "${part_type}" == "lvm" ]]; then
      part="${part/-//}"
    fi

    # If user selected an entire drive, facilitate partitioning
    if [[ "${part_type}" == "disk" ]] ||
        (grep -Eq 'raid[0-9]+' <<<"${part_type}" && [[ -z "${part_fs}" ]]); then
      if df | grep -w "${part}" | grep -q '/mnt' && yesno "$(eval echo \
          \"${UNMOUNT_DRIVE_CONFIRM}\")" "${EDIT}" "${CANCEL}" 'defaultno'; then
        (
          umount -R /mnt
          swapoff -a
        ) &>/dev/null &
        load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2umount -R /mnt\Zn"
        SYSTEM_MOUNTED='false'
        DRIVE=''
        if disk_util="$(get_disk_util)"; then
          clear
          "${disk_util}" /dev/"${part}"
          log "Disk /dev/${part} edited via ${disk_util}"
          clear
        fi
      elif yesno "$(eval echo \"${EDIT_DRIVE_CONFIRM}\")" "${EDIT}" \
          "${CANCEL}" && disk_util="$(get_disk_util)"; then
        clear
        "${disk_util}" /dev/"${part}"
        log "Disk /dev/${part} edited via ${disk_util}"
        clear
      fi

    # If user selected a partition or md device, facilitate mounting/formatting
    else
      TITLE="${EDIT_PART_TITLE}"
      # The root '/' mount point must be established before others
      if [[ -z "${ROOT}" ]]; then
        case "${part_size}" in
          [1-9]T | 9G | [1-9][0-9]*[GT] | 9.*[GT] | 9,*[GT])
            # shellcheck disable=SC2015
            yesno "$(eval echo \"${ROOT_MNT_CONFIRM}\")" "${YES}" "${NO}" \
              'defaultno' && FS="$(get_filesystem)" || continue
            if yesno "$(eval echo \"${ROOT_FORMAT_CONFIRM}\")" \
                "${WRITE_CHANGES}" "${CANCEL}" 'defaultno'; then
              (
                sgdisk --zap-all /dev/"${part}"
                wipefs -a /dev/"${part}"
                mkfs."${FS}" /dev/"${part}"
              ) &>/dev/null &
              load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \
\Z2mkfs.${FS} /dev/${part}\Zn"
              if mount /dev/"${part}" /mnt &>/dev/null; then
                log "Mounted /dev/${part} at /mnt"
                SYSTEM_MOUNTED='true'
                ROOT="${part}"
                if [[ "${part_type}" == "lvm" ]]; then
                  lvm_pv="$(lvdisplay -m | grep -A 20 /dev/"${part}" |
                    grep 'Physical volume' | sed 's/^\s\+//g;s/\s\+/ /g' |
                    cut -d ' ' -f 3)"
                  DRIVE="$(lsblk -dnro PKNAME "${lvm_pv}")"
                else
                  DRIVE="$(lsblk -dnro PKNAME /dev/"${part}")"
                fi
                if parted /dev/"${DRIVE}" print | grep -q 'Table: gpt'; then
                  GPT='true'
                else
                  GPT='false'
                fi
              else
                SYSTEM_MOUNTED='false'
                log "ERROR: Mounting /dev/${part} at /mnt failed"
                message "${ROOT_MOUNT_ERROR_MSG}"
                return # back to 'prepare_drives'
              fi
            fi
            ;;
          *) message "${ROOT_SIZE_ERROR_MSG}" ;;
        esac
      # If the partition's already mounted, provide suitable options
      elif [[ -n "${part_mount}" ]]; then
        if yesno "$(eval echo \"${ALREADY_MOUNTED_MSG}\")" "${EDIT}" "${BACK}" \
            'defaultno'; then
          if [[ "${part}" == "${ROOT}" ]]; then
            if yesno "$(eval echo \"${UNMOUNT_ROOT_CONFIRM}\")" "${YES}" \
                "${NO}" 'defaultno'; then
              SYSTEM_MOUNTED='false'
              UEFI='false'
              DRIVE=''
              ROOT=''
              BOOT=''
              ESP_MNT=''
              umount -R /mnt &>/dev/null &
              load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2umount -R /mnt\Zn"
            fi
          else
            if [[ "${part_mount}" == "[SWAP]" ]] && yesno "$(eval echo \
                \"${SWAPOFF_CONFIRM}\")" "${YES}" "${NO}" 'defaultno'; then
              swapoff /dev/"${part}" &>/dev/null &
              load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2swapoff /dev/${part}\Zn"
            elif yesno "$(eval echo \"${UNMOUNT_CONFIRM}\")" "${YES}" "${NO}" \
                'defaultno'; then
              umount /mnt/"${part_mount}" &>/dev/null &
              load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2umount \
/mnt/${part_mount}\Zn"
              rm -r /mnt/"${part_mount:?}"
              if [[ "${part}" == "${BOOT}" ]]; then
                BOOT=''
              fi
              if [[ "${part}" == "${ESP_MNT}" ]]; then
                UEFI='false'
                ESP_MNT=''
              fi
            fi
          fi
        fi
      # If it's a swap partition, optionally format and attempt to 'swapon'
      elif (( $(fdisk -l | grep -w "${part}" | sed 's/\*//' |
              awk '{print $6}') == 82 )) ||
          (fdisk -l /dev/"$(lsblk -dnro PKNAME /dev/"${part}")" |
           grep -q 'gpt' && [[ "$(fdisk -l -o Device,Size,Type-UUID |
           grep -w "${part}" | awk '{print $3}')" == \
           "0657FD6D-A4AB-43C4-84E5-0933C84B4F4F" ]]); then
        if yesno "${SWAP_FORMAT_CONFIRM}" "${YES}" "${NO}"; then
          format_swap_partition "${part}"
        elif ! swapon /dev/"${part}" &>/dev/null; then
          message "${SWAPON_ERROR_MSG}"
        fi
      # If the partition's not yet mounted, provide mount point options
      elif yesno "$(eval echo \"${MNT_CONFIRM}\")" "${EDIT}" "${BACK}"; then
        mnt="$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
          --menu "\n$(eval echo \"${SELECT_MNT_MSG}\")" 15 60 6 \
          '/home' '->' \
          '/boot' '->' \
          '/efi' '->' \
          '/opt' '->' \
          '/usr' '->' \
          '/var' '->' \
          '/tmp' '->' \
          "${CUSTOM}" '->')" || continue
        if [[ "${mnt}" == "${CUSTOM}" ]]; then
          while true; do
            mnt="$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
              --inputbox "\n${CUSTOM_MNT_MSG}" 10 50 '/')" || continue 2
            if grep -q "[\[\$\!\'\"\`\\|%&#@()+=<>~;:?.,^{}]\|]" \
                <<<"${mnt}"; then
              message "${CUSTOM_MNT_CHAR_ERROR_MSG}"
            elif [[ "${mnt}" == '/' ]]; then
              message "${CUSTOM_MNT_ROOT_ERROR_MSG}"
            else
              [[ "${mnt}" =~ ^/.+ ]] || mnt="/${mnt}"
              break
            fi
          done
        fi
        # Provide formatting options
        if yesno "${PART_FORMAT_MSG}" "${YES}" "${NO}" 'defaultno'; then
          if [[ "${mnt}" == '/efi' || "${mnt}" == '/boot/efi' ]] ||
              fdisk -l | grep "${part}" | grep -q 'EFI'; then
            FS="$(dialog --menu "\n${EFI_VFAT_MSG}" 12 65 1 'vfat' \
              "${FS_VFAT_MSG}")" || continue
          else
            FS="$(get_filesystem)" || continue
          fi
          log "Selected filesystem for ${mnt}: ${FS}"
          yesno "$(eval echo \"${PART_FORMAT_CONFIRM}\")" "${WRITE_CHANGES}" \
            "${CANCEL}" 'defaultno' || continue
          (
            sgdisk --zap-all /dev/"${part}"
            wipefs -a /dev/"${part}"
            case "${FS}" in
              vfat) mkfs.vfat -F32 /dev/"${part}" ;;
              *) mkfs."${FS}" /dev/"${part}" ;;
            esac
          ) &>/dev/null &
          load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${FS} \
/dev/${part}\Zn"
        fi
        # Attempt to mount the partition at the given mount point
        if mkdir -p /mnt"${mnt}" &&
            mount /dev/"${part}" /mnt"${mnt}" &>/dev/null; then
          log "Mounted /dev/${part} at /mnt${mnt}"
          if [[ "${mnt}" == '/boot' ]]; then
            BOOT="${part}"
          fi
          if [[ "${mnt}" == '/efi' || "${mnt}" == '/boot/efi' ]] ||
              fdisk -l | grep "${part}" | grep -q 'EFI'; then
            UEFI='true'
            ESP_MNT="${mnt}"
          fi
        else
          log "ERROR: Mounting /dev/${part} at /mnt${mnt} failed"
          message "${MOUNT_ERROR_MSG}"
        fi
      fi
    fi
  done
}

get_disk_util() {
  dialog --menu "\n${SELECT_DISK_UTIL_MSG}" 12 60 3 \
    'cfdisk' "${CFDISK_MSG}" \
    'fdisk' "${FDISK_MSG}" \
    'gdisk' "${GDISK_MSG}"
}

format_swap_partition() {
  if (( $# == 0 )); then
    log "ERROR: No argument passed to 'format_swap_partition'"
    return 1
  elif (( $# > 1 )); then
    log "ERROR: Multiple arguments passed to 'format_swap_partition' ($*)"
    return 1
  else
    (
      wipefs -a /dev/"$1"
      mkswap /dev/"$1"
      swapon /dev/"$1"
    ) &>/dev/null &
    load_bar "${SWAP_LOAD_MSG}\n\n \Z1> \Z2mkswap /dev/$1\Zn"
    log "Created and activated swap space: $1"
  fi
}

prepare_base() {
  TITLE="${INSTALLATION_TITLE}"
  local additional_packages

  if grep -q 'AuthenticAMD' /proc/cpuinfo; then
    BASE_PACKAGES+='amd-ucode '
    log "Added AMD microcode"
  elif grep -q 'GenuineIntel' /proc/cpuinfo; then
    BASE_PACKAGES+='intel-ucode '
    log "Added Intel microcode"
  fi
  if "${WIFI_AVAILABLE}" ||
      yesno "${WIFI_MSG}" "${YES}" "${NO}" 'defaultno'; then
    BASE_PACKAGES+='wireless_tools wpa_supplicant '
    log "Added wireless utilities"
  fi
  if "${BLUETOOTH_AVAILABLE}"; then
    BASE_PACKAGES+='blueman bluez bluez-utils pulseaudio-bluetooth '
    log "Added bluetooth support"
  fi
  if yesno "${TOUCHPAD_MSG}" "${YES}" "${NO}" 'defaultno'; then
    BASE_PACKAGES+='xf86-input-libinput '
    log "Added touchpad support"
  fi
  if yesno "${OS_PROBER_MSG}" "${YES}" "${NO}" 'defaultno'; then
    BASE_PACKAGES+='os-prober '
    log "Added os-prober"
  fi
  if "${UEFI}"; then
    BASE_PACKAGES+='efibootmgr '
    log "Added efibootmgr"
  fi

  # Graphics and VM packages
  if [[ "${VM_TYPE}" != 'none' ]]; then
    case "${VM_TYPE}" in
      qemu)
        additional_packages="spice-vdagent"
        log "Added QEMU guest utils: ${additional_packages}"
        ;;
      oracle)
        additional_packages="virtualbox-guest-utils"
        log "Added VirtualBox guest utils: ${additional_packages}"
        ;;
      vmware)
        additional_packages="xf86-video-vmware xf86-input-vmmouse open-vm-tools
          net-tools gtkmm"
        log "Added VMware guest utils: ${additional_packages}"
        ;;
      *)
        additional_packages="xf86-video-fbdev"
        log "Added generic VM guest utils: ${additional_packages}"
        ;;
    esac
  else
    if [[ "${GRAPHICS_CHIPSET}" == 'NVIDIA' ]]; then
      until additional_packages="$(dialog --ok-button "${OK}" --no-cancel \
          --menu "\n$(eval echo \"${GRAPHICS_DRIVER_MSG}\")" 18 60 7 \
          "${DEFAULT}" "${GRAPHICS_DEFAULT_MSG}" \
          'nvidia' "${GRAPHICS_NVIDIA_MSG}" \
          'xf86-video-nouveau' "${GRAPHICS_NOUVEAU_MSG}" \
          'xf86-video-intel' "${GRAPHICS_INTEL_MSG}" \
          'xf86-video-vesa' "${GRAPHICS_VESA_MSG}" \
          'xf86-video-ati' "${GRAPHICS_ATI_MSG}" \
          'xf86-video-amdgpu' "${GRAPHICS_AMDGPU_MSG}")"; do
        continue
      done
    else
      until additional_packages="$(dialog --ok-button "${OK}" --no-cancel \
          --menu "\n$(eval echo \"${GRAPHICS_DRIVER_MSG}\")" 17 60 6 \
          "${DEFAULT}" "${GRAPHICS_DEFAULT_MSG}" \
          'xf86-video-ati' "${GRAPHICS_ATI_MSG}" \
          'xf86-video-amdgpu' "${GRAPHICS_AMDGPU_MSG}" \
          'xf86-video-intel' "${GRAPHICS_INTEL_MSG}" \
          'xf86-video-vesa' "${GRAPHICS_VESA_MSG}" \
          'nvidia' "${GRAPHICS_NVIDIA_MSG}" \
          'xf86-video-nouveau' "${GRAPHICS_NOUVEAU_MSG}")"; do
        continue
      done
    fi
    if [[ "${additional_packages}" == "${DEFAULT}" ]]; then
      additional_packages="${DEFAULT_GRAPHICS_DRIVER}"
    fi
    if [[ "${additional_packages}" == 'nvidia' ]]; then
      additional_packages+=' nvidia-dkms nvidia-utils lib32-nvidia-utils
        nvidia-settings nvidia-libgl nvidia-prime'
    elif [[ "${additional_packages}" == 'xf86-video-ati' ||
            "${additional_packages}" == 'xf86-video-amdgpu' ]]; then
      additional_packages+=' vulkan-radeon lib32-vulkan-radeon'
    elif [[ "${additional_packages}" == 'xf86-video-intel' ]]; then
      additional_packages+=' vulkan-intel lib32-vulkan-intel
        lib32-libva-intel-driver'
    fi
    log "Added graphics driver packages: ${additional_packages}"
  fi
  BASE_PACKAGES+="${additional_packages} "
}

set_hostname() {
  TITLE="${SET_HOSTNAME_TITLE}"
  while true; do
    if HOSTNAME="$(dialog --ok-button "${OK}" --no-cancel --inputbox \
        "\n${SET_HOSTNAME_MSG}" 12 55 "${HOSTNAME}" | sed 's/ //g')" &&
        [[ -n "${HOSTNAME}" ]]; then
      # Check for a starting number or any unallowed characters
      if grep -q "^[0-9]\|[\[\$\!\'\"\`\\|%&#@()+=<>~;:/?.,^{}]\|]" \
          <<<"${HOSTNAME}"; then
        message "${HOSTNAME_ERROR_MSG}"
      else
        break
      fi
    fi
  done
}

set_user() {
  TITLE="${ADD_USER_TITLE}"
  while true; do
    # Prompt for username
    if ! USERNAME="$(dialog --cancel-button "${CANCEL}" --ok-button "${OK}" \
        --inputbox "\n${SET_USERNAME_MSG}" 12 55)" ||
        [[ -z "${USERNAME}" ]]; then
      message "${USERNAME_EMPTY_ERROR_MSG}"
    elif grep -q "^[0-9]\|[A-Z]\|[]:/?#@\!\$&'()*+,;=%[]" <<<"${USERNAME}"; then
      message "${USERNAME_CHAR_ERROR_MSG}"
    else
      log "Username set: ${USERNAME}"
      while true; do
        # Prompt for full name
        if FULL_NAME="$(dialog --cancel-button "${CANCEL}" --ok-button "${OK}" \
            --inputbox "\n${SET_FULL_NAME_MSG}" 12 55)"; then
          if grep -q ',' <<<"${FULL_NAME}"; then
            message "${FULL_NAME_ERROR_MSG}"
          else
            # Prompt for password ('root' will use the same password)
            set_password
            break
          fi
        fi
      done
      break
    fi
  done
}

set_password() {
  TITLE="${SET_PASSWORD_TITLE}"
  local input input_check

  while true; do
    if ! input="$(dialog --no-cancel --clear --insecure --passwordbox \
        "\n$(eval echo \"${USER_PASSWORD_MSG}\")" 11 55)" ||
        ! input_check="$(dialog --no-cancel --clear --insecure --passwordbox \
        "\n$(eval echo \"${USER_PASSWORD_CONFIRM}\")" 11 55)" ||
        [[ -z "${input}" ]]; then
      message "${PASSWORD_EMPTY_MSG}"
    elif [[ "${input}" != "${input_check}" ]]; then
      message "${PASSWORD_MISMATCH_MSG}"
    else
      break
    fi
  done
  PASSWORD="$(echo "${input}" | openssl enc -aes-256-cbc -a -salt -pbkdf2 \
    -iter 1000 -pass pass:"${SSL_KEY}")"
  unset input input_check
  log "Password set for user: ${USERNAME}"
}

select_additional_software() {
  local software=''

  TITLE="${MISC_GAMES_SOFTWARE_TITLE}"
  software+="$(dialog --no-cancel --ok-button "${OK}" --checklist \
    "\n${SELECT_SOFTWARE_MSG}" 0 0 0 \
    'lutris' "${SOFTWARE_LUTRIS}" OFF \
    'steam' "${SOFTWARE_STEAM}" OFF \
    'itch' "(AUR) ${SOFTWARE_ITCH}" OFF \
    'legendary' "(AUR) ${SOFTWARE_LEGENDARY}" OFF \
    'playonlinux' "${SOFTWARE_PLAYONLINUX}" OFF \
    'libretro' "${SOFTWARE_LIBRETRO}" OFF \
    'dosbox' "${SOFTWARE_DOSBOX}" OFF \
    'scummvm' "${SOFTWARE_SCUMMVM}" OFF) "
  if grep -q 'lutris' <<<"${software}"; then
    BASE_PACKAGES+="${LUTRIS_PACKAGES} " # install with base
  fi
  if grep -q 'steam' <<<"${software}"; then
    BASE_PACKAGES+='steam steam-native-runtime ' # install with base
  fi

  TITLE="${ACTION_GAMES_SOFTWARE_TITLE}"
  software+="$(dialog --no-cancel --ok-button "${OK}" --checklist \
    "\n${SELECT_SOFTWARE_MSG}" 0 0 0 \
    'supertux' "${SOFTWARE_SUPERTUX}" OFF \
    'frogatto' "${SOFTWARE_FROGATTO}" OFF \
    'alex4' "${SOFTWARE_ALEX4}" OFF \
    'asciiportal' "${SOFTWARE_ASCIIPORTAL}" OFF \
    'mari0' "${SOFTWARE_MARI0}" OFF \
    'xonotic' "${SOFTWARE_XONOTIC}" OFF \
    'warsow' "${SOFTWARE_WARSOW}" OFF \
    'sauerbraten' "${SOFTWARE_SAUERBRATEN}" OFF \
    'assaultcube-reloaded' "(AUR) ${SOFTWARE_ASSAULTCUBE_RELOADED}" OFF \
    'openarena' "(AUR) ${SOFTWARE_OPENARENA}" OFF \
    'astromenace' "${SOFTWARE_ASTROMENACE}" OFF \
    'chromium-bsu' "${SOFTWARE_CHROMIUM_BSU}" OFF \
    'starfighter' "(AUR) ${SOFTWARE_STARFIGHTER}" OFF \
    'teeworlds' "${SOFTWARE_TEEWORLDS}" OFF \
    'bzflag' "(AUR) ${SOFTWARE_BZFLAG}" OFF) "

  TITLE="${ADVENTURE_GAMES_SOFTWARE_TITLE}"
  software+="$(dialog --no-cancel --ok-button "${OK}" --checklist \
    "\n${SELECT_SOFTWARE_MSG}" 0 0 0 \
    'bass' "${SOFTWARE_BASS}" OFF \
    'fotaq' "(AUR) ${SOFTWARE_FOTAQ}" OFF \
    'lure' "(AUR) ${SOFTWARE_LURE}" OFF \
    'drascula' "(AUR) ${SOFTWARE_DRASCULA}" OFF \
    'zsdx' "(AUR) ${SOFTWARE_ZSDX}" OFF \
    'sdlpop' "(AUR) ${SOFTWARE_SDLPOP}" OFF \
    'zork1' "(AUR) ${SOFTWARE_ZORK1}" OFF \
    'zork2' "(AUR) ${SOFTWARE_ZORK2}" OFF \
    'zork3' "(AUR) ${SOFTWARE_ZORK3}" OFF \
    'open-adventure' "(AUR) ${SOFTWARE_OPEN_ADVENTURE}" OFF) "
  if grep -q 'drascula' <<<"${software}"; then
    software+='drascula-audio '
  fi

  TITLE="${ROLEPLAYING_GAMES_SOFTWARE_TITLE}"
  software+="$(dialog --no-cancel --ok-button "${OK}" --checklist \
    "\n${SELECT_SOFTWARE_MSG}" 0 0 0 \
    'openmw' "${SOFTWARE_OPENMW}" OFF \
    'openmw-tes3mp' "(AUR) ${SOFTWARE_OPENMW_TES3MP}" OFF \
    'daggerfall-unity-aur-bin' "(AUR) ${SOFTWARE_DAGGERFALL_UNITY_AUR_BIN}" OFF\
    'freedroidrpg' "${SOFTWARE_FREEDROIDRPG}" OFF \
    'flare-game' "(AUR) ${SOFTWARE_FLARE_GAME}" OFF \
    'naev' "${SOFTWARE_NAEV}" OFF \
    'rogue' "${SOFTWARE_ROGUE}" OFF \
    'angband' "${SOFTWARE_ANGBAND}" OFF \
    'umoria' "(AUR) ${SOFTWARE_UMORIA}" OFF \
    'nethack' "${SOFTWARE_NETHACK}" OFF \
    'tome4' "(AUR) ${SOFTWARE_TOME4}" OFF \
    'stone-soup' "${SOFTWARE_STONE_SOUP}" OFF \
    'cataclysm-dda-tiles' "${SOFTWARE_CATACLYSM_DDA_TILES}" OFF \
    'doomrl' "(AUR) ${SOFTWARE_DOOMRL}" OFF \
    'planeshift' "(AUR) ${SOFTWARE_PLANESHIFT}" OFF \
    'runescape-launcher' "(AUR) ${SOFTWARE_RUNESCAPE_LAUNCHER}" OFF \
    'runelite' "(AUR) ${SOFTWARE_RUNELITE}" OFF \
    'manaplus' "${SOFTWARE_MANAPLUS}" OFF) "

  TITLE="${STRATEGY_GAMES_SOFTWARE_TITLE}"
  software+="$(dialog --no-cancel --ok-button "${OK}" --checklist \
    "\n${SELECT_SOFTWARE_MSG}" 0 0 0 \
    '0ad' "${SOFTWARE_0AD}" OFF \
    'widelands' "${SOFTWARE_WIDELANDS}" OFF \
    'megaglest' "${SOFTWARE_MEGAGLEST}" OFF \
    'warzone2100' "${SOFTWARE_WARZONE2100}" OFF \
    'boswars' "(AUR) ${SOFTWARE_BOSWARS}" OFF \
    'curseofwar' "${SOFTWARE_CURSEOFWAR}" OFF \
    'pingus' "${SOFTWARE_PINGUS}" OFF \
    'wesnoth' "${SOFTWARE_WESNOTH}" OFF \
    'hedgewars' "${SOFTWARE_HEDGEWARS}" OFF \
    'warmux' "(AUR) ${SOFTWARE_WARMUX}" OFF \
    'freeciv' "${SOFTWARE_FREECIV}" OFF \
    'singularity' "${SOFTWARE_SINGULARITY}" OFF) "

  TITLE="${RACING_GAMES_SOFTWARE_TITLE}"
  software+="$(dialog --no-cancel --ok-button "${OK}" --checklist \
    "\n${SELECT_SOFTWARE_MSG}" 0 0 0 \
    'supertuxkart' "${SOFTWARE_SUPERTUXKART}" OFF \
    'extremetuxracer' "${SOFTWARE_EXTREMETUXRACER}" OFF \
    'armagetronad' "${SOFTWARE_ARMAGETRONAD}" OFF \
    'gltron' "(AUR) ${SOFTWARE_GLTRON}" OFF \
    'torcs' "(AUR) ${SOFTWARE_TORCS}" OFF) "

  TITLE="${SIM_GAMES_SOFTWARE_TITLE}"
  software+="$(dialog --no-cancel --ok-button "${OK}" --checklist \
    "\n${SELECT_SOFTWARE_MSG}" 0 0 0 \
    'dwarffortress' "${SOFTWARE_DWARFFORTRESS}" OFF \
    'lincity-ng' "${SOFTWARE_LINCITY_NG}" OFF \
    'simutrans' "${SOFTWARE_SIMUTRANS}" OFF \
    'flightgear' "(AUR) ${SOFTWARE_FLIGHTGEAR}" OFF \
    'minetest' "${SOFTWARE_MINETEST}" OFF \
    'minecraft-launcher' "(AUR) ${SOFTWARE_MINECRAFT_LAUNCHER}" OFF) "

  TITLE="${DEV_SOFTWARE_TITLE}"
  software+="$(dialog --no-cancel --ok-button "${OK}" --checklist \
    "\n${SELECT_SOFTWARE_MSG}" 0 0 0 \
    'godot' "${SOFTWARE_GODOT}" OFF \
    'love' "${SOFTWARE_LOVE}" OFF \
    'solarus' "(AUR) ${SOFTWARE_SOLARUS}" OFF \
    'spring' "${SOFTWARE_SPRING}" OFF \
    'unityhub' "(AUR) ${SOFTWARE_UNITYHUB}" OFF \
    'unreal-engine' "(AUR) ${SOFTWARE_UNREAL_ENGINE}" OFF \
    'tiled' "${SOFTWARE_TILED}" OFF \
    'android-studio' "(AUR) ${SOFTWARE_ANDROID_STUDIO}" OFF \
    'allegro' "${SOFTWARE_ALLEGRO}" OFF \
    'python-pygame' "${SOFTWARE_PYTHON_PYGAME}" OFF \
    'panda3d' "(AUR) ${SOFTWARE_PANDA3D}" OFF \
    'pygtk' "(AUR) ${SOFTWARE_PYGTK}" OFF \
    'scratch' "${SOFTWARE_SCRATCH}" OFF \
    'atom' "${SOFTWARE_ATOM}" OFF \
    'code' "${SOFTWARE_CODE}" OFF \
    'geany' "${SOFTWARE_GEANY}" OFF \
    'emacs' "${SOFTWARE_EMACS}" OFF) "

  TITLE="${GRAPHICS_SOFTWARE_TITLE}"
  software+="$(dialog --no-cancel --ok-button "${OK}" --checklist \
    "\n${SELECT_SOFTWARE_MSG}" 0 0 0 \
    'gimp' "${SOFTWARE_GIMP}" OFF \
    'inkscape' "${SOFTWARE_INKSCAPE}" OFF \
    'blender' "${SOFTWARE_BLENDER}" OFF \
    'goxel' "(AUR) ${SOFTWARE_GOXEL}" OFF \
    'magicavoxel' "(AUR) ${SOFTWARE_MAGICAVOXEL}" OFF \
    'libresprite' "(AUR) ${SOFTWARE_LIBRESPRITE}" OFF \
    'aseprite' "(AUR) ${SOFTWARE_ASEPRITE}" OFF \
    'mtpaint' "${SOFTWARE_MTPAINT}" OFF \
    'mypaint' "${SOFTWARE_MYPAINT}" OFF \
    'krita' "${SOFTWARE_KRITA}" OFF) "

  TITLE="${MULTIMEDIA_SOFTWARE_TITLE}"
  software+="$(dialog --no-cancel --ok-button "${OK}" --checklist \
    "\n${SELECT_SOFTWARE_MSG}" 0 0 0 \
    'obs-studio' "${SOFTWARE_OBS_STUDIO}" OFF \
    'openshot' "${SOFTWARE_OPENSHOT}" OFF \
    'kdenlive' "${SOFTWARE_KDENLIVE}" OFF \
    'simplescreenrecorder' "${SOFTWARE_SIMPLESCREENRECORDER}" OFF \
    'youtube-dl' "${SOFTWARE_YOUTUBE_DL}" OFF \
    'spotify' "(AUR) ${SOFTWARE_SPOTIFY}" OFF \
    'audacity' "${SOFTWARE_AUDACITY}" OFF \
    'lmms' "${SOFTWARE_LMMS}" OFF \
    'pulseaudio-equalizer' "${SOFTWARE_PULSEAUDIO_EQUALIZER}" OFF) "

  TITLE="${INTERNET_SOFTWARE_TITLE}"
  software+="$(dialog --no-cancel --ok-button "${OK}" --checklist \
    "\n${SELECT_SOFTWARE_MSG}" 0 0 0 \
    'firefox' "${SOFTWARE_FIREFOX}" OFF \
    'chromium' "${SOFTWARE_CHROMIUM}" OFF \
    'google-chrome' "(AUR) ${SOFTWARE_GOOGLE_CHROME}" OFF \
    'opera' "${SOFTWARE_OPERA}" OFF \
    'discord' "${SOFTWARE_DISCORD}" OFF \
    'slack-desktop' "(AUR) ${SOFTWARE_SLACK_DESKTOP}" OFF \
    'hexchat' "${SOFTWARE_HEXCHAT}" OFF \
    'transmission-gtk' "${SOFTWARE_TRANSMISSION_GTK}" OFF \
    'piavpn-bin' "(AUR) ${SOFTWARE_PIAVPN_BIN}" OFF \
    'w3m' "${SOFTWARE_W3M}" OFF \
    'lynx' "${SOFTWARE_LYNX}" OFF \
    'minitube' "${SOFTWARE_MINITUBE}" OFF \
    'filezilla' "${SOFTWARE_FILEZILLA}" OFF) "

  TITLE="${FONTS_AND_LANG_SOFTWARE_TITLE}"
  software+="$(dialog --no-cancel --ok-button "${OK}" --checklist \
    "\n${SELECT_SOFTWARE_MSG}" 0 0 0 \
    'bdf-unifont' "${SOFTWARE_BDF_UNIFONT}" OFF \
    'noto-fonts-cjk' "${SOFTWARE_NOTO_FONTS_CJK}" OFF \
    'ibus-libpinyin' "${SOFTWARE_IBUS_LIBPINYIN}" OFF \
    'ibus-anthy' "${SOFTWARE_IBUS_ANTHY}" OFF \
    'ibus-hangul' "${SOFTWARE_IBUS_HANGUL}" OFF) "
  if grep -q 'ibus' <<<"${software}"; then
    echo -e "export GTK_IM_MODULE=ibus\nexport QT_IM_MODULE=ibus\nexport \
XMODIFIERS=@im=ibus\nibus-daemon -drx" >>/usr/share/gdl/extra/skel/.xprofile
  fi

  TITLE="${UTILITIES_SOFTWARE_TITLE}"
  software+="$(dialog --no-cancel --ok-button "${OK}" --checklist \
    "\n${SELECT_SOFTWARE_MSG}" 0 0 0 \
    'htop' "${SOFTWARE_HTOP}" OFF \
    'gtop' "${SOFTWARE_GTOP}" OFF \
    'bashtop' "${SOFTWARE_BASHTOP}" OFF \
    'mangohud' "(AUR) ${SOFTWARE_MANGOHUD}" OFF \
    'gparted' "${SOFTWARE_GPARTED}" OFF \
    'gnome-disk-utility' "${SOFTWARE_GNOME_DISK_UTILITY}" OFF \
    'baobab' "${SOFTWARE_BAOBAB}" OFF \
    'innoextract' "${SOFTWARE_INNOEXTRACT}" OFF \
    'tmux' "${SOFTWARE_TMUX}" OFF \
    'ranger' "${SOFTWARE_RANGER}" OFF \
    'virtualbox' "${SOFTWARE_VIRTUALBOX}" OFF \
    'vmware-workstation' "(AUR) ${SOFTWARE_VMWARE_WORKSTATION}" OFF \
    'insync' "(AUR) ${SOFTWARE_INSYNC}" OFF \
    'pcloud-drive' "(AUR) ${SOFTWARE_PCLOUD_DRIVE}" OFF \
    'timeshift' "(AUR) ${SOFTWARE_TIMESHIFT}" OFF \
    'luckybackup' "(AUR) ${SOFTWARE_LUCKYBACKUP}" OFF \
    'authy' "(AUR) ${SOFTWARE_AUTHY}" OFF \
    'clamav' "${SOFTWARE_CLAMAV}" OFF \
    'bleachbit' "${SOFTWARE_BLEACHBIT}" OFF) "
  if grep -q 'mangohud' <<<"${software}"; then
    software+='lib32-mangohud '
  fi

  # Add language pack (if applicable) for Firefox
  if grep -q 'firefox' <<<"${software}"; then
    case "${LOCALE}" in
      ach_*) software+='firefox-i18n-ach ' ;; # Acholi
      af_*) software+='firefox-i18n-af ' ;; # Afrikaans
      an_*) software+='firefox-i18n-an ' ;; # Aragonese
      ar_*) software+='firefox-i18n-ar ' ;; # Arabic
      ast_*) software+='firefox-i18n-ast ' ;; # Asturianu
      az_*) software+='firefox-i18n-az ' ;; # Azerbaijani
      be_*) software+='firefox-i18n-be ' ;; # Belarusian
      bg_*) software+='firefox-i18n-bg ' ;; # Bulgarian
      bn_*) software+='firefox-i18n-bn ' ;; # Bengali
      br_*) software+='firefox-i18n-br ' ;; # Breton
      bs_*) software+='firefox-i18n-bs ' ;; # Bosnian
      ca_*val*) software+='firefox-i18n-ca-valencia ' ;; # Catalan (Valencia)
      ca_*) software+='firefox-i18n-ca ' ;; # Catalan
      cak_*) software+='firefox-i18n-cak ' ;; # Maya Kaqchikel
      cs_*) software+='firefox-i18n-cs ' ;; # Czech
      cy_*) software+='firefox-i18n-cy ' ;; # Welsh
      da_*) software+='firefox-i18n-da ' ;; # Danish
      de_*) software+='firefox-i18n-de ' ;; # German
      dsb_*) software+='firefox-i18n-dsb ' ;; # Sorbian (Lower)
      el_*) software+='firefox-i18n-el ' ;; # Greek
      en_CA*) software+='firefox-i18n-en-gb ' ;; # English (Canada)
      en_US*) software+='firefox-i18n-en-us ' ;; # English (United States)
      en_*) software+='firefox-i18n-en-gb ' ;; # English (Great Britain)
      eo_*) software+='firefox-i18n-eo ' ;; # Esperanto
      es_AR*) software+="firefox-i18n-es-ar " ;; # Spanish (Argentina)
      es_CL*) software+="firefox-i18n-es-cl " ;; # Spanish (Chile)
      es_MX*) software+="firefox-i18n-es-mx " ;; # Spanish (Mexico)
      es_*) software+="firefox-i18n-es-es " ;; # Spanish (Spain)
      et_*) software+='firefox-i18n-et ' ;; # Estonian
      eu_*) software+='firefox-i18n-eu ' ;; # Basque
      fa_*) software+='firefox-i18n-fa ' ;; # Persian
      ff_*) software+='firefox-i18n-ff ' ;; # Fulah
      fi_*) software+='firefox-i18n-fi ' ;; # Finnish
      fr_*) software+='firefox-i18n-fr ' ;; # French
      fy_*) software+='firefox-i18n-fy-nl ' ;; # Frisian
      ga_*) software+='firefox-i18n-ga-ie ' ;; # Irish
      gd_*) software+='firefox-i18n-gd ' ;; # Gaelic (Scottish)
      gl_*) software+='firefox-i18n-gl ' ;; # Galician
      gn_*|gug_*) software+='firefox-i18n-gn ' ;; # Guarani
      gu_*) software+='firefox-i18n-gu-in ' ;; # Gujarati
      he_*) software+='firefox-i18n-he ' ;; # Hebrew
      hi_*) software+='firefox-i18n-hi-in ' ;; # Hindi
      hr_*) software+='firefox-i18n-hr ' ;; # Croatian
      hsb_*) software+='firefox-i18n-hsb ' ;; # Sorbian (Upper)
      hu_*) software+='firefox-i18n-hu ' ;; # Hungarian
      hy_*) software+='firefox-i18n-hy-am ' ;; # Armenian
      ia_*) software+='firefox-i18n-ia ' ;; # Interlingua
      id_*) software+='firefox-i18n-id ' ;; # Indonesian
      is_*) software+='firefox-i18n-is ' ;; # Icelandic
      it_*) software+='firefox-i18n-it ' ;; # Italian
      ja_*) software+='firefox-i18n-ja ' ;; # Japanese
      ka_*) software+='firefox-i18n-ka ' ;; # Georgian
      kab_*) software+='firefox-i18n-kab ' ;; # Kabyle, Taqbaylit, etc.
      kk_*) software+='firefox-i18n-kk ' ;; # Kazakh
      km_*) software+='firefox-i18n-km ' ;; # Khmer
      kn_*) software+='firefox-i18n-kn ' ;; # Kannada
      ko_*) software+='firefox-i18n-ko ' ;; # Korean
      lij_*) software+='firefox-i18n-lij ' ;; # Ligurian
      lt_*) software+='firefox-i18n-lt ' ;; # Lithuanian
      lv_*) software+='firefox-i18n-lv ' ;; # Latvian
      mk_*) software+='firefox-i18n-mk ' ;; # Macedonian
      mr_*) software+='firefox-i18n-mr ' ;; # Marathi
      ms_*) software+='firefox-i18n-ms ' ;; # Malay
      my_*) software+='firefox-i18n-my ' ;; # Burmese
      nb_*) software+='firefox-i18n-nb-no ' ;; # Norwegian (Bokmål)
      ne_*) software+='firefox-i18n-ne-np ' ;; # Nepali
      nl_*) software+='firefox-i18n-nl ' ;; # Dutch
      nn_*) software+='firefox-i18n-nn-no ' ;; # Norwegian (Nynorsk)
      oc_*) software+='firefox-i18n-oc ' ;; # Occitan
      pa_*) software+='firefox-i18n-pa-in ' ;; # Punjabi
      pl_*) software+='firefox-i18n-pl ' ;; # Polish
      pt_BR*) software+='firefox-i18n-pt-br ' ;; # Portuguese (Brazil)
      pt_*) software+='firefox-i18n-pt-pt ' ;; # Portuguese (Portugal)
      rm_*) software+='firefox-i18n-rm ' ;; # Romansh
      ro_*) software+='firefox-i18n-ro ' ;; # Romanian
      ru_*) software+='firefox-i18n-ru ' ;; # Russian
      si_*) software+='firefox-i18n-si ' ;; # Sinhala
      sk_*) software+='firefox-i18n-sk ' ;; # Slovak
      sl_*) software+='firefox-i18n-sl ' ;; # Slovenian
      son_*) software+='firefox-i18n-son ' ;; # Songhai
      sq_*) software+='firefox-i18n-sq ' ;; # Albanien
      sr_*) software+='firefox-i18n-sr ' ;; # Serbian
      sv_*) software+="firefox-i18n-sv-se " ;; # Swedish
      ta_*) software+='firefox-i18n-ta ' ;; # Tamil
      te_*) software+='firefox-i18n-te ' ;; # Telugu
      th_*) software+='firefox-i18n-th ' ;; # Thai
      tl_*) software+='firefox-i18n-tl ' ;; # Tagolog
      tr_*) software+='firefox-i18n-tr ' ;; # Turkish
      trs_*) software+='firefox-i18n-trs ' ;; # Chicahuaxtla Triqui
      uk_*) software+='firefox-i18n-uk ' ;; # Ukranian
      ur_*) software+='firefox-i18n-ur ' ;; # Urdu
      uz_*) software+='firefox-i18n-uz ' ;; # Uzbek
      vi_*) software+='firefox-i18n-vi ' ;; # Vietnamese
      xh_*) software+='firefox-i18n-xh ' ;; # Xhosa
      *_CN*|zh_SG*) software+='firefox-i18n-zh-cn ' ;; # Simplified Chinese
      zh_*|yue_*|*_TW*) software+='firefox-i18n-zh-tw ' ;; # Traditional Chinese
    esac
  fi

  AUR_AND_OPTIONAL_PACKAGES+="${software} "
}

install_base() {
  TITLE="${INSTALLATION_TITLE}"

  # Confirm user wants to begin installing packages
  while ! yesno "${INSTALL_CONFIRM}" "${YES}" "${NO}" 'defaultno'; do
    if yesno "${EXIT_CONFIRM}" "${YES}" "${NO}" 'defaultno'; then
      log "User chose to exit installer: installation cancelled"
      return_to_shell_prompt
    fi
  done

  # Add language pack (if applicable) for LibreOffice
  case "${LOCALE}" in
    af_*) BASE_PACKAGES+='libreoffice-fresh-af ' ;; # Afrikaans
    am_*) BASE_PACKAGES+='libreoffice-fresh-am ' ;; # Amharic
    ar_*) BASE_PACKAGES+='libreoffice-fresh-ar ' ;; # Arabic
    as_*) BASE_PACKAGES+='libreoffice-fresh-as ' ;; # Assamese
    ast_*) BASE_PACKAGES+='libreoffice-fresh-ast ' ;; # Asturianu
    be_*) BASE_PACKAGES+='libreoffice-fresh-be ' ;; # Belarusian
    bg_*) BASE_PACKAGES+='libreoffice-fresh-bg ' ;; # Bulgarian
    bn_IN*) BASE_PACKAGES+='libreoffice-fresh-bn-in ' ;; # Bengali (India)
    bn_*) BASE_PACKAGES+='libreoffice-fresh-bn ' ;; # Bengali
    bo_*) BASE_PACKAGES+='libreoffice-fresh-bo ' ;; # Tibetan
    br_*) BASE_PACKAGES+='libreoffice-fresh-br ' ;; # Breton
    brx_*) BASE_PACKAGES+='libreoffice-fresh-brx ' ;; # Bodo
    bs_*) BASE_PACKAGES+='libreoffice-fresh-bs ' ;; # Bosnian
    ca_*val*) BASE_PACKAGES+='libreoffice-fresh-ca-valencia ' ;; # Catalan (V.)
    ca_*) BASE_PACKAGES+='libreoffice-fresh-ca ' ;; # Catalan
    ckb_*) BASE_PACKAGES+='libreoffice-fresh-ckb ' ;; # Central Kurdish/Sorani
    cs_*) BASE_PACKAGES+='libreoffice-fresh-cs ' ;; # Czech
    cy_*) BASE_PACKAGES+='libreoffice-fresh-cy ' ;; # Welsh
    da_*) BASE_PACKAGES+='libreoffice-fresh-da ' ;; # Danish
    de_*) BASE_PACKAGES+='libreoffice-fresh-de ' ;; # German
    dgo_*) BASE_PACKAGES+='libreoffice-fresh-dgo ' ;; # Dogri
    dsb_*) BASE_PACKAGES+='libreoffice-fresh-dsb ' ;; # Sorbian (Lower)
    dz_*) BASE_PACKAGES+='libreoffice-fresh-dz ' ;; # Dzongkha
    el_*) BASE_PACKAGES+='libreoffice-fresh-el ' ;; # Greek
    en_ZA*) BASE_PACKAGES+='libreoffice-fresh-en-za ' ;; # English (S. Africa)
    en_[^U]*) BASE_PACKAGES+='libreoffice-fresh-en-gb ' ;; # English (GB)
    eo_*) BASE_PACKAGES+='libreoffice-fresh-eo ' ;; # Esperanto
    es_*) BASE_PACKAGES+='libreoffice-fresh-es ' ;; # Spanish
    et_*) BASE_PACKAGES+='libreoffice-fresh-et ' ;; # Estonian
    eu_*) BASE_PACKAGES+='libreoffice-fresh-eu ' ;; # Basque
    fa_*) BASE_PACKAGES+='libreoffice-fresh-fa ' ;; # Persian
    fi_*) BASE_PACKAGES+='libreoffice-fresh-fi ' ;; # Finnish
    fr_*) BASE_PACKAGES+='libreoffice-fresh-fr ' ;; # French
    fur_*) BASE_PACKAGES+='libreoffice-fresh-fur ' ;; # Friulian/Friulan
    fy_*) BASE_PACKAGES+='libreoffice-fresh-fy ' ;; # Frisian/Frysk/Fries
    ga_*) BASE_PACKAGES+='libreoffice-fresh-ga ' ;; # Irish
    gd_*) BASE_PACKAGES+='libreoffice-fresh-gd ' ;; # Gaelic (Scottish)
    gl_*) BASE_PACKAGES+='libreoffice-fresh-gl ' ;; # Galician
    gn_*|gug_*) BASE_PACKAGES+='libreoffice-fresh-gug ' ;; # Guarani
    gu_*) BASE_PACKAGES+='libreoffice-fresh-gu ' ;; # Gujarati
    he_*) BASE_PACKAGES+='libreoffice-fresh-he ' ;; # Hebrew
    hi_*) BASE_PACKAGES+='libreoffice-fresh-hi ' ;; # Hindi
    hr_*) BASE_PACKAGES+='libreoffice-fresh-hr ' ;; # Croatian
    hsb_*) BASE_PACKAGES+='libreoffice-fresh-hsb ' ;; # Sorbian (Upper)
    hu_*) BASE_PACKAGES+='libreoffice-fresh-hu ' ;; # Hungarian
    id_*) BASE_PACKAGES+='libreoffice-fresh-id ' ;; # Indonesian
    is_*) BASE_PACKAGES+='libreoffice-fresh-is ' ;; # Icelandic
    it_*) BASE_PACKAGES+='libreoffice-fresh-it ' ;; # Italian
    ja_*) BASE_PACKAGES+='libreoffice-fresh-ja ' ;; # Japanese
    ka_*) BASE_PACKAGES+='libreoffice-fresh-ka ' ;; # Georgian
    kab_*) BASE_PACKAGES+='libreoffice-fresh-kab ' ;; # Kabyle, Taqbaylit, etc.
    kk_*) BASE_PACKAGES+='libreoffice-fresh-kk ' ;; # Kazakh
    km_*) BASE_PACKAGES+='libreoffice-fresh-km ' ;; # Khmer
    kmr_*) BASE_PACKAGES+='libreoffice-fresh-kmr-latn ' ;; # Kurdish
    kn_*) BASE_PACKAGES+='libreoffice-fresh-kn ' ;; # Kannada
    ko_*) BASE_PACKAGES+='libreoffice-fresh-ko ' ;; # Korean
    kok_*) BASE_PACKAGES+='libreoffice-fresh-kok ' ;; # Konkani
    ks_*) BASE_PACKAGES+='libreoffice-fresh-ks ' ;; # Kashmiri
    lb_*) BASE_PACKAGES+='libreoffice-fresh-lb ' ;; # Luxembourgish
    lo_*) BASE_PACKAGES+='libreoffice-fresh-lo ' ;; # Lao
    lt_*) BASE_PACKAGES+='libreoffice-fresh-lt ' ;; # Lithuanian
    lv_*) BASE_PACKAGES+='libreoffice-fresh-lv ' ;; # Latvian
    mai_*) BASE_PACKAGES+='libreoffice-fresh-mai ' ;; # Maithili
    mk_*) BASE_PACKAGES+='libreoffice-fresh-mk ' ;; # Macedonian
    ml_*) BASE_PACKAGES+='libreoffice-fresh-ml ' ;; # Malayalam
    mn_*) BASE_PACKAGES+='libreoffice-fresh-mn ' ;; # Mongolian
    mni_*) BASE_PACKAGES+='libreoffice-fresh-mni ' ;; # Manipuri
    mr_*) BASE_PACKAGES+='libreoffice-fresh-mr ' ;; # Marathi
    my_*) BASE_PACKAGES+='libreoffice-fresh-my ' ;; # Burmese
    nb_*) BASE_PACKAGES+='libreoffice-fresh-nb ' ;; # Norwegian (Bokmål)
    ne_*) BASE_PACKAGES+='libreoffice-fresh-ne ' ;; # Nepali
    nl_*) BASE_PACKAGES+='libreoffice-fresh-nl ' ;; # Dutch
    nn_*) BASE_PACKAGES+='libreoffice-fresh-nn ' ;; # Norwegian (Nynorsk)
    nr_*) BASE_PACKAGES+='libreoffice-fresh-nr ' ;; # Ndebele
    nso_*) BASE_PACKAGES+='libreoffice-fresh-nso ' ;; # Sotho (Northern)
    oc_*) BASE_PACKAGES+='libreoffice-fresh-oc ' ;; # Occitan
    om_*) BASE_PACKAGES+='libreoffice-fresh-om ' ;; # Oromo
    or_*) BASE_PACKAGES+='libreoffice-fresh-or ' ;; # Oriya
    pa_*) BASE_PACKAGES+='libreoffice-fresh-pa-in ' ;; # Punjabi
    pl_*) BASE_PACKAGES+='libreoffice-fresh-pl ' ;; # Polish
    pt_BR*) BASE_PACKAGES+='libreoffice-fresh-pt-br ' ;; # Portuguese (Brazil)
    pt_*) BASE_PACKAGES+='libreoffice-fresh-pt ' ;; # Portuguese
    ro_*) BASE_PACKAGES+='libreoffice-fresh-ro ' ;; # Romanian
    ru_*) BASE_PACKAGES+='libreoffice-fresh-ru ' ;; # Russian
    rw_*) BASE_PACKAGES+='libreoffice-fresh-rw ' ;; # Kinyarwanda
    sa_*) BASE_PACKAGES+='libreoffice-fresh-sa-in ' ;; # Sanskrit
    sat_*) BASE_PACKAGES+='libreoffice-fresh-sat ' ;; # Santali
    sd_*) BASE_PACKAGES+='libreoffice-fresh-sd ' ;; # Sindhi
    si_*) BASE_PACKAGES+='libreoffice-fresh-si ' ;; # Sinhala
    sid_*) BASE_PACKAGES+='libreoffice-fresh-sid ' ;; # Sidama
    sk_*) BASE_PACKAGES+='libreoffice-fresh-sk ' ;; # Slovak
    sl_*) BASE_PACKAGES+='libreoffice-fresh-sl ' ;; # Slovenian
    sq_*) BASE_PACKAGES+='libreoffice-fresh-sq ' ;; # Albanien
    sr_*lat*) BASE_PACKAGES+='libreoffice-fresh-sr-latn ' ;; # Serbian (Latin)
    sr_*) BASE_PACKAGES+='libreoffice-fresh-sr ' ;; # Serbian
    ss_*) BASE_PACKAGES+='libreoffice-fresh-ss ' ;; # Swati
    st_*) BASE_PACKAGES+='libreoffice-fresh-st ' ;; # Sotho (Southern)
    sv_*) BASE_PACKAGES+='libreoffice-fresh-sv ' ;; # Swedish
    sw_*) BASE_PACKAGES+='libreoffice-fresh-sw-tz ' ;; # Swahili
    szl_*) BASE_PACKAGES+='libreoffice-fresh-szl ' ;; # Silesian
    ta_*) BASE_PACKAGES+='libreoffice-fresh-ta ' ;; # Tamil
    te_*) BASE_PACKAGES+='libreoffice-fresh-te ' ;; # Telugu
    tg_*) BASE_PACKAGES+='libreoffice-fresh-tg ' ;; # Tajik
    th_*) BASE_PACKAGES+='libreoffice-fresh-th ' ;; # Thai
    tn_*) BASE_PACKAGES+='libreoffice-fresh-tn ' ;; # Tswana
    tr_*) BASE_PACKAGES+='libreoffice-fresh-tr ' ;; # Turkish
    ts_*) BASE_PACKAGES+='libreoffice-fresh-ts ' ;; # Tsonga
    tt_*) BASE_PACKAGES+='libreoffice-fresh-tt ' ;; # Tatar
    ug_*) BASE_PACKAGES+='libreoffice-fresh-ug ' ;; # Uighur
    uk_*) BASE_PACKAGES+='libreoffice-fresh-uk ' ;; # Ukranian
    uz_*) BASE_PACKAGES+='libreoffice-fresh-uz ' ;; # Uzbek
    ve_*) BASE_PACKAGES+='libreoffice-fresh-ve ' ;; # Venda
    vec_*) BASE_PACKAGES+='libreoffice-fresh-vec ' ;; # Venetian
    vi_*) BASE_PACKAGES+='libreoffice-fresh-vi ' ;; # Vietnamese
    xh_*) BASE_PACKAGES+='libreoffice-fresh-xh ' ;; # Xhosa
    zh_CN*|zh_SG*) BASE_PACKAGES+='libreoffice-fresh-zh-cn ' ;; # Simp. Chinese
    zh_*|yue_*|*_TW*) BASE_PACKAGES+='libreoffice-fresh-zh-tw ' ;; # T. Chinese
    zu_*) BASE_PACKAGES+='libreoffice-fresh-zu ' ;; # Zulu
  esac

  # For btrfs installations, ensure grub can show available snapshots
  if mount | grep -q 'type btrfs'; then
    BASE_PACKAGES+='grub-btrfs '
  fi

  # Clean up package list
  BASE_PACKAGES="$(tr <<<"${BASE_PACKAGES}" " " "\n" | sort | uniq |
    tr "\n" " ")"
  log "Base package list: ${BASE_PACKAGES}"

  # Begin installation
  clear
  dragonsay "Installing base packages..." |& tee -a "${LOG_FILE}"
  pacman -Sy
  if pacstrap /mnt ${BASE_PACKAGES}; then
    log "Completed base installation"
  else
    local log_url
    log_url="$(nc termbin.com 9999 </root/gdl.log)"
    log "ERROR: Installation failed. Log uploaded to termbin.com: ${log_url}"
    message "${PACSTRAP_ERROR_MSG} ${log_url}"
    return_to_shell_prompt
  fi
}

configure_system() {
  local fstab='/mnt/etc/fstab' grub='/mnt/etc/default/grub' \
    grub_theme='/boot/grub/themes/gdl'

  # Initial fstab config
  genfstab -U /mnt >>"${fstab}"
  log "Generated fstab"

  # GRUB config
  mkdir -p /mnt"${grub_theme}"
  cp -r /usr/share/gdl/extra/grub-theme/* /mnt"${grub_theme}"
  if ! mount | grep -q 'type btrfs' ||
      (mount | grep -q ' /boot ' &&
       mount | grep ' /boot ' | grep -vq 'type btrfs'); then
    sed -i 's/GRUB_DEFAULT=0/GRUB_DEFAULT=saved/' "${grub}"
    sed -i 's/#GRUB_SAVEDEFAULT/GRUB_SAVEDEFAULT/' "${grub}"
  fi
  sed -i 's/GRUB_TIMEOUT=5/GRUB_TIMEOUT=3/' "${grub}"
  sed -i "s:#GRUB_COLOR_N.*$:GRUB_COLOR_NORMAL=\"red/black\":" "${grub}"
  sed -i "s:#GRUB_COLOR_H.*$:GRUB_COLOR_HIGHLIGHT=\"yellow/black\":" "${grub}"
  sed -i "s:#GRUB_THEME.*$:GRUB_THEME=\"${grub_theme}/theme.txt\":" "${grub}"
  if "${SYSTEM_AUTO_ENCRYPTED}"; then
    sed -i "s!quiet!cryptdevice=/dev/lvm/lvroot:root:allow-discards \
root=/dev/mapper/root transparent_hugepage=never!" "${grub}"
  else
    sed -i 's/quiet/transparent_hugepage=never/' "${grub}"
  fi
  if grep -q 'nvidia' <<<"${BASE_PACKAGES}"; then
    sed -i '/GRUB_CMDLINE_LINUX_DEFAULT=/ s/.$/ nvidia-drm.modeset=1"/;s/" /"/'\
      "${grub}"
  fi
  if "${UEFI}"; then
    arch-chroot /mnt grub-install --target=x86_64-efi \
      --efi-directory="${ESP_MNT}" --bootloader-id=GRUB
    cp /mnt"${ESP_MNT}"/EFI/boot/grubx64.efi \
      /mnt"${ESP_MNT}"/EFI/boot/bootx64.efi
    if ! "${SYSTEM_AUTO_ENCRYPTED}"; then
      arch-chroot /mnt mkinitcpio -P
    fi
  else
    arch-chroot /mnt grub-install /dev/"${DRIVE}"
  fi
  arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg
  log "Configured grub"

  # NVIDIA GPU config
  if grep -q 'nvidia' <<<"${BASE_PACKAGES}"; then
    sed -i \
      '/^MODULES=/ s/.$/ nvidia nvidia_modeset nvidia_uvm nvidia_drm )/;s/" /"/'
    sed -i 's!FILES=""!FILES="/etc/modprobe.d/nvidia.conf"!' \
      /mnt/etc/mkinitcpio.conf
    echo "options nvidia_drm modeset=1" >/mnt/etc/modprobe.d/nvidia.conf
    if grep -q 'nvidia' <<<"${BASE_PACKAGES}"; then
      echo "blacklist nouveau" >>/mnt/etc/modprobe.d/nvidia.conf
    fi
    if [[ ! -d /mnt/etc/pacman.d/hooks ]]; then
      mkdir /mnt/etc/pacman.d/hooks
    fi
    # https://wiki.archlinux.org/index.php/NVIDIA#Pacman_hook
    echo -e "[Trigger]\nOperation=Install\nOperation=Upgrade\nOperation=Remove\
\nType=Package\nTarget=nvidia\nTarget=linux\n\n[Action]\nDescription=Update \
Nvidia module in initcpio\nDepends=mkinitcpio\nWhen=PostTransaction\nNeeds\
Targets\nExec=/bin/sh -c 'while read -r trg; do case \$trg in linux) exit 0; \
esac; done; /usr/bin/mkinitcpio -P'\n" >/mnt/etc/pacman.d/hooks/nvidia.hook
    if ! "${SYSTEM_AUTO_ENCRYPTED}"; then
      arch-chroot /mnt mkinitcpio -P
    fi
    log "Enabled Nvidia DRM (Direct Rendering Manager)"
  fi

  # XFS config
  if mount | grep -q 'type xfs'; then
    sed -i '/^MODULES=/ s/.$/ xfs )/;s/" /"/' /mnt/etc/mkinitcpio.conf
    if ! "${SYSTEM_AUTO_ENCRYPTED}"; then
      arch-chroot /mnt mkinitcpio -P
    fi
    log "Configured system for xfs"
  fi

  # NVMe config
  if grep -q 'nvme' <<<"${BOOT}"; then
    sed -i '/^MODULES=/ s/.$/ nvme )/;s/" /"/' /mnt/etc/mkinitcpio.conf
    if ! "${SYSTEM_AUTO_ENCRYPTED}"; then
      arch-chroot /mnt mkinitcpio -P
    fi
    log "Configured system for nvme"
  fi

  # Additional fstab, mkinitcpio, etc., config
  if "${SYSTEM_AUTO_ENCRYPTED}"; then
    if "${UEFI}"; then
      echo "/dev/${BOOT} ${ESP_MNT} vfat rw,relatime,fmask=0022,dmask=0022,code\
page=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro 0 2" >"${fstab}"
    else
      echo "/dev/${BOOT} /boot ext4 defaults 0 2" >"${fstab}"
    fi
    echo "/dev/mapper/root / ${FS} defaults 0 1" >>"${fstab}"
    echo "/dev/mapper/tmp /tmp tmpfs defaults 0 0" >>"${fstab}"
    echo "tmp /dev/lvm/tmp /dev/urandom tmp,cipher=aes-xts-plain64,size=256" \
      >>/mnt/etc/crypttab
    if (( SWAP_SIZE > 0 )); then
      echo "/dev/mapper/swap none swap defaults 0 0" >>"${fstab}"
      echo "swap /dev/lvm/swap /dev/urandom \
swap,cipher=aes-xts-plain64,size=256" >>/mnt/etc/crypttab
    fi
    # shellcheck disable=SC1004
    sed -i 's/^HOOKS=.*/HOOKS="base udev autodetect keyboard keymap consolefont\
modconf block encrypt lvm2 filesystems fsck"/' /mnt/etc/mkinitcpio.conf
    arch-chroot /mnt mkinitcpio -P
    log "Configured system for encryption"
  else
    # shellcheck disable=SC1004
    sed -i 's/^HOOKS=.*/HOOKS="base udev autodetect keyboard keymap consolefont\
modconf block lvm2 filesystems fsck"/' /mnt/etc/mkinitcpio.conf
    arch-chroot /mnt mkinitcpio -P
    log "Configured system with default mkinitcpio hooks"
  fi

  # Locale config
  sed -i -e "s/#${LOCALE}/${LOCALE}/" /mnt/etc/locale.gen
  echo "LANG=${LOCALE}" >/mnt/etc/locale.conf
  arch-chroot /mnt locale-gen
  log "Set system locale: ${LOCALE}"

  # Keyboard config
  echo "KEYMAP=${KEYMAP}" >/mnt/etc/vconsole.conf
  echo -e "Section \"InputClass\"\nIdentifier \"system-keyboard\"\nMatchIs\
Keyboard \"on\"\nOption \"XkbLayout\" \"${KEYMAP}\"\nEndSection" \
    >/mnt/etc/X11/xorg.conf.d/00-keyboard.conf
  arch-chroot /mnt localectl set-x11-keymap "${KEYMAP}"
  log "Set system keymap: ${KEYMAP}"

  # Time zone and hardware clock config
  arch-chroot /mnt ln -sf /usr/share/zoneinfo/"${TIME_ZONE}" /etc/localtime
  arch-chroot /mnt hwclock --systohc # to generate /etc/adjtime
  log "Set system time zone: ${TIME_ZONE}"

  # Firewall, network, and bluetooth config
  arch-chroot /mnt ufw enable
  enable_service ufw.service
  enable_service NetworkManager.service
  enable_service dhcpcd.service
  if "${BLUETOOTH_AVAILABLE}"; then
    enable_service bluetooth.service
  fi

  # VM config
  case "${VM_TYPE}" in
    oracle) enable_service vboxservice.service ;;
    vmware)
      cat /mnt/proc/version >/mnt/etc/arch-release
      enable_service vmtoolsd.service
      enable_service vmware-vmblock-fuse.service
      local -i x
      for x in {0..6}; do mkdir -p /mnt/etc/init.d/rc"${x}".d; done
      ;;
  esac

  # Desktop config
  arch-chroot /mnt fc-cache -f # build font information cache files
  cp /usr/share/gdl/extra/gdl.png /mnt/usr/share/pixmaps
  cp /usr/share/gdl/extra/gdl.png /mnt/usr/share/icons
  cp -r /usr/share/gdl/extra/Breeze_Amber /mnt/usr/share/icons
  cp -rT /usr/share/gdl/extra/wallpapers /mnt/usr/share/backgrounds/xfce
  cp -rT /usr/share/gdl/extra/skel /mnt/etc/skel
  cp -rT /usr/share/gdl/extra/root /mnt/root
  cp /mnt/etc/skel/.bash_profile /mnt/root/
  cp /mnt/etc/skel/.vimrc /mnt/root/
  cp /mnt/etc/skel/.xinitrc /mnt/root/
  cp /usr/share/gdl/extra/gdl.png /mnt/root/.face
  log "Configured desktop environment"

  # Display manager (login manager) config
  cp -rT /usr/share/gdl/extra/lightdm /mnt/etc/lightdm
  enable_service lightdm.service

  # Pacman config
  if [[ -f /mnt/var/lib/pacman/db.lck ]]; then
    rm /mnt/var/lib/pacman/db.lck &>/dev/null
  fi
  sed -i 's/#Color/Color\nILoveCandy/' /mnt/etc/pacman.conf
  sed -i 's/#VerbosePkgLists/VerbosePkgLists/' /mnt/etc/pacman.conf
  sed -i 's/#ParallelDownloads/ParallelDownloads/' /etc/pacman.conf
  sed -zi 's/#\[multilib]\n#Include/[multilib]\nInclude/' /mnt/etc/pacman.conf
  log "Customized pacman.conf"

  # Hostname and root user config
  echo "${HOSTNAME}" >/mnt/etc/hostname
  echo -e "127.0.0.1 localhost\n::1 localhost\n127.0.1.1 \
${HOSTNAME}.localdomain ${HOSTNAME}" >>/mnt/etc/hosts
  log "Hostname set: ${HOSTNAME}"
  local pw
  pw="$(echo "${PASSWORD}" | openssl enc -aes-256-cbc -a -d -salt -pbkdf2 \
    -iter 1000 -pass pass:"${SSL_KEY}")"
  printf "%s\n%s" "${pw}" "${pw}" | arch-chroot /mnt passwd root
  unset pw
  log "Password set for user: root"

  # CPU frequency scaling
  enable_service cpupower.service

  # Periodic (weekly) TRIM for any attached drives that support 'discard'
  enable_service fstrim.timer

  # Decrease swappiness
  echo "vm.swappiness=10" >/mnt/etc/sysctl.d/99-swappiness.conf

  # Ensure proper MIDI support for GStreamer-based media players
  mkdir -p /mnt/usr/share/sounds/sf2
  arch-chroot /mnt sh -c "ln -s /usr/share/soundfonts/FluidR3_GM.sf2 \
    /usr/share/sounds/sf2/"

  log "System configuration complete"
}

enable_service() {
  if [[ -n "$1" ]] && arch-chroot /mnt systemctl enable "$1"; then
    log "Enabled systemd service '$1'"
  else
    log "ERROR: Failed to enable systemd service '$1'"
  fi
}

install_additional_software() {
  local pw package failed_packages try='y'

  # Create a special temporary user for installing and using yay (AUR helper)
  dragonsay "Setting up AUR support..." |& tee -a "${LOG_FILE}"
  log "Creating temporary user: 'yaybuilder'"
  pw="$(< /dev/urandom tr -dc "@#*%&_A-Z-a-z-0-9" | head -c16)"
  arch-chroot /mnt mkdir yaytemp
  arch-chroot /mnt chmod 777 yaytemp
  arch-chroot /mnt useradd -rNM -d /yaytemp -s /usr/bin/nologin yaybuilder
  arch-chroot /mnt sh -c "echo -e '${pw}\n${pw}\n' | passwd yaybuilder"
  log "Adding 'yaybuilder' to sudoers.d"
  arch-chroot /mnt sh -c "echo 'yaybuilder ALL=(ALL) NOPASSWD: ALL' |
    tee /etc/sudoers.d/yaybuilder"
  arch-chroot /mnt sh -c "echo 'root ALL=(yaybuilder) NOPASSWD: ALL' |
    tee -a /etc/sudoers.d/yaybuilder"

  # Install yay, update, then install additional packages using yay
  log "Installing 'yay' (AUR helper)..."
  arch-chroot /mnt sh -c "cd yaytemp &&
    sudo -u yaybuilder git clone https://aur.archlinux.org/yay-bin.git &&
    cd yay-bin && sudo -u yaybuilder makepkg -si --noconfirm"
  log "Updating system via 'yay'..."
  arch-chroot /mnt sudo -u yaybuilder yay -Syu --noconfirm |&
    tee -a "${LOG_FILE}"
  AUR_AND_OPTIONAL_PACKAGES="$(tr <<<"${AUR_AND_OPTIONAL_PACKAGES}" " " "\n" |
    sort | uniq | tr "\n" " ")"
  log "AUR and optional software package list: ${AUR_AND_OPTIONAL_PACKAGES}"
  dragonsay "Installing additional software..." |& tee -a "${LOG_FILE}"
  while [[ -n "${AUR_AND_OPTIONAL_PACKAGES}" ]] && grep -iq '^y' <<<"${try}"; do
    failed_packages=''
    for package in ${AUR_AND_OPTIONAL_PACKAGES}; do
      log "Installing ${package}..."
      if ! arch-chroot /mnt sudo -u yaybuilder yay -S "${package}" --needed \
          --noconfirm; then
        log "ERROR: Installation of ${package} failed"
        failed_packages+="${package} "
      fi
    done
    if [[ -n "${failed_packages}" ]]; then
      echo "${ERROR} $(wc -w <<<"${failed_packages}") package(s) failed to \
install: ${failed_packages}"
      while true; do
        read -rp "Try again? (y/n) " try
        if grep -Eiq '^n|^y' <<<"${try}"; then
          break
        fi
      done
    fi
    AUR_AND_OPTIONAL_PACKAGES="${failed_packages}"
  done
  if [[ -n "${failed_packages}" ]]; then
    log "$(wc -w <<<"${failed_packages}") failed package(s): ${failed_packages}"
  else
    log "All packages successfully installed"
  fi

  # Clean things up
  log "Cleaning up..."
  arch-chroot /mnt sudo -u yaybuilder yay -Yc --noconfirm &&
    log "Unneeded build dependencies removed"
  arch-chroot /mnt userdel -f yaybuilder && log "User 'yaybuilder' deleted"
  arch-chroot /mnt rm /etc/passwd- /etc/sudoers.d/yaybuilder
  arch-chroot /mnt rm -r yaytemp
  log "Cleanup complete"
}

add_user() {
  if [[ -z "${FULL_NAME}" ]]; then
    arch-chroot /mnt useradd -m -G audio,network,power,storage,optical -s \
      /bin/bash "${USERNAME}"
  else
    arch-chroot /mnt useradd -m -G audio,network,power,storage,optical -c \
      "${FULL_NAME}" -s /bin/bash "${USERNAME}"
  fi
  local pw
  pw="$(echo "${PASSWORD}" | openssl enc -aes-256-cbc -a -d -salt -pbkdf2 \
    -iter 1000 -pass pass:"${SSL_KEY}")"
  printf "%s\n%s" "${pw}" "${pw}" | arch-chroot /mnt passwd "${USERNAME}"
  unset pw
  sed -i '/%wheel ALL=(ALL) ALL/s/^#//' /mnt/etc/sudoers
  arch-chroot /mnt usermod -a -G wheel "${USERNAME}"

  # If Lutris was installed, provide a shortcut for installing Battle.net
  if grep -q 'lutris' <<<"${BASE_PACKAGES}"; then
    mkdir /mnt/home/"${USERNAME}"/Desktop
    echo -e "[Desktop Entry]\nVersion=1.0\nType=Link\nName=Install Battle.net
Comment=Install the Blizzard Battle.net app via Lutris\nIcon=user-bookmarks
URL=lutris:blizzard-battlenet-standard" \
      >/mnt/home/"${USERNAME}"/Desktop/blizzard.desktop
    arch-chroot /mnt chown -R "${USERNAME}:${USERNAME}" \
      /home/"${USERNAME}"/Desktop
  fi

  log "User added: ${USERNAME}"
}

# Custom dialog function
dialog() {
  if "${REDUCE_EXTRANEOUS_TEXT}"; then
    /usr/bin/dialog --stdout --colors --title " ${TITLE} " "$@"
  else
    BACKTITLE="${DEFAULT_BACKTITLE}"
    if [[ -n "${BATTERY}" ]]; then
      BACKTITLE+=" | Battery: $(cat "${BATTERY}"/capacity)%"
    fi
    /usr/bin/dialog --stdout --colors --backtitle "${BACKTITLE}" --title \
      " ${TITLE} " "$@"
  fi
}

# Displays a simple 'OK' message dialog
message() {
  dialog --ok-button "${OK}" --msgbox "\n$1" 0 0
}

# Displays a yes/no dialog
yesno() {
  local body="$1" yes_button="$2" no_button="$3"

  if (( $# == 4 )); then
    dialog --defaultno --yes-label "${yes_button}" --no-label "${no_button}" \
      --yesno "\n${body}" 0 0
  else
    dialog --yes-label "${yes_button}" --no-label "${no_button}" \
      --yesno "\n${body}" 0 0
  fi
  return $?
}

# Displays a gauge (loading bar) dialog
load_bar() {
  {
    local -i progress=1

    # shellcheck disable=SC2009
    while [[ -n $! ]] && ps | grep -q $!; do
      sleep 0.1
      echo "${progress}"
      if (( progress < 100 )); then
        (( ++progress ))
      fi
    done
    echo 100
    sleep 0.7
  } | dialog --gauge "\n$1" 9 79 0
}

# Custom cowsay function
dragonsay() {
  if "${REDUCE_EXTRANEOUS_TEXT}"; then
    echo -e "$1\n"
  else
    cowsay -f dragon "$1"
  fi
}

# Appends a given string or command output stream to the log file
log() {
  if [[ -n "$1" ]]; then # manual logging
    echo "[$(date '+%H:%M:%S')]: $1" >>"${LOG_FILE}"
  else # command output
    while read -r output; do
      echo "${output}" >>"${LOG_FILE}"
    done
  fi
}

main() {
  initialize
  set_language
  set_keymap
  TITLE="${ABOUT_GDL_TITLE}"
  dialog --ok-button "${OK}" --msgbox "\n${ABOUT_GDL_MSG}" 22 80
  update_mirrors
  set_locale
  set_time_zone
  prepare_drives
  prepare_base
  set_hostname
  set_user
  select_additional_software
  install_base
  configure_system
  install_additional_software
  add_user
  clear
  dragonsay "${INSTALL_COMPLETE_MSG}" |& tee -a "${LOG_FILE}"
  echo -e "${INSTALL_COMPLETE_HELP}"
  cp "${LOG_FILE}" /mnt/root
}

main
