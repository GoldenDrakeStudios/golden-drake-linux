#!/bin/bash
#
# Installer script for Golden Drake Linux (GDL): Arch for gaming and game dev!
#
# Copyright (C) 2020-2024 Golden Drake Studios: goldendrakestudios.com
# Forked originally from the Anarchy installer: anarchyinstaller.gitlab.io
#
# shellcheck disable=SC2086

# shellcheck source=gdl.conf
source /etc/gdl.conf || exit 1
# shellcheck source=lang/english.conf
source "${LANG_FILE}" || exit 1

################################################################################
# Initialize installer. If this is the script's first (automatic) run, create
# the log file (by posting its first log message), start the network manager,
# and customize pacman.conf, then return the user to the command line so they
# can run other commands before (or instead of) launching the install process.
# Otherwise (i.e., if the log file already exists), prepare for installation by
# evaluating the hardware environment, setting a 'force_quit' trap, etc.
#
# Globals: GDL_VERSION, LOG_FILE, REDUCE_EXTRANEOUS_TEXT, BATTERY, VM_TYPE,
#   GPU_CHIPSET, DEFAULT_GPU_DRIVER, BASE_PACKAGES
# Arguments: None
################################################################################
initialize() {
  if [[ ! -f "${LOG_FILE}" ]]; then
    log "Initializing GDL installer v${GDL_VERSION}"
    systemctl start NetworkManager.service
    sed -i 's/#Color/Color\nILoveCandy/' /etc/pacman.conf
    sed -i '/#ParallelDownloads/s/#//' /etc/pacman.conf
    sed -zi 's/#\[multilib]\n#Include/[multilib]\nInclude/' /etc/pacman.conf
    [[ -d /tmp/gdl ]] || mkdir /tmp/gdl
    return_to_shell_prompt
  elif (( $(wc -l "${LOG_FILE}" | awk '{print $1}') > 1 )); then
    echo >>"${LOG_FILE}" # add white space
    log "Relaunching installer..."
  fi
  trap force_quit SIGINT # call 'force_quit' when Ctrl+C is pressed
  set -o pipefail # ensure $? remembers failures from piped commands
  if (( $(tput lines) < 25 )) || grep -q 'accessibility=' /proc/cmdline; then
    REDUCE_EXTRANEOUS_TEXT='true'
  fi
  if [[ -n "${BATTERY}" ]]; then
    BASE_PACKAGES+='tlp '
    log "Battery detected: ${BATTERY} ($(cat "${BATTERY}/capacity")%)"
  fi
  if [[ "${VM_TYPE}" == 'none' ]]; then
    if lspci | grep 'VGA' | grep -q 'Intel'; then
      GPU_CHIPSET='Intel'
      DEFAULT_GPU_DRIVER='xf86-video-intel'
      BASE_PACKAGES+='thermald intel-gpu-tools '
    fi
    if lspci | grep 'VGA' | grep -Eq 'ATI|AMD'; then
      GPU_CHIPSET='AMD/ATI'
      DEFAULT_GPU_DRIVER='xf86-video-amdgpu'
      BASE_PACKAGES+='radeontop '
    fi
    if lspci | grep 'VGA' | grep -iq 'nvidia'; then
      GPU_CHIPSET='NVIDIA'
      DEFAULT_GPU_DRIVER='nvidia'
    fi
    log "Graphics chipset detected: ${GPU_CHIPSET}"
  else
    log "VM environment detected: ${VM_TYPE}"
  fi
}

################################################################################
# Return the user to the command line with a welcome message plus help text
# telling them how to (a) relaunch the installer, (b) read ArchWiki articles
# offline in the terminal, (c) reboot, or (d) shut down.
#
# Globals: SHELL_PROMPT_WELCOME, SHELL_PROMPT_HELP, ERRORS_LOGGED
# Arguments: None
################################################################################
return_to_shell_prompt() {
  dragonsay "${SHELL_PROMPT_WELCOME}" --check-errors
  echo -e "${SHELL_PROMPT_HELP}"
  exit "${ERRORS_LOGGED}"
}

################################################################################
# Handle a sudden exit caused by the user pressing Ctrl+C.
#
# Globals: TITLE, FORCE_QUIT_TITLE, FORCE_QUIT_MSG, ERRORS_LOGGED
# Arguments: None
################################################################################
force_quit() {
  log "User force quit the installer (errors logged: ${ERRORS_LOGGED})"
  TITLE="${FORCE_QUIT_TITLE}"
  message "${FORCE_QUIT_MSG}"
  return_to_shell_prompt
}

################################################################################
# Present the language menu (for the installer, not the soon-to-be-installed
# system: its language is determined by 'set_locale'). If the associated
# language file differs from the previously-sourced language file, source it to
# update all language-specific globals and edit gdl.conf to ensure the same
# language file is sourced again if the installer is closed and relaunched.
#
# Globals: TITLE, SET_LANG_TITLE, LANG_FILE, SET_LANG_MSG, ERRORS_LOGGED,
#   BOLD_RED, COLOR_RESET
# Arguments: None
################################################################################
set_installer_language() {
  TITLE="${SET_LANG_TITLE}"
  local language prev_lang_file="${LANG_FILE}"

  until language="$(dialog --no-cancel --menu "\n${SET_LANG_MSG}" 20 60 10 \
      'English' 'English' \
      'Bulgarian' 'Български' \
      'Dutch' 'Nederlands' \
      'French' 'Français' \
      'German' 'Deutsch' \
      'Greek' 'Ελληνικά' \
      'Hungarian' 'Magyar' \
      'Indonesian' 'bahasa Indonesia' \
      'Italian' 'Italiano' \
      'Latvian' 'Latviešu' \
      'Lithuanian' 'Lietuvių' \
      'Polish' 'Polski' \
      'Portuguese' 'Português' \
      'Portuguese-Brazil' 'Português do Brasil' \
      'Romanian' 'Română' \
      'Russian' 'Русский' \
      'Spanish' 'Español' \
      'Swedish' 'Svenska')"; do
    continue
  done
  LANG_FILE="/usr/share/gdl/lang/${language@L}.conf"
  if [[ "${LANG_FILE}" != "${prev_lang_file}" ]]; then
    if source "${LANG_FILE}"; then
      sed -i "s:^LANG_FILE=.*:LANG_FILE='${LANG_FILE}':" /etc/gdl.conf
    else
      log_error "Language file '${LANG_FILE}' not found"
      log "Exiting installer (errors logged: ${ERRORS_LOGGED})"
      echo -e "${BOLD_RED}ERROR:${COLOR_RESET} No file found for '${language}'"
      exit "${ERRORS_LOGGED}"
    fi
  fi
  log "Installer language set: ${language}"
}

################################################################################
# Present the keymap menu.
#
# Globals: TITLE, SET_KEYMAP_TITLE, KEYMAP, SET_KEYMAP_MSG, OTHER, OK, BACK
# Arguments: None
################################################################################
set_keymap() {
  TITLE="${SET_KEYMAP_TITLE}"
  local keymap_list
  keymap_list="$(find /usr/share/kbd/keymaps -type f \
    | sed -n -e 's!^.*/!!p' \
    | grep '.map.gz' \
    | sed 's/.map.gz//g' \
    | sed 's/$/ ->/g' \
    | sort)"

  while true; do
    if KEYMAP="$(dialog --no-cancel --ok-button "${OK}" --menu \
        "\n${SET_KEYMAP_MSG}" 18 60 10 \
        'us' 'United States' \
        'uk' 'United Kingdom' \
        'sv' 'Swedish' \
        'slovene' 'Slovenian' \
        'ru' 'Russian' \
        'ro' 'Romanian' \
        'pt-latin9' 'Portugal' \
        'it' 'Italian' \
        'hu' 'Hungarian' \
        'fr' 'French' \
        'es' 'Spanish' \
        'el' 'Greek' \
        'de' 'German' \
        "${OTHER}" '->')"; then
      if [[ "${KEYMAP}" != "${OTHER}" ]] \
          || KEYMAP="$(dialog --ok-button "${OK}" --cancel-button "${BACK}" \
            --menu "\n${SET_KEYMAP_MSG}" 19 60 10 ${keymap_list})"; then
        break
      fi
    fi
  done
  localectl set-keymap "${KEYMAP}"
  loadkeys "${KEYMAP}"
  log "Keymap set: ${KEYMAP}"
}

################################################################################
# Check for an internet connection. If not found, attempt to auto-connect to
# Wi-Fi (if an SSID is provided) or present options via 'nmtui'.
#
# Globals: WIFI_SSID, WIFI_PASSWORD
# Arguments: None
################################################################################
check_internet_connection() {
  until nc -zw 1 1.1.1.1 443; do
    log "Internet connection not yet established..."
    if ip address | grep -Eq 'wlp|wlo|wlan' \
        && [[ -n "${WIFI_SSID}" ]] \
        && nmcli dev wifi connect "${WIFI_SSID}" password \
          "${WIFI_PASSWORD}"; then
      log "* Using nmcli..."
    else
      log "* Using nmtui..."
      nmtui
    fi
  done
  log "Internet connection established"
}

################################################################################
# Present the locale menu.
#
# Globals: TITLE, SET_LOCALE_TITLE, LOCALE, SET_LOCALE_MSG, OTHER, OK, BACK
# Arguments: None
################################################################################
set_locale() {
  TITLE="${SET_LOCALE_TITLE}"
  local locale_list
  locale_list="$(grep -E "^#?[a-z].*UTF-8" /etc/locale.gen \
    | sed 's/#//' \
    | awk '{print $1" ->"}')"

  while true; do
    if LOCALE="$(dialog --no-cancel --ok-button "${OK}" --menu \
        "\n${SET_LOCALE_MSG}" 18 60 10 \
        'bg_BG.UTF-8' 'Bulgarian (Bulgaria)' \
        'de_DE.UTF-8' 'German (Germany)' \
        'el_GR.UTF-8' 'Greek (Greece)' \
        'en_AU.UTF-8' 'English (Australia)' \
        'en_CA.UTF-8' 'English (Canada)' \
        'en_GB.UTF-8' 'English (UK)' \
        'en_US.UTF-8' 'English (US)' \
        'es_ES.UTF-8' 'Spanish (Spain)' \
        'es_MX.UTF-8' 'Spanish (Mexico)' \
        'fr_FR.UTF-8' 'French (France)' \
        'hu_HU.UTF-8' 'Hungarian (Hungary)' \
        'id_ID.UTF-8' 'Indonesian (Indonesia)' \
        'it_IT.UTF-8' 'Italian (Italy)' \
        'ja_JP.UTF-8' 'Japanese (Japan)' \
        'ko_KR.UTF-8' 'Korean (Korea)' \
        'lt_LT.UTF-8' 'Lithuanian (Lithuania)' \
        'lv_LV.UTF-8' 'Latvian (Latvia)' \
        'nl_NL.UTF-8' 'Dutch (Netherlands)' \
        'pl_PL.UTF-8' 'Polish (Poland)' \
        'pt_BR.UTF-8' 'Portuguese (Brazil)' \
        'pt_PT.UTF-8' 'Portuguese (Portugal)' \
        'ro_RO.UTF-8' 'Romanian (Romania)' \
        'ru_RU.UTF-8' 'Russian (Russia)' \
        'sv_SE.UTF-8' 'Swedish (Sweden)' \
        'zh_CN.UTF-8' 'Chinese (China)' \
        'zh_HK.UTF-8' 'Chinese (Hong Kong)' \
        'zh_SG.UTF-8' 'Chinese (Singapore)' \
        'zh_TW.UTF-8' 'Chinese (Taiwan)' \
        "${OTHER}" '->')"; then
      if [[ "${LOCALE}" != "${OTHER}" ]] \
          || LOCALE="$(dialog --ok-button "${OK}" --cancel-button "${BACK}" \
            --menu "\n${SET_LOCALE_MSG}" 19 60 10 ${locale_list})"; then
        break
      fi
    fi
  done
  log "Locale set: ${LOCALE}"
}

################################################################################
# Present the time zone menu.
#
# Globals: TITLE, SET_TIME_ZONE_TITLE, TIME_ZONE, SET_TIME_ZONE_MSG, OK, BACK
# Arguments: None
################################################################################
set_time_zone() {
  TITLE="${SET_TIME_ZONE_TITLE}"
  local zonelist sublist subzone subsubzone
  zonelist="$(find /usr/share/zoneinfo -maxdepth 1 \
    | sed -n -e 's!^.*/!!p' \
    | grep -Ev 'posix|posixrules|right|zoneinfo|.*tab|W-SU|WET|MST7MDT|CST6CDT'\
    | sort \
    | sed 's/$/ ->/g')"

  while true; do
    TIME_ZONE="$(dialog --no-cancel --ok-button "${OK}" --menu \
      "\n${SET_TIME_ZONE_MSG}" 18 60 10 ${zonelist})"
    if find /usr/share/zoneinfo -maxdepth 1 -type d \
        | sed -n -e 's!^.*/!!p' \
        | grep -q "${TIME_ZONE}"; then
      sublist="$(find "/usr/share/zoneinfo/${TIME_ZONE}" -maxdepth 1 \
        | sed -n -e 's!^.*/!!p' \
        | sort \
        | sed 's/$/ ->/g' \
        | grep -v "${TIME_ZONE}")"
      if subzone="$(dialog --ok-button "${OK}" --cancel-button "${BACK}" \
          --menu "\n${SET_TIME_SUBZONE_MSG}" 18 60 10 ${sublist})"; then
        if find "/usr/share/zoneinfo/${TIME_ZONE}" -maxdepth 1 -type d \
            | sed -n -e 's!^.*/!!p' \
            | grep -q "${subzone}"; then
          sublist="$(find "/usr/share/zoneinfo/${TIME_ZONE}/${subzone}" \
              -maxdepth 1 \
            | sed -n -e 's!^.*/!!p' \
            | sort \
            | sed 's/$/ ->/g' \
            | grep -v "${subzone}")"
          if subsubzone="$(dialog --ok-button "${OK}" --cancel-button "${BACK}"\
              --menu "\n${SET_TIME_SUBZONE_MSG}" 15 60 7 ${sublist})"; then
            TIME_ZONE="${TIME_ZONE}/${subzone}/${subsubzone}"
            break
          fi
        else
          TIME_ZONE="${TIME_ZONE}/${subzone}"
          break
        fi
      fi
    else
      break
    fi
  done
  log "Time zone set: ${TIME_ZONE}"
}

################################################################################
# Present partitioning options and facilitate preparing a drive (or drives) for
# Linux installation.
#
# Globals: TITLE, PREPARE_DRIVES_TITLE, PART_METHOD_MSG, PART_METHOD_AUTO,
#   PART_METHOD_AUTO_ENCRYPT, PART_METHOD_MANUAL, SYSTEM_MOUNTED, DEVICE_LIST,
#   ROOT_DRIVE, ROOT_FS, HOME_DRIVE_MSG, HOME_DRIVE, HOME_FS, UEFI_MSG, UEFI,
#   GPT_MSG, GPT, BOOT_OR_ESP_MNT, BOOT_OR_ESP_SIZE, DEFAULT_ESP_SIZE_SMALL,
#   DEFAULT_ESP_SIZE_LARGE, DEFAULT_BOOT_SIZE, SET_SWAP_SIZE_MSG, SWAP_SIZE,
#   SWAP_INPUT_ERROR_MSG, PART_ERROR_MSG, OK, YES, NO, CANCEL
# Arguments: None
################################################################################
prepare_drives() {
  TITLE="${PREPARE_DRIVES_TITLE}"
  local partition_method partition_prefix root_gib home_gib

  log "Initial partition layout:"
  log_lsblk

  until "${SYSTEM_MOUNTED}"; do
    unmount_and_close_everything --swapoff

    # Present partitioning options
    if ! partition_method="$(dialog --no-cancel --ok-button "${OK}" --menu \
        "\n${PART_METHOD_MSG}" 16 70 3 \
        "${PART_METHOD_AUTO}" '->' \
        "${PART_METHOD_AUTO_ENCRYPT}" '->' \
        "${PART_METHOD_MANUAL}" '->')"; then
      continue

    # If an auto-partitioning option is selected, present drive menu(s)
    elif [[ "${partition_method}" != "${PART_METHOD_MANUAL}" ]]; then
      if [[ "${partition_method}" == "${PART_METHOD_AUTO}" ]]; then
        log "Auto-partitioning..."
      elif [[ "${partition_method}" == "${PART_METHOD_AUTO_ENCRYPT}" ]]; then
        log "Auto-partitioning with encrypted LVM..."
      fi

      # Root drive selection
      prepare_device_menu --auto-root
      ROOT_DRIVE="$(bash /tmp/gdl/part.sh)" || continue
      root_gib="$(get_device_size_gib "${ROOT_DRIVE}")"
      log "* Root drive selection: ${ROOT_DRIVE} (${root_gib} GiB)"
      ROOT_FS="$(get_filesystem)" || continue
      log "* Root filesystem selection: ${ROOT_FS}"

      # Home drive selection (optional)
      if (( $(wc -l <<<"${DEVICE_LIST}") > 1 )); then
        while yesno "${HOME_DRIVE_MSG}" "${YES}" "${NO}" --defaultno; do
          prepare_device_menu --auto-home
          HOME_DRIVE="$(bash /tmp/gdl/part.sh)" || continue
          home_gib="$(get_device_size_gib "${HOME_DRIVE}")"
          log "* Home drive selection: ${HOME_DRIVE} (${home_gib} GiB)"
          HOME_FS="$(get_filesystem)" || continue
          log "* Home filesystem selection: ${HOME_FS}"
          break
        done
      fi

      # Check drive properties and set up boot
      if grep -Eq 'nvme|mmc|md' <<<"${ROOT_DRIVE}"; then
        partition_prefix='p'
      else
        partition_prefix=''
      fi
      if efivar -l &>/dev/null && yesno "${UEFI_MSG}" "${YES}" "${NO}"; then
        GPT='true'
        UEFI='true'
        BOOT_OR_ESP_MNT='/efi'
        if (( $(cat "/sys/class/block/${ROOT_DRIVE}/queue/logical_block_size")
            <= 512 )); then
          BOOT_OR_ESP_SIZE="${DEFAULT_ESP_SIZE_SMALL}"
        else
          BOOT_OR_ESP_SIZE="${DEFAULT_ESP_SIZE_LARGE}"
        fi
        log "* UEFI/GPT setup activated (${BOOT_OR_ESP_SIZE} MiB ESP)"
      else
        BOOT_OR_ESP_MNT='/boot'
        BOOT_OR_ESP_SIZE="${DEFAULT_BOOT_SIZE}"
        if yesno "${GPT_MSG}" "${YES}" "${NO}" --defaultno; then
          GPT='true'
          log "* BIOS/GPT setup activated (${BOOT_OR_ESP_SIZE} MiB boot)"
        else
          log "* BIOS/MBR setup activated (${BOOT_OR_ESP_SIZE} MiB boot)"
        fi
      fi

      # Set swap size
      SWAP_SIZE=''
      if yesno "${CREATE_SWAP_MSG}" "${YES}" "${NO}" --defaultno; then
        while true; do
          SWAP_SIZE="$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
              --inputbox "\n${SET_SWAP_SIZE_MSG}" 11 55 '1G' \
            | tr 'mg' 'MG' \
            | tr -s 'MG' \
            | tr -d 'a-zA-FH-LN-Z[:space:]')" || break
          if grep -q 'M$' <<<"${SWAP_SIZE}"; then
            SWAP_SIZE="$(sed 's/M//;s/\..*//' <<<"${SWAP_SIZE}")"
          elif grep -q 'G$' <<<"${SWAP_SIZE}"; then
            SWAP_SIZE="$(echo "${SWAP_SIZE/G} * 1024" | bc | sed 's/\..*//')"
          else
            log_error "Invalid swap size input: ${SWAP_SIZE}"
            message "${SWAP_INPUT_ERROR_MSG}"
            continue
          fi
          break
        done
      fi
      [[ -z "${SWAP_SIZE}" ]] && SWAP_SIZE='0'
      log "* Swap size: ${SWAP_SIZE} MiB"

      # Format selected drive(s) or go back to main partitioning menu
      wipe_drive "${ROOT_DRIVE}" "${root_gib}" "${ROOT_FS}" || continue
      if [[ -n "${HOME_DRIVE}" ]]; then
        wipe_drive "${HOME_DRIVE}" "${home_gib}" "${HOME_FS}" || continue
      fi
    fi

    # Go to appropriate sub-function
    case "${partition_method}" in
      "${PART_METHOD_AUTO}")
        if ! auto_partition; then
          log_error "Auto-partitioning failed"
          message "${PART_ERROR_MSG}"
        fi
        ;;
      "${PART_METHOD_AUTO_ENCRYPT}")
        if ! auto_partition_with_encryption; then
          log_error "Auto-partitioning with encrypted LVM failed"
          message "${PART_ERROR_MSG}"
        fi
        ;;
      "${PART_METHOD_MANUAL}")
        log "Manually partitioning..."
        manually_partition
        ;;
    esac
  done
  log "Final partition layout:"
  log_lsblk
}

################################################################################
# Automatically partition the drive(s) selected in 'prepare_drives' and mount
# the newly-created partitions.
#
# Globals: TITLE, AUTO_PART_TITLE, ROOT_PART, ROOT_FS, HOME_DRIVE, HOME_FS,
#   BOOT_OR_ESP, BOOT_OR_ESP_MNT, UEFI, EFI_LOAD_MSG, BOOT_LOAD_MSG,
#   MKFS_LOAD_MSG, SYSTEM_MOUNTED
# Arguments: None
# Returns: Number of errors detected.
################################################################################
auto_partition() {
  TITLE="${AUTO_PART_TITLE}"

  # Create and format partitions
  partition_root_drive || return 1
  zap_and_wipe "${BOOT_OR_ESP}" || return 1
  if "${UEFI}"; then
    (
      mkfs.vfat -F32 "/dev/${BOOT_OR_ESP}" \
        && log "  - ESP filesystem created: vfat (FAT32)"
    ) &>/dev/null &
    load_bar "${EFI_LOAD_MSG}\n\n \Z1> \Z2mkfs.vfat -F32 /dev/${BOOT_OR_ESP}\Zn"
  else # BIOS
    (
      mkfs.ext4 "/dev/${BOOT_OR_ESP}" \
        && log "  - Boot filesystem created: ext4"
    ) &>/dev/null &
    load_bar "${BOOT_LOAD_MSG}\n\n \Z1> \Z2mkfs.ext4 /dev/${BOOT_OR_ESP}\Zn"
  fi
  zap_and_wipe "${ROOT_PART}" || return 1
  (
    mkfs."${ROOT_FS}" "/dev/${ROOT_PART}" \
      && log "  - Root filesystem created: ${ROOT_FS}"
  ) &>/dev/null &
  load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${ROOT_FS} \
/dev/${ROOT_PART}\Zn"
  if [[ -n "${HOME_DRIVE}" ]]; then
    (
      mkfs."${HOME_FS}" "/dev/${HOME_DRIVE}" \
        && log "  - Home filesystem created: ${HOME_FS}"
    ) &>/dev/null &
    load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${HOME_FS} \
/dev/${HOME_DRIVE}\Zn"
  fi

  # Mount partitions
  if [[ "${ROOT_FS}" == 'btrfs' ]]; then
    create_and_mount_btrfs_subvolume @ "/dev/${ROOT_PART}" || return 1
    if [[ -z "${HOME_DRIVE}" ]]; then
      create_and_mount_btrfs_subvolume @home "/dev/${ROOT_PART}" || return 1
    fi
    create_and_mount_btrfs_subvolume @var@log "/dev/${ROOT_PART}" || return 1
    create_and_mount_btrfs_subvolume @var@cache "/dev/${ROOT_PART}" || return 1
  elif mount "/dev/${ROOT_PART}" /mnt &>/dev/null; then
    log "  - Mounted /dev/${ROOT_PART} at /mnt"
  else
    log_error "Mounting /dev/${ROOT_PART} at /mnt failed"
    return 1
  fi
  if [[ -n "${HOME_DRIVE}" ]]; then
    if [[ "${HOME_FS}" == 'btrfs' ]]; then
      create_and_mount_btrfs_subvolume @home "/dev/${HOME_DRIVE}" || return 1
    elif mount -m "/dev/${HOME_DRIVE}" /mnt/home &>/dev/null; then
      log "  - Mounted /dev/${HOME_DRIVE} at /mnt/home"
    else
      log_error "Mounting /dev/${HOME_DRIVE} at /mnt/home failed"
      return 1
    fi
  fi
  if mount -m "/dev/${BOOT_OR_ESP}" "/mnt${BOOT_OR_ESP_MNT}" &>/dev/null; then
    log "  - Mounted /dev/${BOOT_OR_ESP} at /mnt${BOOT_OR_ESP_MNT}"
    SYSTEM_MOUNTED='true'
  else
    log_error "Mounting /dev/${BOOT_OR_ESP} at /mnt${BOOT_OR_ESP_MNT} failed"
    return 1
  fi
  log "Auto-partitioning complete"
}

################################################################################
# Automatically partition and encrypt the drive(s) selected in 'prepare_drives',
# applying "LVM on LUKS" to the root drive (including a logical swap space if a
# non-zero swap size is set), and mount the newly-created partitions.
#
# Globals: TITLE, AUTO_PART_TITLE, ROOT_PART, ROOT_FS, HOME_DRIVE, HOME_FS,
#   SWAP_SIZE, BOOT_OR_ESP, BOOT_OR_ESP_MNT, UEFI, SYSTEM_AUTO_ENCRYPTED,
#   SYSTEM_MOUNTED, BASE_PACKAGES, ENCRYPTION_CONFIRM, ENCRYPTION_PASSWORD_MSG,
#   ENCRYPTION_PASSWORD_CONFIRM, PASSWORD_EMPTY_MSG, PASSWORD_MISMATCH_MSG,
#   ENCRYPTION_LOAD_MSG, PVCREATE_LOAD_MSG, LVCREATE_LOAD_MSG, SWAP_LOAD_MSG,
#   EFI_LOAD_MSG, BOOT_LOAD_MSG, MKFS_LOAD_MSG, YES, NO
# Arguments: None
# Returns: Number of errors detected.
################################################################################
auto_partition_with_encryption() {
  TITLE="${AUTO_PART_TITLE}"
  local input input_check

  # Set encryption password
  if yesno "$(eval echo \"${ENCRYPTION_CONFIRM}\")" "${YES}" "${NO}" \
      --defaultno; then
    while true; do
      if ! input="$(dialog --no-cancel --clear --insecure --passwordbox \
            "\n$(eval echo \"${ENCRYPTION_PASSWORD_MSG}\")" 12 55)" \
          || ! input_check="$(dialog --no-cancel --clear --insecure \
            --passwordbox "\n$(eval echo \"${ENCRYPTION_PASSWORD_CONFIRM}\")" \
            12 55)" \
          || [[ -z "${input}" ]]; then
        message "${PASSWORD_EMPTY_MSG}"
      elif [[ "${input}" != "${input_check}" ]]; then
        message "${PASSWORD_MISMATCH_MSG}"
      else
        break
      fi
    done
    log "* Encryption password set"
  else
    return 0 # back to 'prepare_drives'
  fi

  # Create and encrypt partitions
  partition_root_drive --no-swap || return 1
  zap_and_wipe "${ROOT_PART}" || return 1
  (
    printf "%s" "${input}" | cryptsetup luksFormat "/dev/${ROOT_PART}" -
    printf "%s" "${input}" | cryptsetup open "/dev/${ROOT_PART}" cryptroot -
    log "  - Root partition encrypted"
  ) &>/dev/null &
  load_bar "${ENCRYPTION_LOAD_MSG}\n\n \Z1> \Z2cryptsetup luksFormat \
/dev/${ROOT_PART}\Zn"
  if [[ -n "${HOME_DRIVE}" ]]; then
    (
      printf "%s" "${input}" | cryptsetup luksFormat "/dev/${HOME_DRIVE}" -
      printf "%s" "${input}" | cryptsetup open "/dev/${HOME_DRIVE}" crypthome -
      echo -n "${input}" >/tmp/gdl/crypthome.key
      chmod 400 /tmp/gdl/crypthome.key
      log "  - Home partition encrypted"
    ) &>/dev/null &
    load_bar "${ENCRYPTION_LOAD_MSG}\n\n \Z1> \Z2cryptsetup luksFormat \
/dev/${HOME_DRIVE}\Zn"
  fi
  unset input input_check

  (
    pvcreate /dev/mapper/cryptroot \
      && log "  - Physical volume created on /dev/mapper/cryptroot"
    vgcreate vg /dev/mapper/cryptroot \
      && log "  - Logical volume group created: vg"
  ) &>/dev/null &
  load_bar "${PVCREATE_LOAD_MSG}\n\n \Z1> \Z2pvcreate /dev/mapper/cryptroot\Zn"

  if (( SWAP_SIZE > 0 )); then
    (
      lvcreate -L "${SWAP_SIZE}" vg -n lvswap \
        && mkswap /dev/vg/lvswap \
        && log "  - Logical swap space created: lvswap"
      swapon /dev/vg/lvswap
    ) &>/dev/null &
    load_bar \
      "${SWAP_LOAD_MSG}\n\n \Z1> \Z2lvcreate -L ${SWAP_SIZE} vg -n lvswap\Zn"
  fi
  (
    lvcreate -l 100%FREE vg -n lvroot \
      && log "  - Logical root volume created: lvroot"
    [[ "${ROOT_FS}" == 'ext4' ]] \
      && lvreduce -L -256M vg/lvroot \
      && log "  - 256 MiB removed from lvroot to allow use of e2scrub"
  ) &>/dev/null &
  load_bar \
    "${LVCREATE_LOAD_MSG}\n\n \Z1> \Z2lvcreate -l 100%FREE vg -n lvroot\Zn"

  # Apply filesystems
  if "${UEFI}"; then
    (
      mkfs.vfat -F32 "/dev/${BOOT_OR_ESP}" \
        && log "  - ESP filesystem created: vfat (FAT32)"
    ) &>/dev/null &
    load_bar "${EFI_LOAD_MSG}\n\n \Z1> \Z2mkfs.vfat -F32 /dev/${BOOT_OR_ESP}\Zn"
  else # BIOS
    (
      mkfs.ext4 "/dev/${BOOT_OR_ESP}" \
        && log "  - Boot filesystem created: ext4"
    ) &>/dev/null &
    load_bar "${BOOT_LOAD_MSG}\n\n \Z1> \Z2mkfs.ext4 /dev/${BOOT_OR_ESP}\Zn"
  fi
  (
    mkfs."${ROOT_FS}" /dev/vg/lvroot \
      && log "  - Root filesystem created: ${ROOT_FS}"
  ) &>/dev/null &
  load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${ROOT_FS} \
/dev/vg/lvroot\Zn"
  if [[ -n "${HOME_DRIVE}" ]]; then
    (
      mkfs."${HOME_FS}" /dev/mapper/crypthome \
        && log "  - Home filesystem created: ${HOME_FS}"
    ) &>/dev/null &
    load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${HOME_FS} \
/dev/mapper/crypthome\Zn"
  fi

  # Mount partitions/volumes
  if [[ "${ROOT_FS}" == 'btrfs' ]]; then
    create_and_mount_btrfs_subvolume @ /dev/vg/lvroot || return 1
    if [[ -z "${HOME_DRIVE}" ]]; then
      create_and_mount_btrfs_subvolume @home /dev/vg/lvroot || return 1
    fi
    create_and_mount_btrfs_subvolume @var@log /dev/vg/lvroot || return 1
    create_and_mount_btrfs_subvolume @var@cache /dev/vg/lvroot || return 1
  elif mount /dev/vg/lvroot /mnt &>/dev/null; then
    log "  - Mounted /dev/vg/lvroot at /mnt"
  else
    log_error "Mounting /dev/vg/lvroot at /mnt failed"
    return 1
  fi
  if [[ -n "${HOME_DRIVE}" ]]; then
    if [[ "${HOME_FS}" == 'btrfs' ]]; then
      create_and_mount_btrfs_subvolume @home /dev/mapper/crypthome || return 1
    elif mount -m /dev/mapper/crypthome /mnt/home &>/dev/null; then
      log "  - Mounted /dev/mapper/crypthome at /mnt/home"
    else
      log_error "Mounting /dev/mapper/crypthome at /mnt/home failed"
      return 1
    fi
    mkdir -p /mnt/etc/cryptsetup-keys.d
    mv /tmp/gdl/crypthome.key /mnt/etc/cryptsetup-keys.d
  fi
  if mount -m "/dev/${BOOT_OR_ESP}" "/mnt${BOOT_OR_ESP_MNT}" &>/dev/null; then
    log "  - Mounted /dev/${BOOT_OR_ESP} at /mnt${BOOT_OR_ESP_MNT}"
    SYSTEM_MOUNTED='true'
    SYSTEM_AUTO_ENCRYPTED='true'
  else
    log_error "Mounting /dev/${BOOT_OR_ESP} at /mnt${BOOT_OR_ESP_MNT} failed"
    return 1
  fi
  BASE_PACKAGES+='lvm2 '
  log "Auto-partitioning with encrypted LVM complete"
}

################################################################################
# Present options for manual partitioning of available drives and handle
# formatting and mounting of newly-created partitions.
#
# Globals: TITLE, MANUAL_PART_TITLE, EDIT_PART_TITLE, DEVICE_LIST, ROOT_DRIVE,
#   ROOT_PART, ROOT_FS, GPT, UEFI, BOOT_OR_ESP_MNT, SYSTEM_MOUNTED,
#   ALREADY_MOUNTED_MSG, SELECT_MNT_MSG, CUSTOM_MNT_MSG, PART_FORMAT_MSG,
#   EFI_VFAT_MSG, FS_VFAT_MSG, WRITE_CONFIRM, UNMOUNT_DRIVE_CONFIRM,
#   EDIT_DRIVE_CONFIRM, ROOT_MNT_CONFIRM, ROOT_FORMAT_CONFIRM,
#   UNMOUNT_ROOT_CONFIRM, UNMOUNT_PART_CONFIRM, SWAPOFF_CONFIRM, MNT_CONFIRM,
#   PART_FORMAT_CONFIRM, WAIT_LOAD_MSG, MKFS_LOAD_MSG, ROOT_UNMOUNTED_ERROR_MSG,
#   GPT_BIOS_ERROR_MSG, ROOT_MOUNT_ERROR_MSG, CUSTOM_MNT_CHAR_ERROR_MSG,
#   CUSTOM_MNT_ROOT_ERROR_MSG, MOUNT_ERROR_MSG, PARTITION, SIZE, MOUNT_POINT,
#   CUSTOM, EDIT, BACK, WRITE_CHANGES, OK, CANCEL, YES, NO, DONE
# Arguments: None
# Returns: Number of errors detected.
################################################################################
manually_partition() {
  local part part_size part_type part_fs part_mount part_final \
    empty_value='----' lvm_pv selected_fs

  while true; do
    # Prepare and present manual partitioning menu
    TITLE="${MANUAL_PART_TITLE}"
    prepare_device_menu --manual
    if ! part="$(bash /tmp/gdl/part.sh | sed 's/^\s\+//g;s/\s\+$//g')" \
        || [[ -z "${part}" ]]; then
      SYSTEM_MOUNTED='false'
      return 0 # back to 'prepare_drives'
    fi
    log "* Menu selection: '${part}'"

    # If user selected 'done', attempt to finish the partitioning process
    if [[ "${part}" == "${DONE}" ]]; then
      if ! "${SYSTEM_MOUNTED}"; then
        log_error "Root partition not found"
        message "${ROOT_UNMOUNTED_ERROR_MSG}"
        continue
      elif "${GPT}" && ! "${UEFI}" && ! fdisk -l | grep -q 'BIOS boot'; then
        log_error "BIOS boot partition not found"
        message "${GPT_BIOS_ERROR_MSG}"
        continue
      fi
      part_final="$( (df -h \
          | grep '/mnt' \
          | awk '{print $1,$2,$6 "\\n"}' \
          | sed 's/mnt\/\?//'; swapon \
          | awk 'NR==2 {print $1,$3,"SWAP"}') \
        | column -t)"
      yesno "${WRITE_CONFIRM}\n\n${PARTITION}  ${SIZE}  ${MOUNT_POINT}\n\n\
${part_final}" "${OK}" "${CANCEL}" --defaultno || continue

      # Add home and var subvolumes for Btrfs root (if mount points are free)
      if mount | grep -q ' /mnt type btrfs'; then
        mount | grep -q ' /mnt/home ' \
          || create_and_mount_btrfs_subvolume @home "/dev/${ROOT_PART}"
        if ! mount | grep -q ' /mnt/var '; then
          mount | grep -q ' /mnt/var/log ' \
            || create_and_mount_btrfs_subvolume @var@log "/dev/${ROOT_PART}"
          mount | grep -q ' /mnt/var/cache ' \
            || create_and_mount_btrfs_subvolume @var@cache "/dev/${ROOT_PART}"
        fi
      fi

      log "Manual partitioning complete"
      return 0 # all done: return to 'prepare_drives'
    fi

    # If not 'done', prepare and present a disk/partition editing menu
    part_size="$(grep -w "${part}" <<<"${DEVICE_LIST}" | awk '{print $2}')"
    part_type="$(grep -w "${part}" <<<"${DEVICE_LIST}" | awk '{print $3}')"
    part_fs="$(grep -w "${part}" <<<"${DEVICE_LIST}" | awk '{print $4}')"
    part_mount="$(df \
      | grep -w "${part}" \
      | awk '{print $6}' \
      | sed 's/mnt\/\?//')"
    [[ "${part_type}" == 'lvm' ]] && part="${part/-//}"
    log "  - Device info: ${part_type} ${part_fs} ${part_size} ${part_mount}"
    [[ "${part_fs}" == 'linux_raid_member' ]] && continue # do nothing

    # If user selected an entire drive, facilitate partitioning
    if [[ "${part_type}" == 'disk' ]] \
        || (grep -Eq 'raid[0-9]+' <<<"${part_type}" \
            && [[ -z "${part_fs}" ]]); then
      if mount | grep -q "${part}.*on /mnt"; then
        if yesno "$(eval echo \"${UNMOUNT_DRIVE_CONFIRM}\")" "${EDIT}" \
            "${CANCEL}" --defaultno; then
          unmount_and_close_everything --swapoff
          modify_partition_table "/dev/${part}"
        fi
      elif yesno "$(eval echo \"${EDIT_DRIVE_CONFIRM}\")" "${EDIT}" \
          "${CANCEL}"; then
        modify_partition_table "/dev/${part}"
      fi

    # If user selected a partition or md device, facilitate mounting/formatting
    else
      TITLE="${EDIT_PART_TITLE}"
      # The root '/' mount point must be established before others
      if [[ -z "${ROOT_PART}" ]]; then
        # shellcheck disable=SC2015
        yesno "$(eval echo \"${ROOT_MNT_CONFIRM}\")" "${YES}" "${NO}" \
            --defaultno && ROOT_FS="$(get_filesystem)" \
          && yesno "$(eval echo \"${ROOT_FORMAT_CONFIRM}\")" \
            "${WRITE_CHANGES}" "${CANCEL}" --defaultno \
          || continue
        zap_and_wipe "${part}" || return 1
        (
          mkfs."${ROOT_FS}" "/dev/${part}" \
            && log "  - Root filesystem created for /dev/${part}: ${ROOT_FS}"
        ) &>/dev/null &
        load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \
\Z2mkfs.${ROOT_FS} /dev/${part}\Zn"
        if [[ "${ROOT_FS}" == 'btrfs' ]]; then
          if ! create_and_mount_btrfs_subvolume @ "/dev/${part}"; then
            message "${ROOT_MOUNT_ERROR_MSG}"
            return 1 # back to 'prepare_drives'
          fi
        elif mount "/dev/${part}" /mnt &>/dev/null; then
          log "  - Mounted /dev/${part} at /mnt"
        else
          log_error "Mounting /dev/${part} at /mnt failed"
          message "${ROOT_MOUNT_ERROR_MSG}"
          return 1 # back to 'prepare_drives'
        fi
        SYSTEM_MOUNTED='true'
        ROOT_PART="${part}"
        if [[ "${part_type}" == "lvm" ]]; then
          lvm_pv="$(lvdisplay -m \
            | grep -A 20 "/dev/${part}" \
            | grep 'Physical volume' \
            | sed 's/^\s\+//g;s/\s\+/ /g' \
            | cut -d ' ' -f 3)"
          ROOT_DRIVE="$(lsblk -dnro PKNAME "${lvm_pv}")"
        else
          ROOT_DRIVE="$(lsblk -dnro PKNAME "/dev/${part}")"
        fi
        log "  - Root drive: ${ROOT_DRIVE}"
        if parted "/dev/${ROOT_DRIVE}" print | grep -q 'Table: gpt'; then
          GPT='true'
        else
          GPT='false'
        fi
        log "  - GPT: ${GPT}"
      # If the partition's already mounted, provide option to unmount
      elif [[ -n "${part_mount}" ]]; then
        if yesno "$(eval echo \"${ALREADY_MOUNTED_MSG}\")" "${EDIT}" "${BACK}" \
            --defaultno; then
          if [[ "${part}" == "${ROOT_PART}" ]]; then
            if yesno "$(eval echo \"${UNMOUNT_ROOT_CONFIRM}\")" "${YES}" \
                "${NO}" --defaultno; then
              unmount_and_close_everything
            fi
          elif yesno "$(eval echo \"${UNMOUNT_PART_CONFIRM}\")" "${YES}" \
              "${NO}" --defaultno; then
            if "${UEFI}" \
                && [[ "${part_mount}" =~ efi|boot ]] \
                && mount | grep -q " /mnt${part_mount} type vfat "; then
              UEFI='false'
              BOOT_OR_ESP_MNT=''
              log "  - Unmounting ESP..."
            fi
            (
              umount "/mnt${part_mount}" \
                && log "  - Unmounted /dev/${part} from /mnt${part_mount}"
              rm -r "/mnt${part_mount:?}"
            ) &>/dev/null &
            load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2umount /mnt${part_mount}\Zn"
          fi
        fi
      # If it's already in use as swap, provide option to 'swapoff' and wipe
      elif lsblk | grep -q "${part} .*\[SWAP\]$"; then
        if yesno "$(eval echo \"${SWAPOFF_CONFIRM}\")" "${YES}" "${NO}" \
            --defaultno; then
          (
            swapoff "/dev/${part}"
            wipefs -a "/dev/${part}" \
              && log "  - Swap partition /dev/${part} deactivated and wiped"
            sleep 0.6
          ) &>/dev/null &
          load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2swapoff /dev/${part}\Zn"
        fi
      # If it's a swap partition not in use, reformat and 'swapon'
      elif (( $(fdisk -l \
            | grep -w "${part}" \
            | sed 's/\*//' \
            | awk '{print $6}') == 82 )) &>/dev/null \
          || (fdisk -l /dev/"$(lsblk -dnro PKNAME "/dev/${part}")" \
              | grep -q 'gpt' \
            && [[ "$(fdisk -l -o Device,Size,Type-UUID \
              | grep -w "${part}" \
              | awk '{print $3}')" == "0657FD6D-A4AB-43C4-84E5-0933C84B4F4F" ]]\
            ) &>/dev/null; then
        format_swap_partition "${part}"
      # Otherwise, present mount point menu (inc. option to create swap)
      elif yesno "$(eval echo \"${MNT_CONFIRM}\")" "${EDIT}" "${BACK}"; then
        mnt="$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
          --menu "\n$(eval echo \"${SELECT_MNT_MSG}\")" 15 60 6 \
          '/home' '->' \
          '/boot' '->' \
          '/efi' '->' \
          '/opt' '->' \
          '/usr' '->' \
          '/var' '->' \
          '/tmp' '->' \
          '[SWAP]' '->' \
          "${CUSTOM}" '->')" || continue
        if [[ "${mnt}" == '[SWAP]' ]]; then
          format_swap_partition "${part}"
          continue
        elif [[ "${mnt}" == "${CUSTOM}" ]]; then
          while true; do
            mnt="$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
                --inputbox "\n${CUSTOM_MNT_MSG}" 10 50 '/' \
              | tr -d '[:space:]' \
              | tr -s '/')" || continue 2
            if grep -q "[\[\$\!\'\"\`\\|%&#@()+=<>~;:?.,^{}]\|]" \
                <<<"${mnt}"; then
              message "${CUSTOM_MNT_CHAR_ERROR_MSG}"
            elif [[ "${mnt}" == '/' ]]; then
              message "${CUSTOM_MNT_ROOT_ERROR_MSG}"
            elif [[ -n "${mnt}" ]]; then
              [[ "${mnt}" =~ ^/ ]] || mnt="/${mnt}"
              break
            fi
          done
        fi
        log "  - Mount point selection: ${mnt}"
        # Provide formatting options
        if yesno "${PART_FORMAT_MSG}" "${YES}" "${NO}" --defaultno; then
          if [[ "${mnt}" == '/efi' || "${mnt}" == '/boot/efi' ]] \
              || fdisk -l | grep "${part}" | grep -q 'EFI'; then
            selected_fs="$(dialog --menu "\n${EFI_VFAT_MSG}" 12 65 1 'vfat' \
              "${FS_VFAT_MSG}")" || continue
          else
            selected_fs="$(get_filesystem)" || continue
          fi
          yesno "$(eval echo \"${PART_FORMAT_CONFIRM}\")" "${WRITE_CHANGES}" \
            "${CANCEL}" --defaultno || continue
          zap_and_wipe "${part}" || return 1
          (
            case "${selected_fs}" in
              vfat) mkfs.vfat -F32 "/dev/${part}" ;;
              *) mkfs."${selected_fs}" "/dev/${part}" ;;
            esac
            log "  - Filesystem created for ${mnt}: ${selected_fs}"
          ) &>/dev/null &
          load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \
\Z2mkfs.${selected_fs} /dev/${part}\Zn"
        fi
        # Attempt to mount the partition at the given mount point
        if blkid | grep "${part}" | grep -q 'TYPE="btrfs"'; then
          create_and_mount_btrfs_subvolume "${mnt////@}" "/dev/${part}" \
            || message "${MOUNT_ERROR_MSG}"
        elif mount -m "/dev/${part}" "/mnt${mnt}" &>/dev/null; then
          if [[ "${mnt}" =~ efi|boot ]] \
              && efivar -l &>/dev/null \
              && mount | grep -q " /mnt${mnt} type vfat "; then
            UEFI='true'
            BOOT_OR_ESP_MNT="${mnt}"
            log "  - Mounting ESP..."
          fi
          log "  - Mounted /dev/${part} at /mnt${mnt}"
        else
          log_error "Mounting /dev/${part} at /mnt${mnt} failed"
          message "${MOUNT_ERROR_MSG}"
        fi
      fi
    fi
  done
}

################################################################################
# Prepare a device list string, plus temp files 'part.list' and 'part.sh', for
# use in a given type of partitioning menu. (Assumes TITLE is already set.)
#
# Globals: DEVICE_LIST, ROOT_DRIVE, SELECT_DRIVE_MSG, SELECT_HOME_DRIVE_MSG,
#   MANUAL_PART_MSG, TITLE, BACKTITLE, EDIT, OK, CANCEL, DONE, WRITE_CHANGES,
#   REDUCE_EXTRANEOUS_TEXT
# Arguments: Type of menu (--auto-root, --auto-home, or --manual).
# Returns: Number of errors detected.
################################################################################
prepare_device_menu() {
  local -i counter device_count
  local device dev_size dev_type dev_fs dev_mnt dev_used dev_parent \
    empty_value='----' menu_header='               Device    Size    Type' \
    menu_msg grep_str

  # Check input
  case "$1" in
    --auto-root) menu_msg="${SELECT_DRIVE_MSG}" ;;
    --auto-home) menu_msg="${SELECT_HOME_DRIVE_MSG}" ;;
    --manual)
      menu_msg="${MANUAL_PART_MSG}"
      menu_header='       Device    Size    Used    FS    Mount    Type'
      ;;
    *)
      log_error "Invalid argument passed to 'prepare_device_menu': $1"
      return 1
      ;;
  esac

  # Start crafting 'dialog' command
  if "${REDUCE_EXTRANEOUS_TEXT}"; then
    echo -n "dialog --stdout --colors --title \" ${TITLE} \" --ok-button " \
      >/tmp/gdl/part.sh
  else
    echo -n "dialog --stdout --colors --backtitle \"${BACKTITLE}\" --title \" \
${TITLE} \" --ok-button " >/tmp/gdl/part.sh
  fi

  # Finish crafting 'dialog' command for an auto-partitioning drive menu
  if [[ "$1" =~ ^--auto ]]; then
    # shellcheck disable=SC2028
    echo "\"${OK}\" --cancel-button \"${CANCEL}\" --menu \"\n${menu_msg}\n\n\
${menu_header}\" 16 60 5 \\" >>/tmp/gdl/part.sh
    DEVICE_LIST="$(lsblk -nio NAME,SIZE,TYPE \
      | grep -E "disk|raid[0-9]+$" \
      | sed 's/[^[:alnum:]_., ]//g' \
      | column -t \
      | sort -k 1,1 \
      | uniq \
      | awk '{print "\""$1"\"""  ""\"| "$2" | "$3"     \""" \\"}' \
      | column -t)"
    while read -r line; do
      if [[ "$1" =~ root || ! "${line}" =~ ${ROOT_DRIVE} ]]; then
        echo "${line}" >>/tmp/gdl/part.sh
      fi
    done < <(echo "${DEVICE_LIST}")

  # Finish crafting 'dialog' command for the manual partitioning menu
  else
    grep_str="$(lsblk \
      | grep ' /run' \
      | grep -o sd. \
      | tr '\n' '|')loop[0-9]+|sr[0-9]+|fd[0-9]+"
    DEVICE_LIST="$(lsblk -no NAME,SIZE,TYPE,FSTYPE \
      | grep -Ev "${grep_str}" \
      | sed 's/[^[:alnum:]_., -]//g' \
      | column -t \
      | sort -k 1,1 \
      | uniq)"
    device_count=$(wc -l <<<"${DEVICE_LIST}")
    # shellcheck disable=SC2028
    echo "\"${EDIT}\" --cancel-button \"${CANCEL}\" --menu \"\n${menu_msg}\n\n\
${menu_header}\" 21 68 9 \\" >>/tmp/gdl/part.sh
    [[ -f /tmp/gdl/part.list ]] && rm /tmp/gdl/part.list
    counter=1
    until (( counter > device_count )); do
      device="$(awk <<<"${DEVICE_LIST}" '{print $1}' | awk "NR==${counter}")"
      dev_size="$(grep -w "${device}" <<<"${DEVICE_LIST}" | awk '{print $2}')"
      dev_type="$(grep -w "${device}" <<<"${DEVICE_LIST}" | awk '{print $3}')"
      dev_fs="$(grep -w "${device}" <<<"${DEVICE_LIST}" | awk '{print $4}')"
      dev_mnt="$(df \
        | grep -w "${device}" \
        | awk '{print $6}' \
        | sed 's/mnt\/\?//')"
      if grep -q '/' <<<"${dev_mnt}"; then
        dev_used="$(df -T | grep -w "${device}" | awk '{print $6}')"
      else
        dev_used="$(swapon -s | grep -w "${device}" | awk '{print $4}')"
        if [[ -n "${dev_used}" ]]; then
          dev_used="${dev_used}%"
        fi
      fi
      [[ -z "${dev_fs}" || "${dev_fs}" == "linux_raid_member" ]] \
        && dev_fs="${empty_value}"
      [[ -z "${dev_used}" ]] && dev_used="${empty_value}"
      [[ -z "${dev_mnt}" ]] && dev_mnt="${empty_value}"
      dev_parent="$(lsblk -dnro PKNAME "/dev/${device/-//}")"
      if [[ -z "${dev_parent}" ]]; then
        dev_type="$(grep -w "${device}" <<<"${DEVICE_LIST}" | awk '{print $3}')"
      else
        dev_type="$(fdisk -lo Device,Type "/dev/${dev_parent}" \
          | grep -w "${device}" \
          | cut -d ' ' -f 2- \
          | sed -e 's/^[[:space:]]*//;s/[[:space:]]*$//;s/ /_/g')"
      fi
      echo "\"${device}\" \"${dev_size} ${dev_used} ${dev_fs} ${dev_mnt} \
${dev_type}\" \\" >>/tmp/gdl/part.list
      (( ++counter ))
    done
    column </tmp/gdl/part.list -t >>/tmp/gdl/part.sh
    echo -e "\"${DONE}\" \"${WRITE_CHANGES}\"" >>/tmp/gdl/part.sh
  fi
}

################################################################################
# Handle root drive partition setup as the first phase of auto-partitioning. A
# separate /efi or /boot partition is created for UEFI and BIOS systems
# respectively, plus a 1 MiB BIOS boot partition for BIOS/GPT systems, along
# with a swap partition unless swap size is zero or '--no-swap' was passed.
#
# Globals: GPT, UEFI, SWAP_SIZE, BOOT_OR_ESP_SIZE, BOOT_OR_ESP, ROOT_DRIVE,
#   ROOT_PART, ROOT_PART_LOAD_MSG
# Arguments: '--no-swap' if a swap partition isn't desired.
# Returns: Number of errors detected.
################################################################################
partition_root_drive() {
  log "* Setting up partitions..."
  if "${GPT}"; then
    if "${UEFI}"; then # UEFI/GPT
      if [[ -z $1 ]] && (( SWAP_SIZE > 0 )); then
        echo -e "n\n\n\n${BOOT_OR_ESP_SIZE}M\nef00\nn\n3\n\n+${SWAP_SIZE}M\n\
8200\nn\n\n\n\n\nw\ny" | gdisk "/dev/${ROOT_DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${ROOT_PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${ROOT_DRIVE}\Zn"
        format_swap_partition "${ROOT_DRIVE}${partition_prefix}3" || return 1
      else
        echo -e "n\n\n\n${BOOT_OR_ESP_SIZE}M\nef00\nn\n\n\n\n\nw\ny" \
          | gdisk "/dev/${ROOT_DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${ROOT_PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${ROOT_DRIVE}\Zn"
      fi
      BOOT_OR_ESP="${ROOT_DRIVE}${partition_prefix}1"
      ROOT_PART="${ROOT_DRIVE}${partition_prefix}2"
      log "  - EFI system partition (ESP) created: ${BOOT_OR_ESP}"
    else # BIOS/GPT
      if [[ -z $1 ]] && (( SWAP_SIZE > 0 )); then
        echo -e "o\ny\nn\n1\n\n+${BOOT_OR_ESP_SIZE}M\n\nn\n2\n\n+1M\nef02\nn\n\
4\n\n+${SWAP_SIZE}M\n8200\nn\n3\n\n\n\nw\ny" | gdisk "/dev/${ROOT_DRIVE}" \
&>/dev/null &
        load_bar "$(eval echo \"${ROOT_PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${ROOT_DRIVE}\Zn"
        format_swap_partition "${ROOT_DRIVE}${partition_prefix}4" || return 1
      else
        echo -e "o\ny\nn\n1\n\n+${BOOT_OR_ESP_SIZE}M\n\nn\n2\n\n+1M\nef02\nn\n3\
\n\n\n\nw\ny" | gdisk "/dev/${ROOT_DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${ROOT_PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${ROOT_DRIVE}\Zn"
      fi
      BOOT_OR_ESP="${ROOT_DRIVE}${partition_prefix}1"
      ROOT_PART="${ROOT_DRIVE}${partition_prefix}3"
      log "  - BIOS boot partition created: ${ROOT_DRIVE}${partition_prefix}2"
    fi
  else # BIOS/MBR
    if [[ -z $1 ]] && (( SWAP_SIZE > 0 )); then
      echo -e "o\nn\np\n1\n\n+${BOOT_OR_ESP_SIZE}M\nn\np\n3\n\n+${SWAP_SIZE}M\n\
t\n\n82\nn\np\n2\n\n\nw" | fdisk "/dev/${ROOT_DRIVE}" &>/dev/null &
      load_bar "$(eval echo \"${ROOT_PART_LOAD_MSG}\")\n\n \Z1> \Z2fdisk \
/dev/${ROOT_DRIVE}\Zn"
      format_swap_partition "${ROOT_DRIVE}${partition_prefix}3" || return 1
    else
      echo -e "o\nn\np\n1\n\n+${BOOT_OR_ESP_SIZE}M\nn\np\n2\n\n\nw" \
        | fdisk "/dev/${ROOT_DRIVE}" &>/dev/null &
      load_bar "$(eval echo \"${ROOT_PART_LOAD_MSG}\")\n\n \Z1> \Z2fdisk \
/dev/${ROOT_DRIVE}\Zn"
    fi
    BOOT_OR_ESP="${ROOT_DRIVE}${partition_prefix}1"
    ROOT_PART="${ROOT_DRIVE}${partition_prefix}2"
  fi
  "${UEFI}" || log "  - Boot partition created: ${BOOT_OR_ESP}"
  log "  - Root partition created: ${ROOT_PART}"
}

################################################################################
# Provide a given device's size as measured in GiB (number only).
#
# Arguments: Name of the device (e.g., 'sdb' or 'sdb1').
# Outputs: Size of the device in GiB (or '0' if the argument's invalid).
################################################################################
get_device_size_gib() {
  local -i size=0

  if [[ -b "/dev/$1" ]]; then
    size=$(( $(lsblk -nbo SIZE "/dev/$1" | sed -n 1p) / 1024 / 1024 / 1024 ))
  fi
  echo $size
}

################################################################################
# Present the filesystem menu and return its output.
#
# Globals: SELECT_FS_MSG, FS_EXT4_MSG, FS_BTRFS_MSG, FS_XFS_MSG
# Arguments: None
# Outputs: The selected filesystem (or nothing if the user hits Esc).
################################################################################
get_filesystem() {
  dialog --no-cancel --menu "\n${SELECT_FS_MSG}" 12 60 3 \
    'ext4' "${FS_EXT4_MSG}" \
    'btrfs' "${FS_BTRFS_MSG}" \
    'xfs' "${FS_XFS_MSG}"
}

################################################################################
# After user confirmation, "zap" and "wipe" a given drive, removing any GPT/MBR
# data structures as well as any filesystem/raid/partition signatures.
#
# Globals: WIPE_DRIVE_CONFIRM, WRITE_CHANGES, CANCEL
# Arguments: Name of the drive (e.g., 'sda'), its size in GiB, and the
#   filesystem chosen for it (for use in WIPE_DRIVE_CONFIRM).
# Returns: '0' if the drive is wiped, '1' otherwise.
################################################################################
wipe_drive() {
  # shellcheck disable=SC2034
  local drive="/dev/$1" drive_gib="$2" drive_fs="$3"

  if [[ -z $2 || -z $3 || ! -b "${drive}" ]]; then
    log_error "Invalid argument(s) passed to 'wipe_drive': $1, $2, $3"
  elif yesno "$(eval echo \"${WIPE_DRIVE_CONFIRM}\")" "${WRITE_CHANGES}" \
      "${CANCEL}" --defaultno; then
    zap_and_wipe "$1" || return 1

    return 0
  fi

  return 1
}

################################################################################
# "Zap" and "wipe" a given storage device (drive or partition), removing any
# GPT/MBR data structures as well as any filesystem/raid/partition signatures.
#
# Globals: WIPEFS_LOAD_MSG
# Arguments: Name of drive/partition to zap and wipe (e.g., 'sda2').
# Returns: Number of errors detected.
################################################################################
zap_and_wipe() {
  local device="/dev/$1"

  if [[ ! -b "${device}" ]]; then
    log_error "Invalid device name passed to 'zap_and_wipe': ${device}"
    return 1
  fi
  (
    sgdisk --zap-all "${device}"
    wipefs -a "${device}"
  ) &>/dev/null &
  load_bar "${WIPEFS_LOAD_MSG}\n\n \Z1> \Z2wipefs -a ${device}\Zn"
}

################################################################################
# Let the user select a disk utility to modify a given disk's partition table.
#
# Globals: SELECT_DISK_UTIL_MSG, CFDISK_MSG, FDISK_MSG, GDISK_MSG
# Arguments: Full path of the disk to be modified (e.g., '/dev/sda').
# Returns: Number of errors detected.
################################################################################
modify_partition_table() {
  local disk_util

  if [[ ! -b "$1" ]]; then
    log_error "Invalid device name passed to 'modify_partition_table': $1"
    return 1
  elif disk_util="$(dialog --menu "\n${SELECT_DISK_UTIL_MSG}" 12 60 3 \
      'cfdisk' "${CFDISK_MSG}" \
      'fdisk' "${FDISK_MSG}" \
      'gdisk' "${GDISK_MSG}")"; then
    clear
    "${disk_util}" "$1"
    log "  - Disk $1 edited via ${disk_util}"
    clear
  fi
}

################################################################################
# Format a given partition to serve as swap space. Also assign the partition to
# SWAP_PART for potential future use.
#
# Globals: SWAP_PART, SWAP_LOAD_MSG
# Arguments: Name of the partition (e.g., 'sda3').
# Returns: Number of errors detected.
################################################################################
format_swap_partition() {
  if [[ ! -b "/dev/$1" ]]; then
    log_error "Invalid device name passed to 'format_swap_partition': $1"
    return 1
  fi

  SWAP_PART="$1"
  (
    wipefs -a "/dev/${SWAP_PART}"
    mkswap "/dev/${SWAP_PART}" \
      && log "  - Swap partition formatted and activated: /dev/${SWAP_PART}"
    swapon "/dev/${SWAP_PART}"
    sleep 0.6
  ) &>/dev/null &
  load_bar "${SWAP_LOAD_MSG}\n\n \Z1> \Z2mkswap /dev/${SWAP_PART}\Zn"
}

################################################################################
# Attempt to create a new Btrfs subvolume of a given name (which must follow the
# '@' = '/' schema) for a given Btrfs device, then mount it based on its name
# (replacing '@' with '/').
#
# Globals: BTRFS_MOUNT_OPTIONS
# Arguments: New subvolume name (starting with '@') and full Btrfs device path.
# Returns: Number of errors detected.
################################################################################
create_and_mount_btrfs_subvolume() {
  local subvol="$1" device="$2" mount_point
  local -i errors=0

  # Check and process arguments
  log "  - Creating Btrfs subvolume '${subvol}' on ${device}..."
  if [[ "${subvol}" =~ ^@ ]]; then
    mount_point="/mnt${subvol//@//}" # replace all '@' with '/'
    if mount | grep -q " ${mount_point} "; then
      log_error "Mount point ${mount_point} already occupied"
      (( ++errors ))
    elif [[ ! -b "${device}" ]]; then
      log_error "Invalid device path: ${device}"
      (( ++errors ))
    fi
  else
    log_error "Subvolume name '${subvol}' should start with '@'"
    (( ++errors ))
  fi

  # If both arguments seem valid, attempt to create and mount a new subvolume
  if (( errors == 0 )); then
    if mount -m "${device}" /btrfs-temp &>/dev/null; then
      if mount | grep '/btrfs-temp' | grep -q 'type btrfs'; then
        if btrfs subvolume create "/btrfs-temp/${subvol}" &>/dev/null; then
          if mount -m -o "${BTRFS_MOUNT_OPTIONS},subvol=${subvol}" "${device}" \
              "${mount_point}" &>/dev/null; then
            log "  - Mounted '${subvol}' at ${mount_point}"
          else
            log_error "Mounting '${subvol}' at ${mount_point} failed"
            (( ++errors ))
          fi
        else
          log_error "Unable to create subvolume '${subvol}'"
          (( ++errors ))
        fi
      else
        log_error "No Btrfs partition found on ${device}"
        (( ++errors ))
      fi
    else
      log_error "Failed to mount ${device}"
      (( ++errors ))
    fi
    umount /btrfs-temp &>/dev/null
    rm -r /btrfs-temp &>/dev/null
  fi

  return $errors
}

################################################################################
# Unmount everything under /mnt, close all encrypted devices, and (optionally)
# turn off swap.
#
# Globals: SYSTEM_MOUNTED, SYSTEM_AUTO_ENCRYPTED, ROOT_DRIVE, ROOT_PART, UEFI,
#   GPT, HOME_DRIVE, BOOT_OR_ESP, BOOT_OR_ESP_MNT, SWAP_PART, WAIT_LOAD_MSG
# Arguments: '--swapoff' if swap should be deactivated.
################################################################################
unmount_and_close_everything() {
  local -i attempts=0 max_attempts=3

  SYSTEM_MOUNTED='false'
  SYSTEM_AUTO_ENCRYPTED='false'
  GPT='false'
  UEFI='false'
  ROOT_DRIVE=''
  ROOT_PART=''
  HOME_DRIVE=''
  BOOT_OR_ESP=''
  BOOT_OR_ESP_MNT=''

  log "* Checking for devices to unmount/deactivate/close..."
  while [[ "$1" == '--swapoff' && -n $(swapon --show) ]] \
      && (( attempts < max_attempts )); do
    SWAP_PART=''
    log "  - Deactivating swap..."
    swapoff -a &>/dev/null &
    load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2swapoff -a\Zn"
    (( ++attempts ))
  done
  attempts=0
  while lsblk | grep -q '/mnt' && (( attempts < max_attempts )); do
    log "  - Unmounting everything under /mnt..."
    umount -R /mnt &>/dev/null &
    load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2umount -R /mnt\Zn"
    (( ++attempts ))
  done
  attempts=0
  while [[ ! $(dmsetup ls) =~ ^No ]] && (( attempts < max_attempts )); do
    for device in $(dmsetup ls | awk '{print $1}' | sort -r); do
      cryptsetup close "$1" &>/dev/null \
        && log "  - Encrypted device '$1' successfully closed"
    done
    (( ++attempts ))
  done
}

################################################################################
# Prompt user for a hostname until a valid hostname is provided.
#
# Globals: TITLE, SET_HOSTNAME_TITLE, HOSTNAME, OK, SET_HOSTNAME_MSG,
#   HOSTNAME_ERROR_MSG
# Arguments: None
################################################################################
set_hostname() {
  TITLE="${SET_HOSTNAME_TITLE}"
  while true; do
    if HOSTNAME="$(dialog --ok-button "${OK}" --no-cancel --inputbox \
          "\n${SET_HOSTNAME_MSG}" 12 55 "${HOSTNAME}" | tr -d '[:space:]')" \
        && [[ -n "${HOSTNAME}" ]]; then
      if grep -q "^[0-9]\|[\[\$\!\'\"\`\\|%&#@()+=<>~;:/?.,^{}]\|]" \
          <<<"${HOSTNAME}"; then
        message "${HOSTNAME_ERROR_MSG}"
      else
        break
      fi
    fi
  done
  log "Hostname set: ${HOSTNAME}"
}

################################################################################
# Prompt user for a username and full name and ensure all input is valid, then
# call 'set_password' to handle password input. (For now, GDL does not support
# creating more than one user during installation.)
#
# Globals: TITLE, ADD_USER_TITLE, USERNAME, FULL_NAME, OK, SET_USERNAME_MSG,
#   USERNAME_EMPTY_ERROR_MSG, USERNAME_CHAR_ERROR_MSG, SET_FULL_NAME_MSG,
#   FULL_NAME_ERROR_MSG
# Arguments: None
################################################################################
set_user() {
  TITLE="${ADD_USER_TITLE}"
  while true; do
    if ! USERNAME="$(dialog --no-cancel --ok-button "${OK}" --inputbox \
          "\n${SET_USERNAME_MSG}" 12 55 | tr -d '[:space:]')" \
        || [[ -z "${USERNAME}" ]]; then
      message "${USERNAME_EMPTY_ERROR_MSG}"
    elif grep -q "^[0-9]\|[A-Z]\|[]:/?#@\!\$&'()*+,;=%[]" <<<"${USERNAME}"; then
      message "${USERNAME_CHAR_ERROR_MSG}"
    else
      log "Username set: ${USERNAME}"
      while true; do
        if FULL_NAME="$(dialog --no-cancel --ok-button "${OK}" --inputbox \
            "\n${SET_FULL_NAME_MSG}" 12 55)"; then
          if grep -Eq ',|:' <<<"${FULL_NAME}"; then
            message "${FULL_NAME_ERROR_MSG}"
          else
            set_password
            break
          fi
        fi
      done
      break
    fi
  done
}

################################################################################
# Prompt user for a password ('root' will use the same password).
#
# Globals: TITLE, SET_PASSWORD_TITLE, PASSWORD, SSL_KEY, USER_PASSWORD_MSG,
#   USER_PASSWORD_CONFIRM, PASSWORD_EMPTY_MSG, PASSWORD_MISMATCH_MSG, USERNAME
# Arguments: None
################################################################################
set_password() {
  TITLE="${SET_PASSWORD_TITLE}"
  local input input_check

  while true; do
    if ! input="$(dialog --no-cancel --clear --insecure --passwordbox \
          "\n$(eval echo \"${USER_PASSWORD_MSG}\")" 12 60)" \
        || ! input_check="$(dialog --no-cancel --clear --insecure \
          --passwordbox "\n$(eval echo \"${USER_PASSWORD_CONFIRM}\")" 12 60)" \
        || [[ -z "${input}" ]]; then
      message "${PASSWORD_EMPTY_MSG}"
    elif [[ "${input}" != "${input_check}" ]]; then
      message "${PASSWORD_MISMATCH_MSG}"
    else
      break
    fi
  done
  PASSWORD="$(echo "${input}" | openssl enc -aes-256-cbc -a -salt -pbkdf2 \
    -iter 1000 -pass "pass:${SSL_KEY}")"
  unset input input_check
  log "Password set for user: ${USERNAME}"
}

################################################################################
# Provide desktop environment (DE) options and add to the base and AUR package
# lists according to chosen DE, detected hardware, etc.
#
# Globals: TITLE, INSTALLATION_TITLE, BASE_PACKAGES, AUR_PACKAGES, DESKTOP_ENV,
#   DESKTOP_ENV_BASE_PACKAGES, DESKTOP_ENV_AUR_PACKAGES, DISPLAY_MANAGER,
#   LOCALE, TOUCHPAD_MSG, OS_PROBER_MSG, UEFI, ROOT_FS, VM_TYPE, GPU_CHIPSET,
#   DEFAULT, DEFAULT_GPU_DRIVER, AMD_GPU_PACKAGES, INTEL_GPU_PACKAGES,
#   NVIDIA_GPU_PACKAGES, DESKTOP_ENV_MSG, DISPLAY_MANAGER_MSG, GPU_DRIVER_MSG,
#   GPU_DEFAULT_MSG, GPU_AMDGPU_MSG, GPU_ATI_MSG, GPU_INTEL_MSG, GPU_NVIDIA_MSG,
#   GPU_NOUVEAU_MSG, GPU_VESA_MSG, YES, NO, OK
# Arguments: None
################################################################################
prepare_base() {
  TITLE="${INSTALLATION_TITLE}"
  local gpu_driver
  log "Preparing base packages..."

  # Set desktop environment
  until DESKTOP_ENV="$(dialog --stdout --no-cancel --ok-button "${OK}" --menu \
      "\n${DESKTOP_ENV_MSG}" 13 60 4 \
      'KDE Plasma' '->' \
      'GNOME' '->' \
      'Cinnamon' '->' \
      'Xfce' '->')"; do
    continue
  done
  DESKTOP_ENV="$(echo "${DESKTOP_ENV@L}" | tr ' ' '-')"
  BASE_PACKAGES+="${DESKTOP_ENV_BASE_PACKAGES[$DESKTOP_ENV]}"
  AUR_PACKAGES+="${DESKTOP_ENV_AUR_PACKAGES[$DESKTOP_ENV]}"
  log "* Desktop environment: ${DESKTOP_ENV}"

  # Set display manager (login manager)
  case "${DESKTOP_ENV}" in
    kde-plasma) # offer SDDM or LightDM for KDE Plasma
      until DISPLAY_MANAGER="$(dialog --stdout --no-cancel --ok-button "${OK}" \
          --menu "\n${DISPLAY_MANAGER_MSG} \Z2sddm\Zn" 13 60 2 \
          'sddm' '->' \
          'lightdm' '->')"; do
        continue
      done
      ;;
    gnome) DISPLAY_MANAGER='gdm' ;; # default to GDM for GNOME
    *) DISPLAY_MANAGER='lightdm' ;; # default to LightDM for Cinnamon/Xfce
  esac
  BASE_PACKAGES+="${DISPLAY_MANAGER} "
  if [[ "${DISPLAY_MANAGER}" == 'lightdm' ]]; then
    BASE_PACKAGES+='lightdm-gtk-greeter-settings '
    AUR_PACKAGES+='lightdm-guest-account '
  fi
  log "* Display manager: ${DISPLAY_MANAGER}"

  # Add packages based on hardware, boot/root setup, and user input
  if grep -q 'AuthenticAMD' /proc/cpuinfo; then
    BASE_PACKAGES+='amd-ucode '
    log "* Added AMD microcode"
  elif grep -q 'GenuineIntel' /proc/cpuinfo; then
    BASE_PACKAGES+='intel-ucode '
    log "* Added Intel microcode"
  fi
  if yesno "${TOUCHPAD_MSG}" "${YES}" "${NO}" --defaultno; then
    BASE_PACKAGES+='xf86-input-libinput '
    log "* Added touchpad support"
  fi
  if yesno "${OS_PROBER_MSG}" "${YES}" "${NO}" --defaultno; then
    BASE_PACKAGES+='os-prober '
    log "* Added OS prober"
  fi
  if "${UEFI}"; then
    BASE_PACKAGES+='efibootmgr '
    log "* Added EFI boot manager"
  fi
  if [[ "${ROOT_FS}" == 'btrfs' ]]; then
    BASE_PACKAGES+='grub-btrfs inotify-tools '
    log "* Added GRUB Btrfs snapshot support"
  fi

  # Add locale-specific packages
  if [[ "${LOCALE}" =~ zh_|yue_|_CN|_HK|_SG|_TW|ja_|ko_ ]]; then
    BASE_PACKAGES+='noto-fonts-cjk '
  fi
  if grep -q 'libreoffice' <<<"${BASE_PACKAGES}"; then
    case "${LOCALE}" in
      af_*) BASE_PACKAGES+='libreoffice-fresh-af ' ;; # Afrikaans
      am_*) BASE_PACKAGES+='libreoffice-fresh-am ' ;; # Amharic
      ar_*) BASE_PACKAGES+='libreoffice-fresh-ar ' ;; # Arabic
      as_*) BASE_PACKAGES+='libreoffice-fresh-as ' ;; # Assamese
      ast_*) BASE_PACKAGES+='libreoffice-fresh-ast ' ;; # Asturianu
      be_*) BASE_PACKAGES+='libreoffice-fresh-be ' ;; # Belarusian
      bg_*) BASE_PACKAGES+='libreoffice-fresh-bg ' ;; # Bulgarian
      bn_IN*) BASE_PACKAGES+='libreoffice-fresh-bn-in ' ;; # Bengali (India)
      bn_*) BASE_PACKAGES+='libreoffice-fresh-bn ' ;; # Bengali
      bo_*) BASE_PACKAGES+='libreoffice-fresh-bo ' ;; # Tibetan
      br_*) BASE_PACKAGES+='libreoffice-fresh-br ' ;; # Breton
      brx_*) BASE_PACKAGES+='libreoffice-fresh-brx ' ;; # Bodo
      bs_*) BASE_PACKAGES+='libreoffice-fresh-bs ' ;; # Bosnian
      ca_*val*) BASE_PACKAGES+='libreoffice-fresh-ca-valencia ' ;; # Cat. (Val.)
      ca_*) BASE_PACKAGES+='libreoffice-fresh-ca ' ;; # Catalan
      ckb_*) BASE_PACKAGES+='libreoffice-fresh-ckb ' ;; # Central Kurdish/Sorani
      cs_*) BASE_PACKAGES+='libreoffice-fresh-cs ' ;; # Czech
      cy_*) BASE_PACKAGES+='libreoffice-fresh-cy ' ;; # Welsh
      da_*) BASE_PACKAGES+='libreoffice-fresh-da ' ;; # Danish
      de_*) BASE_PACKAGES+='libreoffice-fresh-de ' ;; # German
      dgo_*) BASE_PACKAGES+='libreoffice-fresh-dgo ' ;; # Dogri
      dsb_*) BASE_PACKAGES+='libreoffice-fresh-dsb ' ;; # Sorbian (Lower)
      dz_*) BASE_PACKAGES+='libreoffice-fresh-dz ' ;; # Dzongkha
      el_*) BASE_PACKAGES+='libreoffice-fresh-el ' ;; # Greek
      en_ZA*) BASE_PACKAGES+='libreoffice-fresh-en-za ' ;; # English (S. Africa)
      en_[^U]*) BASE_PACKAGES+='libreoffice-fresh-en-gb ' ;; # English (GB)
      eo_*) BASE_PACKAGES+='libreoffice-fresh-eo ' ;; # Esperanto
      es_*) BASE_PACKAGES+='libreoffice-fresh-es ' ;; # Spanish
      et_*) BASE_PACKAGES+='libreoffice-fresh-et ' ;; # Estonian
      eu_*) BASE_PACKAGES+='libreoffice-fresh-eu ' ;; # Basque
      fa_*) BASE_PACKAGES+='libreoffice-fresh-fa ' ;; # Persian
      fi_*) BASE_PACKAGES+='libreoffice-fresh-fi ' ;; # Finnish
      fr_*) BASE_PACKAGES+='libreoffice-fresh-fr ' ;; # French
      fur_*) BASE_PACKAGES+='libreoffice-fresh-fur ' ;; # Friulian/Friulan
      fy_*) BASE_PACKAGES+='libreoffice-fresh-fy ' ;; # Frisian/Frysk/Fries
      ga_*) BASE_PACKAGES+='libreoffice-fresh-ga ' ;; # Irish
      gd_*) BASE_PACKAGES+='libreoffice-fresh-gd ' ;; # Gaelic (Scottish)
      gl_*) BASE_PACKAGES+='libreoffice-fresh-gl ' ;; # Galician
      gn_*|gug_*) BASE_PACKAGES+='libreoffice-fresh-gug ' ;; # Guarani
      gu_*) BASE_PACKAGES+='libreoffice-fresh-gu ' ;; # Gujarati
      he_*) BASE_PACKAGES+='libreoffice-fresh-he ' ;; # Hebrew
      hi_*) BASE_PACKAGES+='libreoffice-fresh-hi ' ;; # Hindi
      hr_*) BASE_PACKAGES+='libreoffice-fresh-hr ' ;; # Croatian
      hsb_*) BASE_PACKAGES+='libreoffice-fresh-hsb ' ;; # Sorbian (Upper)
      hu_*) BASE_PACKAGES+='libreoffice-fresh-hu ' ;; # Hungarian
      id_*) BASE_PACKAGES+='libreoffice-fresh-id ' ;; # Indonesian
      is_*) BASE_PACKAGES+='libreoffice-fresh-is ' ;; # Icelandic
      it_*) BASE_PACKAGES+='libreoffice-fresh-it ' ;; # Italian
      ja_*) BASE_PACKAGES+='libreoffice-fresh-ja ' ;; # Japanese
      ka_*) BASE_PACKAGES+='libreoffice-fresh-ka ' ;; # Georgian
      kab_*) BASE_PACKAGES+='libreoffice-fresh-kab ' ;; # Kabyle, etc.
      kk_*) BASE_PACKAGES+='libreoffice-fresh-kk ' ;; # Kazakh
      km_*) BASE_PACKAGES+='libreoffice-fresh-km ' ;; # Khmer
      kmr_*) BASE_PACKAGES+='libreoffice-fresh-kmr-latn ' ;; # Kurdish
      kn_*) BASE_PACKAGES+='libreoffice-fresh-kn ' ;; # Kannada
      ko_*) BASE_PACKAGES+='libreoffice-fresh-ko ' ;; # Korean
      kok_*) BASE_PACKAGES+='libreoffice-fresh-kok ' ;; # Konkani
      ks_*) BASE_PACKAGES+='libreoffice-fresh-ks ' ;; # Kashmiri
      lb_*) BASE_PACKAGES+='libreoffice-fresh-lb ' ;; # Luxembourgish
      lo_*) BASE_PACKAGES+='libreoffice-fresh-lo ' ;; # Lao
      lt_*) BASE_PACKAGES+='libreoffice-fresh-lt ' ;; # Lithuanian
      lv_*) BASE_PACKAGES+='libreoffice-fresh-lv ' ;; # Latvian
      mai_*) BASE_PACKAGES+='libreoffice-fresh-mai ' ;; # Maithili
      mk_*) BASE_PACKAGES+='libreoffice-fresh-mk ' ;; # Macedonian
      ml_*) BASE_PACKAGES+='libreoffice-fresh-ml ' ;; # Malayalam
      mn_*) BASE_PACKAGES+='libreoffice-fresh-mn ' ;; # Mongolian
      mni_*) BASE_PACKAGES+='libreoffice-fresh-mni ' ;; # Manipuri
      mr_*) BASE_PACKAGES+='libreoffice-fresh-mr ' ;; # Marathi
      my_*) BASE_PACKAGES+='libreoffice-fresh-my ' ;; # Burmese
      nb_*) BASE_PACKAGES+='libreoffice-fresh-nb ' ;; # Norwegian (Bokmål)
      ne_*) BASE_PACKAGES+='libreoffice-fresh-ne ' ;; # Nepali
      nl_*) BASE_PACKAGES+='libreoffice-fresh-nl ' ;; # Dutch
      nn_*) BASE_PACKAGES+='libreoffice-fresh-nn ' ;; # Norwegian (Nynorsk)
      nr_*) BASE_PACKAGES+='libreoffice-fresh-nr ' ;; # Ndebele
      nso_*) BASE_PACKAGES+='libreoffice-fresh-nso ' ;; # Sotho (Northern)
      oc_*) BASE_PACKAGES+='libreoffice-fresh-oc ' ;; # Occitan
      om_*) BASE_PACKAGES+='libreoffice-fresh-om ' ;; # Oromo
      or_*) BASE_PACKAGES+='libreoffice-fresh-or ' ;; # Oriya
      pa_*) BASE_PACKAGES+='libreoffice-fresh-pa-in ' ;; # Punjabi
      pl_*) BASE_PACKAGES+='libreoffice-fresh-pl ' ;; # Polish
      pt_BR*) BASE_PACKAGES+='libreoffice-fresh-pt-br ' ;; # Portuguese (Brazil)
      pt_*) BASE_PACKAGES+='libreoffice-fresh-pt ' ;; # Portuguese
      ro_*) BASE_PACKAGES+='libreoffice-fresh-ro ' ;; # Romanian
      ru_*) BASE_PACKAGES+='libreoffice-fresh-ru ' ;; # Russian
      rw_*) BASE_PACKAGES+='libreoffice-fresh-rw ' ;; # Kinyarwanda
      sa_*) BASE_PACKAGES+='libreoffice-fresh-sa-in ' ;; # Sanskrit
      sat_*) BASE_PACKAGES+='libreoffice-fresh-sat ' ;; # Santali
      sd_*) BASE_PACKAGES+='libreoffice-fresh-sd ' ;; # Sindhi
      si_*) BASE_PACKAGES+='libreoffice-fresh-si ' ;; # Sinhala
      sid_*) BASE_PACKAGES+='libreoffice-fresh-sid ' ;; # Sidama
      sk_*) BASE_PACKAGES+='libreoffice-fresh-sk ' ;; # Slovak
      sl_*) BASE_PACKAGES+='libreoffice-fresh-sl ' ;; # Slovenian
      sq_*) BASE_PACKAGES+='libreoffice-fresh-sq ' ;; # Albanien
      sr_*lat*) BASE_PACKAGES+='libreoffice-fresh-sr-latn ' ;; # Serbian (Latin)
      sr_*) BASE_PACKAGES+='libreoffice-fresh-sr ' ;; # Serbian
      ss_*) BASE_PACKAGES+='libreoffice-fresh-ss ' ;; # Swati
      st_*) BASE_PACKAGES+='libreoffice-fresh-st ' ;; # Sotho (Southern)
      sv_*) BASE_PACKAGES+='libreoffice-fresh-sv ' ;; # Swedish
      sw_*) BASE_PACKAGES+='libreoffice-fresh-sw-tz ' ;; # Swahili
      szl_*) BASE_PACKAGES+='libreoffice-fresh-szl ' ;; # Silesian
      ta_*) BASE_PACKAGES+='libreoffice-fresh-ta ' ;; # Tamil
      te_*) BASE_PACKAGES+='libreoffice-fresh-te ' ;; # Telugu
      tg_*) BASE_PACKAGES+='libreoffice-fresh-tg ' ;; # Tajik
      th_*) BASE_PACKAGES+='libreoffice-fresh-th ' ;; # Thai
      tn_*) BASE_PACKAGES+='libreoffice-fresh-tn ' ;; # Tswana
      tr_*) BASE_PACKAGES+='libreoffice-fresh-tr ' ;; # Turkish
      ts_*) BASE_PACKAGES+='libreoffice-fresh-ts ' ;; # Tsonga
      tt_*) BASE_PACKAGES+='libreoffice-fresh-tt ' ;; # Tatar
      ug_*) BASE_PACKAGES+='libreoffice-fresh-ug ' ;; # Uighur
      uk_*) BASE_PACKAGES+='libreoffice-fresh-uk ' ;; # Ukranian
      uz_*) BASE_PACKAGES+='libreoffice-fresh-uz ' ;; # Uzbek
      ve_*) BASE_PACKAGES+='libreoffice-fresh-ve ' ;; # Venda
      vec_*) BASE_PACKAGES+='libreoffice-fresh-vec ' ;; # Venetian
      vi_*) BASE_PACKAGES+='libreoffice-fresh-vi ' ;; # Vietnamese
      xh_*) BASE_PACKAGES+='libreoffice-fresh-xh ' ;; # Xhosa
      zh_CN*|zh_SG*) BASE_PACKAGES+='libreoffice-fresh-zh-cn ' ;; # S. Chinese
      zh_*|yue_*|*_TW*) BASE_PACKAGES+='libreoffice-fresh-zh-tw ' ;; # T. Ch.
      zu_*) BASE_PACKAGES+='libreoffice-fresh-zu ' ;; # Zulu
    esac
  fi

  # Add graphics/VM packages
  if [[ "${VM_TYPE}" != 'none' ]]; then
    case "${VM_TYPE}" in
      qemu)
        BASE_PACKAGES+='spice-vdagent qemu-guest-agent '
        log "* Added QEMU guest utils"
        ;;
      oracle)
        BASE_PACKAGES+='virtualbox-guest-utils '
        log "* Added VirtualBox guest utils"
        ;;
      vmware)
        BASE_PACKAGES+='xf86-video-vmware xf86-input-vmmouse open-vm-tools
          net-tools gtkmm '
        log "* Added VMware guest utils"
        ;;
      *)
        BASE_PACKAGES+='xf86-video-fbdev '
        log "* Added generic VM guest utils"
        ;;
    esac
  else # not a VM
    if [[ "${GPU_CHIPSET}" == 'NVIDIA' ]]; then
      until gpu_driver="$(dialog --ok-button "${OK}" --no-cancel --menu \
          "\n$(eval echo \"${GPU_DRIVER_MSG}\")" 18 60 7 \
          "${DEFAULT}" "${GPU_DEFAULT_MSG}" \
          'nvidia' "${GPU_NVIDIA_MSG}" \
          'xf86-video-nouveau' "${GPU_NOUVEAU_MSG}" \
          'xf86-video-intel' "${GPU_INTEL_MSG}" \
          'xf86-video-vesa' "${GPU_VESA_MSG}" \
          'xf86-video-amdgpu' "${GPU_AMDGPU_MSG}" \
          'xf86-video-ati' "${GPU_ATI_MSG}")"; do
        continue
      done
    else
      until gpu_driver="$(dialog --ok-button "${OK}" --no-cancel --menu \
          "\n$(eval echo \"${GPU_DRIVER_MSG}\")" 17 60 6 \
          "${DEFAULT}" "${GPU_DEFAULT_MSG}" \
          'xf86-video-amdgpu' "${GPU_AMDGPU_MSG}" \
          'xf86-video-ati' "${GPU_ATI_MSG}" \
          'xf86-video-intel' "${GPU_INTEL_MSG}" \
          'xf86-video-vesa' "${GPU_VESA_MSG}" \
          'nvidia' "${GPU_NVIDIA_MSG}" \
          'xf86-video-nouveau' "${GPU_NOUVEAU_MSG}")"; do
        continue
      done
    fi
    [[ "${gpu_driver}" == "${DEFAULT}" ]] && gpu_driver="${DEFAULT_GPU_DRIVER}"
    BASE_PACKAGES+="${gpu_driver} "
    case "${gpu_driver}" in
      nvidia) BASE_PACKAGES+="${NVIDIA_GPU_PACKAGES}" ;;
      *-ati|*-amdgpu) BASE_PACKAGES+="${AMD_GPU_PACKAGES}" ;;
      xf86-video-intel) BASE_PACKAGES+="${INTEL_GPU_PACKAGES}" ;;
    esac
    log "* Added graphics driver: ${gpu_driver}"
  fi
}

################################################################################
# Present categorized software menus and add selected and supplemental packages
# to the base package list (some may be moved to the AUR list later).
#
# Globals: TITLE, SELECT_SOFTWARE_MSG, BASE_PACKAGES, AUR_PACKAGES, DESKTOP_ENV,
#   WINE_PACKAGES, ROOT_FS, LOCALE, OK, BACK, and various software menu titles
#   and package descriptions
# Arguments: None
################################################################################
select_additional_software() {
  local -a software options
  local -i category_num=0 num_categories=13

  while (( category_num < num_categories )); do
    case $category_num in
      0)
        TITLE="${MISC_GAMES_SOFTWARE_TITLE}"
        options=(
          'lutris' "${SOFTWARE_LUTRIS}" OFF
          'steam' "${SOFTWARE_STEAM}" OFF
          'bottles' "(AUR) ${SOFTWARE_BOTTLES}" OFF
          'itch-setup-bin' "(AUR) ${SOFTWARE_ITCH_SETUP_BIN}" OFF
          'heroic-games-launcher-bin'
            "(AUR) ${SOFTWARE_HEROIC_GAMES_LAUNCHER_BIN}" OFF
          'libretro' "${SOFTWARE_LIBRETRO}" OFF
          'dosbox' "${SOFTWARE_DOSBOX}" OFF
          'scummvm' "${SOFTWARE_SCUMMVM}" OFF
          'playonlinux' "(AUR) ${SOFTWARE_PLAYONLINUX}" OFF
          'innoextract' "${SOFTWARE_INNOEXTRACT}" OFF
        )
        ;;
      1)
        TITLE="${ACTION_GAMES_SOFTWARE_TITLE}"
        options=(
          'supertux' "${SOFTWARE_SUPERTUX}" OFF
          'frogatto' "${SOFTWARE_FROGATTO}" OFF
          'alex4' "${SOFTWARE_ALEX4}" OFF
          'sdlpop' "(AUR) ${SOFTWARE_SDLPOP}" OFF
          'asciiportal' "${SOFTWARE_ASCIIPORTAL}" OFF
          'mari0' "${SOFTWARE_MARI0}" OFF
          'xonotic' "${SOFTWARE_XONOTIC}" OFF
          'warsow' "${SOFTWARE_WARSOW}" OFF
          'sauerbraten' "${SOFTWARE_SAUERBRATEN}" OFF
          'assaultcube-reloaded' "(AUR) ${SOFTWARE_ASSAULTCUBE_RELOADED}" OFF
          'openarena' "(AUR) ${SOFTWARE_OPENARENA}" OFF
          'astromenace' "${SOFTWARE_ASTROMENACE}" OFF
          'chromium-bsu' "${SOFTWARE_CHROMIUM_BSU}" OFF
          'starfighter' "(AUR) ${SOFTWARE_STARFIGHTER}" OFF
          'teeworlds' "${SOFTWARE_TEEWORLDS}" OFF
          'bzflag' "(AUR) ${SOFTWARE_BZFLAG}" OFF
        )
        ;;
      2)
        TITLE="${ADVENTURE_GAMES_SOFTWARE_TITLE}"
        options=(
          'bass' "${SOFTWARE_BASS}" OFF
          'fotaq' "(AUR) ${SOFTWARE_FOTAQ}" OFF
          'lure' "(AUR) ${SOFTWARE_LURE}" OFF
          'drascula' "(AUR) ${SOFTWARE_DRASCULA}" OFF
          'zsdx' "(AUR) ${SOFTWARE_ZSDX}" OFF
          'zork1' "(AUR) ${SOFTWARE_ZORK1}" OFF
          'zork2' "(AUR) ${SOFTWARE_ZORK2}" OFF
          'zork3' "(AUR) ${SOFTWARE_ZORK3}" OFF
          'open-adventure' "(AUR) ${SOFTWARE_OPEN_ADVENTURE}" OFF
        )
        ;;
      3)
        TITLE="${ROLEPLAYING_GAMES_SOFTWARE_TITLE}"
        options=(
          'openmw' "${SOFTWARE_OPENMW}" OFF
          'openmw-tes3mp' "(AUR) ${SOFTWARE_OPENMW_TES3MP}" OFF
          'daggerfall-unity-bin' "(AUR) ${SOFTWARE_DAGGERFALL_UNITY_BIN}" OFF
          'rogue' "${SOFTWARE_ROGUE}" OFF
          'angband' "${SOFTWARE_ANGBAND}" OFF
          'umoria' "(AUR) ${SOFTWARE_UMORIA}" OFF
          'nethack' "${SOFTWARE_NETHACK}" OFF
          'tome4' "(AUR) ${SOFTWARE_TOME4}" OFF
          'stone-soup' "${SOFTWARE_STONE_SOUP}" OFF
          'cataclysm-dda-tiles' "${SOFTWARE_CATACLYSM_DDA_TILES}" OFF
          'doomrl' "(AUR) ${SOFTWARE_DOOMRL}" OFF
          'freedroidrpg' "${SOFTWARE_FREEDROIDRPG}" OFF
          'flare-game' "(AUR) ${SOFTWARE_FLARE_GAME}" OFF
          'naev' "${SOFTWARE_NAEV}" OFF
          'planeshift' "(AUR) ${SOFTWARE_PLANESHIFT}" OFF
          'runescape-launcher' "(AUR) ${SOFTWARE_RUNESCAPE_LAUNCHER}" OFF
          'runelite' "(AUR) ${SOFTWARE_RUNELITE}" OFF
          'manaplus' "${SOFTWARE_MANAPLUS}" OFF
        )
        ;;
      4)
        TITLE="${STRATEGY_GAMES_SOFTWARE_TITLE}"
        options=(
          '0ad' "${SOFTWARE_0AD}" OFF
          'widelands' "${SOFTWARE_WIDELANDS}" OFF
          'megaglest' "${SOFTWARE_MEGAGLEST}" OFF
          'warzone2100' "${SOFTWARE_WARZONE2100}" OFF
          'boswars' "(AUR) ${SOFTWARE_BOSWARS}" OFF
          'curseofwar' "${SOFTWARE_CURSEOFWAR}" OFF
          'wesnoth' "${SOFTWARE_WESNOTH}" OFF
          'pingus' "${SOFTWARE_PINGUS}" OFF
          'hedgewars' "${SOFTWARE_HEDGEWARS}" OFF
          'warmux' "(AUR) ${SOFTWARE_WARMUX}" OFF
          'freeciv' "${SOFTWARE_FREECIV}" OFF
          'singularity' "${SOFTWARE_SINGULARITY}" OFF
        )
        ;;
      5)
        TITLE="${RACING_GAMES_SOFTWARE_TITLE}"
        options=(
          'supertuxkart' "${SOFTWARE_SUPERTUXKART}" OFF
          'extremetuxracer' "${SOFTWARE_EXTREMETUXRACER}" OFF
          'armagetronad' "${SOFTWARE_ARMAGETRONAD}" OFF
          'gltron' "(AUR) ${SOFTWARE_GLTRON}" OFF
          'torcs' "(AUR) ${SOFTWARE_TORCS}" OFF
        )
        ;;
      6)
        TITLE="${SIM_GAMES_SOFTWARE_TITLE}"
        options=(
          'dwarffortress' "${SOFTWARE_DWARFFORTRESS}" OFF
          'lincity-ng' "${SOFTWARE_LINCITY_NG}" OFF
          'simutrans' "${SOFTWARE_SIMUTRANS}" OFF
          'flightgear' "(AUR) ${SOFTWARE_FLIGHTGEAR}" OFF
          'minetest' "${SOFTWARE_MINETEST}" OFF
          'minecraft-launcher' "(AUR) ${SOFTWARE_MINECRAFT_LAUNCHER}" OFF
        )
        ;;
      7)
        TITLE="${DEV_SOFTWARE_TITLE}"
        options=(
          'godot' "${SOFTWARE_GODOT}" OFF
          'unityhub' "(AUR) ${SOFTWARE_UNITYHUB}" OFF
          'unreal-engine' "(AUR) ${SOFTWARE_UNREAL_ENGINE}" OFF
          'spring' "${SOFTWARE_SPRING}" OFF
          'love' "${SOFTWARE_LOVE}" OFF
          'solarus' "(AUR) ${SOFTWARE_SOLARUS}" OFF
          'tiled' "${SOFTWARE_TILED}" OFF
          'allegro' "${SOFTWARE_ALLEGRO}" OFF
          'python-pygame' "${SOFTWARE_PYTHON_PYGAME}" OFF
          'panda3d' "(AUR) ${SOFTWARE_PANDA3D}" OFF
          'pygtk' "(AUR) ${SOFTWARE_PYGTK}" OFF
          'scratch' "${SOFTWARE_SCRATCH}" OFF
          'android-studio' "(AUR) ${SOFTWARE_ANDROID_STUDIO}" OFF
          'atom' "(AUR) ${SOFTWARE_ATOM}" OFF
          'code' "${SOFTWARE_CODE}" OFF
          'vscodium-bin' "${SOFTWARE_VSCODIUM_BIN}" OFF
          'geany' "${SOFTWARE_GEANY}" OFF
          'emacs' "${SOFTWARE_EMACS}" OFF
        )
        ;;
      8)
        TITLE="${GRAPHICS_SOFTWARE_TITLE}"
        options=(
          'gimp' "${SOFTWARE_GIMP}" OFF
          'inkscape' "${SOFTWARE_INKSCAPE}" OFF
          'blender' "${SOFTWARE_BLENDER}" OFF
          'goxel' "(AUR) ${SOFTWARE_GOXEL}" OFF
          'magicavoxel' "(AUR) ${SOFTWARE_MAGICAVOXEL}" OFF
          'libresprite' "(AUR) ${SOFTWARE_LIBRESPRITE}" OFF
          'aseprite' "(AUR) ${SOFTWARE_ASEPRITE}" OFF
          'mtpaint' "${SOFTWARE_MTPAINT}" OFF
          'mypaint' "${SOFTWARE_MYPAINT}" OFF
          'krita' "${SOFTWARE_KRITA}" OFF
        )
        ;;
      9)
        TITLE="${MULTIMEDIA_SOFTWARE_TITLE}"
        options=(
          'obs-studio' "${SOFTWARE_OBS_STUDIO}" OFF
          'kdenlive' "${SOFTWARE_KDENLIVE}" OFF
          'openshot' "${SOFTWARE_OPENSHOT}" OFF
          'simplescreenrecorder' "${SOFTWARE_SIMPLESCREENRECORDER}" OFF
          'minitube' "${SOFTWARE_MINITUBE}" OFF
          'yt-dlp' "${SOFTWARE_YT_DLP}" OFF
          'audacity' "${SOFTWARE_AUDACITY}" OFF
          'lmms' "${SOFTWARE_LMMS}" OFF
          'pulseaudio-equalizer' "${SOFTWARE_PULSEAUDIO_EQUALIZER}" OFF
          'spotify' "(AUR) ${SOFTWARE_SPOTIFY}" OFF
        )
        ;;
      10)
        TITLE="${INTERNET_SOFTWARE_TITLE}"
        options=(
          'firefox' "${SOFTWARE_FIREFOX}" OFF
          'chromium' "${SOFTWARE_CHROMIUM}" OFF
          'google-chrome' "(AUR) ${SOFTWARE_GOOGLE_CHROME}" OFF
          'opera' "${SOFTWARE_OPERA}" OFF
          'discord' "${SOFTWARE_DISCORD}" OFF
          'slack-desktop' "(AUR) ${SOFTWARE_SLACK_DESKTOP}" OFF
          'hexchat' "${SOFTWARE_HEXCHAT}" OFF
          'filezilla' "${SOFTWARE_FILEZILLA}" OFF
          'w3m' "${SOFTWARE_W3M}" OFF
          'lynx' "${SOFTWARE_LYNX}" OFF
        )
        ;;
      11)
        TITLE="${FONTS_AND_LANG_SOFTWARE_TITLE}"
        options=(
          'noto-fonts' "${SOFTWARE_NOTO_FONTS}" ON
          'noto-fonts-extra' "${SOFTWARE_NOTO_FONTS_EXTRA}" OFF
          'noto-fonts-cjk' "${SOFTWARE_NOTO_FONTS_CJK}" OFF
          'nerd-fonts-complete' "(AUR) ${SOFTWARE_NERD_FONTS_COMPLETE}" OFF
          'ibus-libpinyin' "${SOFTWARE_IBUS_LIBPINYIN}" OFF
          'ibus-chewing' "${SOFTWARE_IBUS_CHEWING}" OFF
          'ibus-kkc' "${SOFTWARE_IBUS_KKC}" OFF
          'ibus-hangul' "${SOFTWARE_IBUS_HANGUL}" OFF
        )
        ;;
      12)
        TITLE="${UTILITIES_SOFTWARE_TITLE}"
        options=(
          'htop' "${SOFTWARE_HTOP}" ON
          'gtop' "${SOFTWARE_GTOP}" OFF
          'bashtop' "${SOFTWARE_BASHTOP}" OFF
          'mangohud' "(AUR) ${SOFTWARE_MANGOHUD}" OFF
          'timeshift' "(AUR) ${SOFTWARE_TIMESHIFT}" OFF
          'gparted' "${SOFTWARE_GPARTED}" OFF
          'gnome-disk-utility' "${SOFTWARE_GNOME_DISK_UTILITY}" OFF
          'baobab' "${SOFTWARE_BAOBAB}" OFF
          'tmux' "${SOFTWARE_TMUX}" OFF
          'ranger' "${SOFTWARE_RANGER}" OFF
          'virtualbox' "${SOFTWARE_VIRTUALBOX}" OFF
          'libvirt' "${SOFTWARE_LIBVIRT}" OFF
          'vmware-workstation' "(AUR) ${SOFTWARE_VMWARE_WORKSTATION}" OFF
          'insync' "(AUR) ${SOFTWARE_INSYNC}" OFF
          'pcloud-drive' "(AUR) ${SOFTWARE_PCLOUD_DRIVE}" OFF
          'authy' "(AUR) ${SOFTWARE_AUTHY}" OFF
          'clamav' "${SOFTWARE_CLAMAV}" OFF
          'bleachbit' "${SOFTWARE_BLEACHBIT}" OFF
        )
        ;;
    esac
    if (( category_num == 0 )); then
      if software[0]="$(dialog --no-cancel --ok-button "${OK}" --checklist \
          "\n${SELECT_SOFTWARE_MSG}" 0 0 0 "${options[@]}")"; then
        (( category_num++ ))
      fi
    elif software[category_num]="$(dialog --ok-button "${OK}" --cancel-button \
        "${BACK}" --checklist "\n${SELECT_SOFTWARE_MSG}" 0 0 0 \
        "${options[@]}")"; then
      (( category_num++ ))
    else
      (( category_num-- ))
    fi
  done
  log "Optional packages selected: $(tr <<<"${software[*]}" ' ' '\n' \
    | sort \
    | uniq \
    | tr '\n' ' ')"

  # Add selected and supplemental software to base package list (for now)
  BASE_PACKAGES+="${software[*]} "
  if grep -Eq 'lutris|bottles|playonlinux' <<<"${BASE_PACKAGES}"; then
    BASE_PACKAGES+="${WINE_PACKAGES}"
  fi
  if grep -q 'steam' <<<"${BASE_PACKAGES}"; then
    BASE_PACKAGES+='steam-native-runtime '
  fi
  if grep -q 'drascula' <<<"${BASE_PACKAGES}"; then
    AUR_PACKAGES+='drascula-audio '
  fi
  if grep -q 'kdenlive' <<<"${BASE_PACKAGES}"; then
    BASE_PACKAGES+='python-pip '
  fi
  if grep -q 'ibus' <<<"${BASE_PACKAGES}" \
      && ! grep -q 'cjk' <<<"${BASE_PACKAGES}"; then
    BASE_PACKAGES+='noto-fonts-cjk '
  fi
  if grep -q 'mangohud' <<<"${BASE_PACKAGES}"; then
    BASE_PACKAGES+='lib32-mangohud '
  fi
  if grep -q 'virtualbox' <<<"${BASE_PACKAGES}"; then
    BASE_PACKAGES+='virtualbox-host-modules-arch '
  fi
  if grep -q 'libvirt' <<<"${BASE_PACKAGES}"; then
    BASE_PACKAGES+='qemu-desktop '
  fi
  if grep -q 'insync' <<<"${BASE_PACKAGES}"; then
    case "${DESKTOP_ENV}" in
      kde-plasma) AUR_PACKAGES+='insync-dolphin ' ;;
      gnome) AUR_PACKAGES+='insync-nautilus ' ;;
      cinnamon) AUR_PACKAGES+='insync-nemo ' ;;
      xfce) AUR_PACKAGES+='insync-thunar ' ;;
    esac
  fi
  if grep -q 'timeshift' <<<"${BASE_PACKAGES}" \
      && [[ "${ROOT_FS}" == 'btrfs' ]]; then
    AUR_PACKAGES+='timeshift-autosnap '
  fi
  if grep -q 'firefox' <<<"${BASE_PACKAGES}"; then
    case "${LOCALE}" in
      ach_*) BASE_PACKAGES+='firefox-i18n-ach ' ;; # Acholi
      af_*) BASE_PACKAGES+='firefox-i18n-af ' ;; # Afrikaans
      an_*) BASE_PACKAGES+='firefox-i18n-an ' ;; # Aragonese
      ar_*) BASE_PACKAGES+='firefox-i18n-ar ' ;; # Arabic
      ast_*) BASE_PACKAGES+='firefox-i18n-ast ' ;; # Asturianu
      az_*) BASE_PACKAGES+='firefox-i18n-az ' ;; # Azerbaijani
      be_*) BASE_PACKAGES+='firefox-i18n-be ' ;; # Belarusian
      bg_*) BASE_PACKAGES+='firefox-i18n-bg ' ;; # Bulgarian
      bn_*) BASE_PACKAGES+='firefox-i18n-bn ' ;; # Bengali
      br_*) BASE_PACKAGES+='firefox-i18n-br ' ;; # Breton
      bs_*) BASE_PACKAGES+='firefox-i18n-bs ' ;; # Bosnian
      ca_*val*) BASE_PACKAGES+='firefox-i18n-ca-valencia ' ;; # Catalan (Val.)
      ca_*) BASE_PACKAGES+='firefox-i18n-ca ' ;; # Catalan
      cak_*) BASE_PACKAGES+='firefox-i18n-cak ' ;; # Maya Kaqchikel
      cs_*) BASE_PACKAGES+='firefox-i18n-cs ' ;; # Czech
      cy_*) BASE_PACKAGES+='firefox-i18n-cy ' ;; # Welsh
      da_*) BASE_PACKAGES+='firefox-i18n-da ' ;; # Danish
      de_*) BASE_PACKAGES+='firefox-i18n-de ' ;; # German
      dsb_*) BASE_PACKAGES+='firefox-i18n-dsb ' ;; # Sorbian (Lower)
      el_*) BASE_PACKAGES+='firefox-i18n-el ' ;; # Greek
      en_CA*) BASE_PACKAGES+='firefox-i18n-en-gb ' ;; # English (Canada)
      en_US*) BASE_PACKAGES+='firefox-i18n-en-us ' ;; # English (United States)
      en_*) BASE_PACKAGES+='firefox-i18n-en-gb ' ;; # English (Great Britain)
      eo_*) BASE_PACKAGES+='firefox-i18n-eo ' ;; # Esperanto
      es_AR*) BASE_PACKAGES+='firefox-i18n-es-ar ' ;; # Spanish (Argentina)
      es_CL*) BASE_PACKAGES+='firefox-i18n-es-cl ' ;; # Spanish (Chile)
      es_MX*) BASE_PACKAGES+='firefox-i18n-es-mx ' ;; # Spanish (Mexico)
      es_*) BASE_PACKAGES+='firefox-i18n-es-es ' ;; # Spanish (Spain)
      et_*) BASE_PACKAGES+='firefox-i18n-et ' ;; # Estonian
      eu_*) BASE_PACKAGES+='firefox-i18n-eu ' ;; # Basque
      fa_*) BASE_PACKAGES+='firefox-i18n-fa ' ;; # Persian
      ff_*) BASE_PACKAGES+='firefox-i18n-ff ' ;; # Fulah
      fi_*) BASE_PACKAGES+='firefox-i18n-fi ' ;; # Finnish
      fr_*) BASE_PACKAGES+='firefox-i18n-fr ' ;; # French
      fy_*) BASE_PACKAGES+='firefox-i18n-fy-nl ' ;; # Frisian
      ga_*) BASE_PACKAGES+='firefox-i18n-ga-ie ' ;; # Irish
      gd_*) BASE_PACKAGES+='firefox-i18n-gd ' ;; # Gaelic (Scottish)
      gl_*) BASE_PACKAGES+='firefox-i18n-gl ' ;; # Galician
      gn_*|gug_*) BASE_PACKAGES+='firefox-i18n-gn ' ;; # Guarani
      gu_*) BASE_PACKAGES+='firefox-i18n-gu-in ' ;; # Gujarati
      he_*) BASE_PACKAGES+='firefox-i18n-he ' ;; # Hebrew
      hi_*) BASE_PACKAGES+='firefox-i18n-hi-in ' ;; # Hindi
      hr_*) BASE_PACKAGES+='firefox-i18n-hr ' ;; # Croatian
      hsb_*) BASE_PACKAGES+='firefox-i18n-hsb ' ;; # Sorbian (Upper)
      hu_*) BASE_PACKAGES+='firefox-i18n-hu ' ;; # Hungarian
      hy_*) BASE_PACKAGES+='firefox-i18n-hy-am ' ;; # Armenian
      ia_*) BASE_PACKAGES+='firefox-i18n-ia ' ;; # Interlingua
      id_*) BASE_PACKAGES+='firefox-i18n-id ' ;; # Indonesian
      is_*) BASE_PACKAGES+='firefox-i18n-is ' ;; # Icelandic
      it_*) BASE_PACKAGES+='firefox-i18n-it ' ;; # Italian
      ja_*) BASE_PACKAGES+='firefox-i18n-ja ' ;; # Japanese
      ka_*) BASE_PACKAGES+='firefox-i18n-ka ' ;; # Georgian
      kab_*) BASE_PACKAGES+='firefox-i18n-kab ' ;; # Kabyle, Taqbaylit, etc.
      kk_*) BASE_PACKAGES+='firefox-i18n-kk ' ;; # Kazakh
      km_*) BASE_PACKAGES+='firefox-i18n-km ' ;; # Khmer
      kn_*) BASE_PACKAGES+='firefox-i18n-kn ' ;; # Kannada
      ko_*) BASE_PACKAGES+='firefox-i18n-ko ' ;; # Korean
      lij_*) BASE_PACKAGES+='firefox-i18n-lij ' ;; # Ligurian
      lt_*) BASE_PACKAGES+='firefox-i18n-lt ' ;; # Lithuanian
      lv_*) BASE_PACKAGES+='firefox-i18n-lv ' ;; # Latvian
      mk_*) BASE_PACKAGES+='firefox-i18n-mk ' ;; # Macedonian
      mr_*) BASE_PACKAGES+='firefox-i18n-mr ' ;; # Marathi
      ms_*) BASE_PACKAGES+='firefox-i18n-ms ' ;; # Malay
      my_*) BASE_PACKAGES+='firefox-i18n-my ' ;; # Burmese
      nb_*) BASE_PACKAGES+='firefox-i18n-nb-no ' ;; # Norwegian (Bokmål)
      ne_*) BASE_PACKAGES+='firefox-i18n-ne-np ' ;; # Nepali
      nl_*) BASE_PACKAGES+='firefox-i18n-nl ' ;; # Dutch
      nn_*) BASE_PACKAGES+='firefox-i18n-nn-no ' ;; # Norwegian (Nynorsk)
      oc_*) BASE_PACKAGES+='firefox-i18n-oc ' ;; # Occitan
      pa_*) BASE_PACKAGES+='firefox-i18n-pa-in ' ;; # Punjabi
      pl_*) BASE_PACKAGES+='firefox-i18n-pl ' ;; # Polish
      pt_BR*) BASE_PACKAGES+='firefox-i18n-pt-br ' ;; # Portuguese (Brazil)
      pt_*) BASE_PACKAGES+='firefox-i18n-pt-pt ' ;; # Portuguese (Portugal)
      rm_*) BASE_PACKAGES+='firefox-i18n-rm ' ;; # Romansh
      ro_*) BASE_PACKAGES+='firefox-i18n-ro ' ;; # Romanian
      ru_*) BASE_PACKAGES+='firefox-i18n-ru ' ;; # Russian
      si_*) BASE_PACKAGES+='firefox-i18n-si ' ;; # Sinhala
      sk_*) BASE_PACKAGES+='firefox-i18n-sk ' ;; # Slovak
      sl_*) BASE_PACKAGES+='firefox-i18n-sl ' ;; # Slovenian
      son_*) BASE_PACKAGES+='firefox-i18n-son ' ;; # Songhai
      sq_*) BASE_PACKAGES+='firefox-i18n-sq ' ;; # Albanien
      sr_*) BASE_PACKAGES+='firefox-i18n-sr ' ;; # Serbian
      sv_*) BASE_PACKAGES+='firefox-i18n-sv-se ' ;; # Swedish
      ta_*) BASE_PACKAGES+='firefox-i18n-ta ' ;; # Tamil
      te_*) BASE_PACKAGES+='firefox-i18n-te ' ;; # Telugu
      th_*) BASE_PACKAGES+='firefox-i18n-th ' ;; # Thai
      tl_*) BASE_PACKAGES+='firefox-i18n-tl ' ;; # Tagolog
      tr_*) BASE_PACKAGES+='firefox-i18n-tr ' ;; # Turkish
      trs_*) BASE_PACKAGES+='firefox-i18n-trs ' ;; # Chicahuaxtla Triqui
      uk_*) BASE_PACKAGES+='firefox-i18n-uk ' ;; # Ukranian
      ur_*) BASE_PACKAGES+='firefox-i18n-ur ' ;; # Urdu
      uz_*) BASE_PACKAGES+='firefox-i18n-uz ' ;; # Uzbek
      vi_*) BASE_PACKAGES+='firefox-i18n-vi ' ;; # Vietnamese
      xh_*) BASE_PACKAGES+='firefox-i18n-xh ' ;; # Xhosa
      *_CN*|zh_SG*) BASE_PACKAGES+='firefox-i18n-zh-cn ' ;; # Simplified Chinese
      zh_*|yue_*|*_TW*) BASE_PACKAGES+='firefox-i18n-zh-tw ' ;; # Trad. Chinese
    esac
  fi
}

################################################################################
# Give the user a final chance to cancel installation, then clean up the list of
# base packages, move any packages not found in official repos to the AUR list,
# and install base packages via pacstrap. If pacstrap fails, upload log file to
# termbin and present the resulting URL before exiting.
#
# Globals: TITLE, INSTALLATION_TITLE, INSTALL_CONFIRM, EXIT_CONFIRM, LOG_FILE,
#   BASE_PACKAGES, AUR_PACKAGES, ERRORS_LOGGED, PACSTRAP_ERROR_MSG, YES, NO
# Arguments: None
################################################################################
install_base() {
  TITLE="${INSTALLATION_TITLE}"
  local log_url pacstrap_list=''

  # Confirm user wants to begin installing packages
  until yesno "${INSTALL_CONFIRM}" "${YES}" "${NO}" --defaultno; do
    if yesno "${EXIT_CONFIRM}" "${YES}" "${NO}" --defaultno; then
      log "User cancelled installation (errors logged: ${ERRORS_LOGGED})"
      return_to_shell_prompt
    fi
  done

  # Ensure system clock is accurate (if done earlier, annoying messages appear)
  timedatectl set-ntp true

  # Update keyring (if out of date)
  log "Updating Arch Linux keyring..."
  dragonsay "Updating Arch Linux keyring..."
  pacman-key --init 2> >(tee -a "${LOG_FILE}")
  while ! pacman -Sy archlinux-keyring --needed --noconfirm \
      2> >(tee -a "${LOG_FILE}") && try_again "Keyring update failed"; do
    continue
  done

  # Clean and sort package lists, moving packages to AUR list as appropriate
  # (this also helps protect against future changes to package availability)
  BASE_PACKAGES="$(tr <<<"${BASE_PACKAGES}" ' ' '\n' \
    | sort \
    | uniq \
    | tr '\n' ' ')"
  for package in ${BASE_PACKAGES}; do
    if (pacman -Si "${package}" || pacman -Sg "${package}") &>/dev/null; then
      pacstrap_list+="${package} "
      echo "Package '${package}' confirmed"
    else
      AUR_PACKAGES+="${package} "
      echo "Package '${package}' not found in official repos: moved to AUR list"
    fi
  done
  log "Base package list: ${pacstrap_list}"
  AUR_PACKAGES="$(tr <<<"${AUR_PACKAGES}" ' ' '\n' | sort | uniq | tr '\n' ' ')"
  log "AUR package list: ${AUR_PACKAGES}"

  # Begin installation
  log "Installing base packages..."
  dragonsay "Installing base packages..."
  while true; do
    if pacstrap /mnt ${pacstrap_list} 2> >(tee -a "${LOG_FILE}"); then
      log "Base installation completed successfully"
      break
    elif ! try_again "Pacstrap failed"; then
      log "Uplodaing log to termbin... (errors logged: ${ERRORS_LOGGED})"
      log_url="$(nc termbin.com 9999 <"${LOG_FILE}")"
      log "Log uploaded to termbin: ${log_url}"
      message "${PACSTRAP_ERROR_MSG} ${log_url}"
      return_to_shell_prompt
    fi
  done
}

################################################################################
# Configure the freshly-installed GDL system.
#
# Globals: SYSTEM_AUTO_ENCRYPTED, BASE_PACKAGES, UEFI, ROOT_DRIVE, ROOT_PART,
#   ROOT_FS, BOOT_OR_ESP, BOOT_OR_ESP_MNT, HOME_DRIVE, BTRFS_MOUNT_OPTIONS,
#   HOME_DRIVE, HOME_FS, SWAP_SIZE, HOSTNAME, PASSWORD, SSL_KEY, LOCALE, KEYMAP,
#   TIME_ZONE, VM_TYPE, DISPLAY_MANAGER, DESKTOP_ENV
# Arguments: None
################################################################################
configure_system() {
  local pw uuid fstab='/mnt/etc/fstab' extra='/usr/share/gdl/extra' \
    grub='/mnt/etc/default/grub' grub_theme='/boot/grub/themes/gdl' \
    grub_install_command='grub-install'

  log "Configuring system..."
  dragonsay "Configuring system..."

  # Initial fstab config
  genfstab -U /mnt >>"${fstab}" && log "* Generated fstab"

  # GRUB config
  mkdir -p "/mnt${grub_theme}"
  cp -rT "${extra}/grub" "/mnt${grub_theme}"
  if (! mount | grep -q ' /mnt/boot ' && [[ "${ROOT_FS}" != 'btrfs' ]]) \
      || mount | grep -q ' /mnt/boot type [^b]'; then
    sed -i 's/GRUB_DEFAULT=0/GRUB_DEFAULT=saved/' "${grub}"
    sed -i 's/#GRUB_SAVEDEFAULT/GRUB_SAVEDEFAULT/' "${grub}"
  fi
  sed -i 's/GRUB_TIMEOUT=5/GRUB_TIMEOUT=3/' "${grub}"
  sed -i "s/GRUB_GFXM.*/GRUB_GFXMODE=1920x1080,1366x768,auto/" "${grub}"
  sed -i "s:#GRUB_COLOR_N.*:GRUB_COLOR_NORMAL=\"red/black\":" "${grub}"
  sed -i "s:#GRUB_COLOR_H.*:GRUB_COLOR_HIGHLIGHT=\"yellow/black\":" "${grub}"
  sed -i "s:#GRUB_THEME.*:GRUB_THEME=\"${grub_theme}/theme.txt\":" "${grub}"
  if "${SYSTEM_AUTO_ENCRYPTED}"; then
    uuid="$(lsblk -no UUID "/dev/${ROOT_PART}" | sed -n 1p)"
    sed -i "s!quiet!cryptdevice=UUID=${uuid}:cryptroot:allow-discards root=\
/dev/vg/lvroot transparent_hugepage=never!" "${grub}"
    sed -i "s/#GRUB_ENABLE_CRYPT.*/GRUB_ENABLE_CRYPTODISK=y/" "${grub}"
  else
    sed -i 's/quiet/transparent_hugepage=never/' "${grub}"
  fi
  if grep -q 'nvidia' <<<"${BASE_PACKAGES}"; then
    sed -i '/GRUB_CMDLINE_LINUX_DEFAULT=/s/.$/ nvidia-drm.modeset=1"/;s/" /"/' \
      "${grub}"
  fi
  if "${UEFI}"; then
    grub_install_command+=" --target=x86_64-efi --bootloader-id=GRUB \
--efi-directory=${BOOT_OR_ESP_MNT}"
  else
    grub_install_command+=" /dev/${ROOT_DRIVE}"
  fi
  while true; do
    if arch-chroot /mnt ${grub_install_command}; then
      sed -i "s:reinstallgrub=':&sudo ${grub_install_command}:" \
        "${extra}/skel/.bashrc" # for future GRUB repair (rarely needed)
      if "${UEFI}"; then
        if [[ ! -f "/mnt${BOOT_OR_ESP_MNT}/EFI/BOOT/bootx64.efi" ]]; then
          mkdir "/mnt${BOOT_OR_ESP_MNT}/EFI/BOOT"
          cp "/mnt${BOOT_OR_ESP_MNT}/EFI/GRUB/grubx64.efi" \
            "/mnt${BOOT_OR_ESP_MNT}/EFI/BOOT/bootx64.efi" # needed in some cases
        fi
        log "* Installed GRUB (UEFI)"
      else
        log "* Installed GRUB (BIOS)"
      fi
      break
    else
      try_again "GRUB installation failed" || break
    fi
  done

  # NVIDIA GPU config
  if grep -q 'nvidia' <<<"${BASE_PACKAGES}"; then
    sed -i 's/^MODULES=(/&nvidia nvidia_modeset nvidia_uvm nvidia_drm /' \
      /mnt/etc/mkinitcpio.conf
    echo -e 'options nvidia-drm modeset=1\nblacklist nouveau' \
      >/mnt/etc/modprobe.d/nvidia.conf
    sed -i 's:^FILES=(:&/etc/modprobe.d/nvidia.conf :;s/ )/)/' \
      /mnt/etc/mkinitcpio.conf
    mkdir /mnt/etc/pacman.d/hooks
    # https://wiki.archlinux.org/index.php/NVIDIA#Pacman_hook
    echo -e "[Trigger]\nOperation=Install\nOperation=Upgrade\nOperation=Remove\
\nType=Package\nTarget=nvidia\nTarget=linux\n\n[Action]\nDescription=Update \
NVIDIA module in initcpio\nDepends=mkinitcpio\nWhen=PostTransaction\n\
NeedsTargets\nExec=/bin/sh -c 'while read -r trg; do case \$trg in linux) exit \
0; esac; done; /usr/bin/mkinitcpio -P'" >/mnt/etc/pacman.d/hooks/nvidia.hook
    log "* Enabled NVIDIA DRM (Direct Rendering Manager)"
    if lspci | grep 'VGA' | grep -Eq 'Intel|ATI|AMD'; then
      echo 'GAMEMODERUNEXEC=prime-run' >>/mnt/etc/environment
      log "* Configured GameMode to always enable NVIDIA PRIME render offload"
    fi
  fi

  # Btrfs config
  if mount | grep -q 'type btrfs'; then
    sed -i 's/^MODULES=(/&btrfs /;s/ )/)/' /mnt/etc/mkinitcpio.conf \
      && log "* Configured system for Btrfs"
  fi

  # XFS config
  if mount | grep -q 'type xfs'; then
    sed -i 's/^MODULES=(/&xfs /;s/ )/)/' /mnt/etc/mkinitcpio.conf \
      && log "* Configured system for XFS"
  fi

  # NVMe config
  if mount | grep -q 'nvme'; then
    sed -i 's/^MODULES=(/&nvme /;s/ )/)/' /mnt/etc/mkinitcpio.conf \
      && log "* Configured system for NVMe"
  fi

  # Additional fstab, crypttab, and mkinitcpio config
  if "${SYSTEM_AUTO_ENCRYPTED}"; then
    # Unencrypted boot/EFI partition
    if "${UEFI}"; then
      echo "/dev/${BOOT_OR_ESP} ${BOOT_OR_ESP_MNT} vfat rw,relatime,fmask=0022,\
dmask=0022,codepage=437,iocharset=utf8,shortname=mixed,utf8,errors=remount-ro \
0 2" >"${fstab}"
    else
      echo "/dev/${BOOT_OR_ESP} ${BOOT_OR_ESP_MNT} ext4 defaults 0 2" \
        >"${fstab}"
    fi
    # Encrypted root partition
    if [[ "${ROOT_FS}" == 'btrfs' ]]; then
      echo "/dev/vg/lvroot / btrfs ${BTRFS_MOUNT_OPTIONS},subvol=@ 0 0
/dev/vg/lvroot /var/log btrfs ${BTRFS_MOUNT_OPTIONS},subvol=@var@log 0 0
/dev/vg/lvroot /var/cache btrfs ${BTRFS_MOUNT_OPTIONS},subvol=@var@cache 0 0" \
        >>"${fstab}"
      if [[ -z "${HOME_DRIVE}" ]]; then
        echo "/dev/vg/lvroot /home btrfs ${BTRFS_MOUNT_OPTIONS},subvol=@home \
0 0" >>"${fstab}"
      fi
    else
      echo "/dev/vg/lvroot / ${ROOT_FS} defaults 0 1" >>"${fstab}"
    fi
    # Encrypted home partition
    if [[ -n "${HOME_DRIVE}" ]]; then
      if [[ "${HOME_FS}" == 'btrfs' ]]; then
        echo "/dev/mapper/crypthome /home btrfs ${BTRFS_MOUNT_OPTIONS},subvol=\
@home 0 0" >>"${fstab}"
      else
        echo "/dev/mapper/crypthome /home ${HOME_FS} defaults 0 1" >>"${fstab}"
      fi
      uuid="$(lsblk -no UUID "/dev/${HOME_DRIVE}" | sed -n 1p)"
      echo "crypthome UUID=${uuid}" >>/mnt/etc/crypttab
    fi
    # Encrypted SWAP
    if (( SWAP_SIZE > 0 )); then
      echo "/dev/vg/lvswap none swap defaults 0 0" >>"${fstab}"
    fi
    # mkinitcpio
    sed -i "s/^HOOKS=.*/HOOKS=(base udev autodetect microcode modconf kms \
keyboard keymap block encrypt lvm2 filesystems fsck)/" /mnt/etc/mkinitcpio.conf
    log "* Configured system for encryption"
  else # not auto-encrypted
    sed -i "s/^HOOKS=.*/HOOKS=(base udev autodetect microcode modconf kms \
keyboard keymap block filesystems fsck)/" /mnt/etc/mkinitcpio.conf
  fi
  sed -i 's/	/ /g' "${fstab}" # remove tabs
  sed -i 's/ \+/ /g' "${fstab}" # remove extraneous spaces
  sed -Ei '/btrfs|xfs/s/0 [^0]$/0 0/' "${fstab}" # remove fsck for btrfs/xfs
  while true; do
    if arch-chroot /mnt mkinitcpio -P; then
      log "* Created new initramfs"
      break
    else
      try_again "Failed to create new initramfs" || break
    fi
  done

  # Locale config
  sed -i "/#${LOCALE}/s/#//" /mnt/etc/locale.gen
  sed -i '/#en_US.UTF-8/s/#//' /mnt/etc/locale.gen
  echo "LANG=${LOCALE}" >/mnt/etc/locale.conf
  arch-chroot /mnt locale-gen
  if [[ "${LOCALE}" =~ zh_|yue_|ja_ ]]; then
    sed -i 's/%A, %B %-e, %Y/%Y年%B%-e日/' \
      "${extra}/lightdm/lightdm-gtk-greeter.conf"
    sed -i 's/%-l:%M:%S %p, %A, %B %-e, %Y/%Y年%B%-e日 %A%p%I:%M:%S/' \
      "${extra}/xfce/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-panel.xml"
    sed -i 's/%A, %B %-e/%Y年%B%-e日/' "${extra}/skel/.config/gdl-config-script"
    sed -i 's/clock-show-weekday true/clock-show-weekday false/' \
      "${extra}/skel/.config/gdl-config-script"
  fi
  log "* Set system locale: ${LOCALE}"

  # Keyboard config
  echo "KEYMAP=${KEYMAP}" >>/mnt/etc/vconsole.conf
  echo -e "Section \"InputClass\"\nIdentifier \"system-keyboard\"\n\
MatchIsKeyboard \"on\"\nOption \"XkbLayout\" \"${KEYMAP}\"\nEndSection" \
    >/mnt/etc/X11/xorg.conf.d/00-keyboard.conf
  arch-chroot /mnt localectl set-x11-keymap "${KEYMAP}"
  log "* Set system keymap: ${KEYMAP}"

  # Time zone and hardware clock config
  ln -sf "/usr/share/zoneinfo/${TIME_ZONE}" /mnt/etc/localtime \
    && log "* Set system time zone: ${TIME_ZONE}"
  arch-chroot /mnt hwclock --systohc && log "* Generated /etc/adjtime"

  # Here be daemons...
  log "* Configuring systemd services..."

  # Package cache cleanup
  arch-chroot /mnt pacman -Q pacman-contrib &>/dev/null \
    && enable_service paccache.timer

  # VM config
  case "${VM_TYPE}" in
    qemu) enable_service qemu-guest-agent.service ;;
    oracle) enable_service vboxservice.service ;;
    vmware)
      cat /mnt/proc/version >/mnt/etc/arch-release
      enable_service vmtoolsd.service
      enable_service vmware-vmblock-fuse.service
      mkdir -pv /mnt/etc/init.d/rc{0..6}.d
      ;;
  esac

  # Network, firewall, and bluetooth config
  arch-chroot /mnt pacman -Q networkmanager &>/dev/null \
    && enable_service NetworkManager.service
  if arch-chroot /mnt pacman -Q ufw &>/dev/null; then
    arch-chroot /mnt ufw enable
    enable_service ufw.service
    if arch-chroot /mnt pacman -Q kdeconnect &>/dev/null; then
      arch-chroot /mnt ufw allow 1714:1764/udp
      arch-chroot /mnt ufw allow 1714:1764/tcp
      log "  - Opened UFW ports for KDE Connect"
    fi
  fi
  if lsusb | grep -qi 'bluetooth' || dmesg | grep -qi 'bluetooth'; then
    enable_service bluetooth.service
  fi

  # Display manager (login manager) config
  [[ -d /mnt/etc/lightdm ]] && cp -rT "${extra}/lightdm" /mnt/etc/lightdm
  if [[ "${DESKTOP_ENV}" == 'kde-plasma' ]]; then
    mkdir /mnt/etc/sddm.conf.d
    echo -e "[Autologin]\nRelogin=false\nSession=\nUser=\n\n[General]\n\
HaltCommand=/usr/bin/systemctl poweroff\nRebootCommand=/usr/bin/systemctl \
reboot\n\n[Theme]\nCurrent=breeze\n\n[Users]\nMaximumUid=60513\n\
MinimumUid=1000" >/mnt/etc/sddm.conf.d/kde_settings.conf
    sed -i "s:background.*:background=/usr/share/backgrounds/gdl/\
gds-drake-dark-1920x1080.jpg:" /mnt/usr/share/sddm/themes/breeze/theme.conf
    [[ -f /mnt/etc/lightdm/lightdm-gtk-greeter.conf ]] \
      && sed -i 's/Matcha-dark-aliz/Breeze-Dark/' \
        /mnt/etc/lightdm/lightdm-gtk-greeter.conf
  fi
  enable_service "${DISPLAY_MANAGER}.service"

  # CPU, temperature, and power management
  arch-chroot /mnt pacman -Q cpupower &>/dev/null \
    && enable_service cpupower.service
  arch-chroot /mnt pacman -Q thermald &>/dev/null \
    && enable_service thermald.service
  arch-chroot /mnt pacman -Q tlp &>/dev/null && enable_service tlp.service

  # Kernel module cleanup
  arch-chroot /mnt pacman -Q kernel-modules-hook &>/dev/null \
    && enable_service linux-modules-cleanup.service

  # Weekly TRIM for all drives that support 'discard'
  enable_service fstrim.timer

  # CUPS printing system
  arch-chroot /mnt pacman -Q cups &>/dev/null && enable_service cups.socket

  # Avahi (for discovering printers and other devices/services)
  arch-chroot /mnt pacman -Q avahi &>/dev/null \
    && enable_service avahi-daemon.service
  sed -i 's/hosts: mymachines/& mdns_minimal [NOTFOUND=return]/' \
    /mnt/etc/nsswitch.conf

  # GRUB Btrfs snapshot support
  arch-chroot /mnt pacman -Q grub-btrfs &>/dev/null \
    && enable_service grub-btrfsd.service

  # Desktop config
  cp -rT "${extra}/${DESKTOP_ENV}" "${extra}/skel"
  case "${DESKTOP_ENV}" in
    kde-plasma)
      arch-chroot /mnt pacman -S appstream --noconfirm # fix Discover issue
      sed -i 's/Opacity=.*/Opacity=0.84/' /mnt/usr/share/konsole/*.colorscheme
      echo 'Opacity=0.84' >>/mnt/usr/share/konsole/Linux.colorscheme
      ;;
    xfce) mv "${extra}/skel/toggle-touchpad" /mnt/usr/local/bin ;;
  esac
  if arch-chroot /mnt pacman -Q ibus &>/dev/null; then
    echo -e "export GTK_IM_MODULE=ibus\nexport QT_IM_MODULE=ibus\nexport \
XMODIFIERS=@im=ibus\nibus-daemon -drxR" >>"${extra}/skel/.xprofile"
    if [[ "${DESKTOP_ENV}" == 'kde-plasma' ]]; then
      sed -i 's:-drxR:& --panel=/usr/lib/kimpanel-ibus-panel:' \
        "${extra}/skel/.xprofile"
      echo -e "\n[Containments][2][Applets][25]\nimmutability=1\n\
plugin=org.kde.plasma.kimpanel" \
        >>"${extra}/skel/.config/plasma-org.kde.plasma.desktop-appletsrc"
      sed -i 's/;6;/&25;/' \
        "${extra}/skel/.config/plasma-org.kde.plasma.desktop-appletsrc"
    fi
  fi
  mkdir -p /mnt/usr/share/backgrounds/gdl
  cp -rT "${extra}/wallpapers" /mnt/usr/share/backgrounds/gdl
  cp -rT "${extra}/icons" /mnt/usr/share/pixmaps
  cp -rT "${extra}/skel" /mnt/etc/skel
  log "* Configured DE and default user settings"

  # Pacman config
  [[ -f /mnt/var/lib/pacman/db.lck ]] && rm /mnt/var/lib/pacman/db.lck
  sed -i 's/#Color/Color\nILoveCandy/' /mnt/etc/pacman.conf
  sed -i 's/#VerbosePkgLists/VerbosePkgLists/' /mnt/etc/pacman.conf
  sed -i 's/#ParallelDownloads/ParallelDownloads/' /mnt/etc/pacman.conf
  sed -zi 's/#\[multilib]\n#Include/[multilib]\nInclude/' /mnt/etc/pacman.conf
  log "* Configured pacman"

  # Hostname config
  echo "${HOSTNAME}" >/mnt/etc/hostname
  echo -e "127.0.0.1 localhost\n::1 localhost\n127.0.1.1 \
${HOSTNAME}.localdomain ${HOSTNAME}" >>/mnt/etc/hosts
  log "* Set system hostname: ${HOSTNAME}"

  # Set root user password
  pw="$(echo "${PASSWORD}" | openssl enc -aes-256-cbc -a -d -salt -pbkdf2 \
    -iter 1000 -pass "pass:${SSL_KEY}")"
  printf "%s\n%s" "${pw}" "${pw}" | arch-chroot /mnt passwd root
  unset pw

  # Enable SysRq keyboard shortcuts
  echo -e 'kernel.sysrq=1' >/mnt/etc/sysctl.d/99-sysctl.conf

  # Ensure proper MIDI support for certain media players
  ln -s libfluidsynth.so.3 /mnt/usr/lib/libfluidsynth.so.2
  mkdir -p /mnt/usr/share/sounds/sf2
  ln -s /usr/share/soundfonts/FluidR3_GM.sf2 /mnt/usr/share/sounds/sf2/

  # Add a group for GameMode to ensure it can "renice" processes
  arch-chroot /mnt groupadd -g 2000 gamemode
}

################################################################################
# Enable a given systemd service within the newly-installed system.
#
# Arguments: Name of the desired systemd service.
################################################################################
enable_service() {
  if [[ -n "$1" ]] && arch-chroot /mnt systemctl enable "$1"; then
    log "  - Enabled '$1'"
  else
    log_error "Failed to enable '$1'"
  fi
}

################################################################################
# Install AUR helper 'yay' (yay-bin) and use it to install AUR packages. If a
# package fails, provide the option to try again (or manually install in the
# case of the oft problematic and now missing Breeze Amber cursor theme).
#
# Globals: AUR_PACKAGES, ROOT_FS, ROOT_PART, SYSTEM_AUTO_ENCRYPTED, DESKTOP_ENV
# Arguments: None
################################################################################
install_aur_software() {
  local pw uuid package failed_packages=''

  # Ensure superfluous 'debug' packages are not installed by 'yay'
  sed -i '/^OPTIONS=/s/ debug/ !debug/' /mnt/etc/makepkg.conf

  # Create a temporary user for installing and using 'yay'
  log "Installing AUR helper 'yay' (yay-bin)..."
  dragonsay "Setting up AUR support..."
  pw="$(</dev/urandom tr -dc "@#*%&_A-Z-a-z-0-9" | head -c16)"
  mkdir /mnt/yaytemp
  chmod 777 /mnt/yaytemp
  arch-chroot /mnt useradd -rNM -d /yaytemp -s /usr/bin/nologin yaybuilder
  arch-chroot /mnt sh -c "echo -e '${pw}\n${pw}\n' | passwd yaybuilder"
  echo 'yaybuilder ALL=(ALL:ALL) NOPASSWD: ALL
root ALL=(yaybuilder) NOPASSWD: ALL' >/mnt/etc/sudoers.d/yaybuilder

  # Install 'yay'
  while true; do
    if arch-chroot /mnt sh -c "cd /yaytemp \
        && sudo -u yaybuilder git clone https://aur.archlinux.org/yay-bin.git \
        && cd yay-bin \
        && sudo -u yaybuilder makepkg -si --noconfirm"; then
      log "Installing AUR packages..."
      break
    elif ! try_again "Failed to install AUR helper 'yay'"; then
      AUR_PACKAGES=''
      break
    fi
  done

  # Install AUR packages
  while [[ -n "${AUR_PACKAGES}" ]]; do
    failed_packages=''
    for package in ${AUR_PACKAGES}; do
      dragonsay "Installing ${package}..."
      if (! arch-chroot /mnt sudo -u yaybuilder yay -Si "${package}" \
            && ! arch-chroot /mnt sudo -u yaybuilder yay -Sg "${package}") \
          || ! arch-chroot /mnt sudo -u yaybuilder yay -Syu "${package}" \
            --needed --noconfirm; then
        [[ "${package}" =~ ^breeze-amber ]] || failed_packages+="${package} "
      else
        log "* Installed '${package}'"
      fi
    done
    if [[ -n "${failed_packages}" ]]; then
      try_again "$(wc -w <<<"${failed_packages}") package(s) failed to \
install: ${failed_packages}" || break
    fi
    AUR_PACKAGES="${failed_packages}"
  done

  # Configure Timeshift (if applicable)
  if arch-chroot /mnt pacman -Q timeshift &>/dev/null; then
    log "* Configuring Timeshift..."
    enable_service cronie.service
    if [[ "${ROOT_FS}" == 'btrfs' ]]; then
      sed -i 's!/.snapshots!--timeshift-auto!' \
        /mnt/usr/lib/systemd/system/grub-btrfsd.service
      cp /mnt/etc/timeshift/default.json /mnt/etc/timeshift/timeshift.json
      sed -i 's/"do_first_run" : "true"/"do_first_run" : "false"/' \
        /mnt/etc/timeshift/timeshift.json
      sed -i "s/\"btrfs_mode\" : \"false\",/\"btrfs_mode\" : \"true\",\n  \
\"btrfs_use_qgroup\" : \"true\",\n  \"date_format\" : \"%Y-%m-%d %H:%M:%S\",/" \
        /mnt/etc/timeshift/timeshift.json
      sed -i 's/"schedule_daily" : "false"/"schedule_daily" : "true"/' \
        /mnt/etc/timeshift/timeshift.json
      sed -i 's/"schedule_hourly" : "false"/"schedule_hourly" : "true"/' \
        /mnt/etc/timeshift/timeshift.json
      sed -i 's/"schedule_boot" : "false"/"schedule_boot" : "true"/' \
        /mnt/etc/timeshift/timeshift.json
      uuid="$(lsblk -no UUID "/dev/${ROOT_PART}" | sed -n 1p)"
      if "${SYSTEM_AUTO_ENCRYPTED}"; then
        sed -i "s/parent_device_uuid.*/parent_device_uuid\" : \"${uuid}\",/" \
          /mnt/etc/timeshift/timeshift.json
        uuid="$(lsblk -no UUID /dev/vg/lvroot | sed -n 2p)"
      fi
      sed -i "s/backup_device_uuid.*/backup_device_uuid\" : \"${uuid}\",/" \
        /mnt/etc/timeshift/timeshift.json
      arch-chroot /mnt timeshift --list # to complete Timeshift setup
      log "  - Backup device UUID set for Timeshift"
    fi
  fi
  if arch-chroot /mnt pacman -Q timeshift-autosnap &>/dev/null; then
    sed -i 's/snapshotDescription=.*/snapshotDescription=auto/' \
      /mnt/etc/timeshift-autosnap.conf
  fi

  # Provide cursor theme (if missing), then log failed packages
  if ! arch-chroot /mnt pacman -Q breeze-amber-cursor-theme &>/dev/null; then
    tar xf /usr/share/gdl/extra/breeze-amber.tar.xz -C /mnt/usr/share/icons \
      && log "* Breeze Amber cursor theme added manually"
  fi
  [[ -n "${failed_packages}" ]] && log "Failed package(s): ${failed_packages}"

  # Additional KDE Plasma config
  if [[ "${DESKTOP_ENV}" == 'kde-plasma' ]]; then
    sed -i 's/Papirus-Maia/BeautyLine/' "/mnt/usr/share/plasma/\
look-and-feel/com.gitlab.cscs.matchama/contents/defaults"
    sed -i 's/Papirus-Dark-Maia/BeautyLine/' "/mnt/usr/share/plasma/\
look-and-feel/com.gitlab.cscs.matchama-dark/contents/defaults"
  fi

  # Clean things up
  log "Cleaning up..."
  arch-chroot /mnt sudo -u yaybuilder yay -Yc --noconfirm
  arch-chroot /mnt userdel -f yaybuilder
  rm /mnt/etc/passwd- /mnt/etc/sudoers.d/yaybuilder
  rm -r /mnt/yaytemp
  arch-chroot /mnt fc-cache -f # (re)build font information cache files

  # Update GRUB config
  while true; do
    if arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg; then
      log "GRUB configuration updated"
      break
    else
      try_again "Failed to update GRUB configuration" || break
    fi
  done
}

################################################################################
# Add the previously-defined user to the newly-installed system.
#
# Globals: USERNAME, FULL_NAME, PASSWORD, SSL_KEY, DESKTOP_ENV
# Arguments: None
# Returns: Number of errors detected.
################################################################################
add_user() {
  local pw

  dragonsay "Adding user '${USERNAME}'..."
  if [[ -z "${FULL_NAME}" ]] && ! arch-chroot /mnt useradd -mG \
      audio,network,power,storage,optical,gamemode -s /bin/bash \
      "${USERNAME}"; then
    log_error "Failed to add user: ${USERNAME}"
    return 1
  elif [[ -n "${FULL_NAME}" ]] && ! arch-chroot /mnt useradd -mG \
      audio,network,power,storage,optical,gamemode -c "${FULL_NAME}" -s \
      /bin/bash "${USERNAME}"; then
    log_error "Failed to add user: ${USERNAME} (${FULL_NAME})"
    return 1
  fi

  # Set password
  pw="$(echo "${PASSWORD}" | openssl enc -aes-256-cbc -a -d -salt -pbkdf2 \
    -iter 1000 -pass "pass:${SSL_KEY}")"
  if ! printf "%s\n%s" "${pw}" "${pw}" \
      | arch-chroot /mnt passwd "${USERNAME}"; then
    unset pw
    log_error "Failed to set password for ${USERNAME}"
    return 1
  fi
  unset pw

  # Allow privilege elevation via sudo
  sed -i '/%wheel ALL=(ALL:ALL) ALL/s/^# //' /mnt/etc/sudoers
  arch-chroot /mnt usermod -aG wheel "${USERNAME}"

  # Provide default user image
  cp /mnt/etc/skel/.face "/mnt/var/lib/AccountsService/icons/${USERNAME}"
  echo -e "[User]\nIcon=/var/lib/AccountsService/icons/${USERNAME}\n\
SystemAccount=false" >"/mnt/var/lib/AccountsService/users/${USERNAME}"

  log "User added: ${USERNAME}"

  # Let GNOME Keyring act as wrapper around user's ssh-agent
  if [[ "${DESKTOP_ENV}" != 'kde-plasma' ]]; then
    if arch-chroot /mnt sudo -u "${USERNAME}" systemctl enable --user \
        gcr-ssh-agent.socket; then
      log "Enabled 'gcr-ssh-agent.socket' for user: ${USERNAME}"
    else
      log_error "Failed to enable 'gcr-ssh-agent.socket' for user: ${USERNAME}"
    fi
  fi
}

################################################################################
# Add final details to the log file, then copy it to the new user's home.
#
# Globals: LOG_FILE, ERRORS_LOGGED, USERNAME
# Arguments: None
################################################################################
finalize_and_copy_log() {
  log "GDL installation complete (errors logged: ${ERRORS_LOGGED})"
  arch-chroot /mnt df -Th | log
  cp "${LOG_FILE}" "/mnt/home/${USERNAME}"
  chown 1000:1000 "/mnt/home/${USERNAME}/gdl.log"
}

################################################################################
# Custom 'dialog' function. Unless extraneous text should be reduced, a
# backtitle is included which may also show remaining battery capacity. Output
# is directed to STDOUT ('dialog' defaults to STDERR otherwise).
#
# Globals: TITLE, BACKTITLE, DEFAULT_BACKTITLE, BATTERY, REDUCE_EXTRANEOUS_TEXT
# Arguments: The desired text plus additional 'dialog' options.
################################################################################
dialog() {
  sleep 0.1 # to help avoid accidental keyboard input carryover
  if "${REDUCE_EXTRANEOUS_TEXT}"; then
    /usr/bin/dialog --stdout --colors --title " ${TITLE} " "$@"
  else
    BACKTITLE="${DEFAULT_BACKTITLE}"
    if [[ -n "${BATTERY}" ]]; then
      BACKTITLE+=" | Battery: $(cat "${BATTERY}/capacity")%"
    fi
    /usr/bin/dialog --stdout --colors --backtitle "${BACKTITLE}" --title \
      " ${TITLE} " "$@"
  fi
}

################################################################################
# Present a message in an 'ok' dialog box.
#
# Globals: OK
# Arguments: The desired message text.
################################################################################
message() {
  dialog --ok-button "${OK}" --msgbox "\n$1" 0 0
}

################################################################################
# Present a message in a 'yes/no' dialog box.
#
# Arguments: The desired body text plus 'yes' and 'no' button texts. If a fourth
#   argument is provided, the dialog box uses '--defaultno'.
# Returns: Dialog exit status.
################################################################################
yesno() {
  local body="$1" yes_button="$2" no_button="$3"

  if (( $# == 4 )); then
    dialog --defaultno --yes-label "${yes_button}" --no-label "${no_button}" \
      --yesno "\n${body}" 0 0
  else
    dialog --yes-label "${yes_button}" --no-label "${no_button}" --yesno \
      "\n${body}" 0 0
  fi

  return $?
}

################################################################################
# Present a dialog box with a "gauge" (loading bar) that gradually fills up as
# background processes are completed.
#
# Arguments: The desired text to display above the loading bar.
################################################################################
load_bar() {
  {
    local -i progress=1

    # shellcheck disable=SC2009
    while [[ -n $! ]] && ps | grep -q $!; do
      sleep 0.1
      echo $progress
      if (( progress < 100 )); then
        (( ++progress ))
      fi
    done
    echo 100
    sleep 0.6 # provide a bit more time for reading text before moving on
  } | dialog --gauge "\n$1" 9 79 0
}

################################################################################
# Present (and log) a given error message and prompt the user to choose whether
# to attempt the task again. This is used in "emergencies" during installation,
# such as when a package fails to install (internet issues, etc.).
#
# Globals: BOLD_RED, WHITE, COLOR_RESET
# Arguments: A description of the error.
# Returns: '0' if the user wants to try again, '1' otherwise.
################################################################################
try_again() {
  local try

  log_error "$1"
  echo -e "${BOLD_RED}ERROR: ${WHITE}$1${COLOR_RESET}"
  while true; do
    echo -en "Try again? (y/n) " && read -r try
    if [[ "${try}" =~ ^[Yy] ]]; then
      log "Trying again..."
      return 0
    elif [[ "${try}" =~ ^[Nn] ]]; then
      log "Giving up..."
      return 1
    fi
  done
}

################################################################################
# Present a message as if spoken by an ASCII dragon via 'cowsay' (or simply echo
# the message if extraneous text should be reduced).
#
# Globals: REDUCE_EXTRANEOUS_TEXT, ERRORS_LOGGED
# Arguments: The text to be presented. A second argument of '--check-errors'
#   compels the dragon to attack an ASCII cow if errors are detected.
################################################################################
dragonsay() {
  sleep 0.6 # provide a bit more time for reading previous text
  clear
  if "${REDUCE_EXTRANEOUS_TEXT}"; then
    echo -e "$1\n"
  elif [[ "$2" == '--check-errors' ]] && (( ERRORS_LOGGED > 0 )); then
    cowsay -f dragon-and-cow "$1"
  else
    cowsay -f dragon "$1"
  fi
  sleep 0.6 # provide a bit more time for reading current text
}

################################################################################
# Append a given string (or stdin) to the log file.
#
# Globals: LOG_FILE
# Arguments: A string of text (or piped command output).
################################################################################
log() {
  local output

  if [[ -n "$1" ]]; then # manual logging
    echo "[$(date '+%H:%M:%S')]: $1" >>"${LOG_FILE}"
  else # stdin
    echo >>"${LOG_FILE}" # add white space
    while read -r output; do
      echo "${output}" >>"${LOG_FILE}"
    done
    echo >>"${LOG_FILE}" # add white space
  fi
}

################################################################################
# Append custom 'lsblk' output to the log file.
#
# Arguments: None
################################################################################
log_lsblk() {
  lsblk -o NAME,SIZE,TYPE,MOUNTPOINTS,FSTYPE,FSVER,FSUSE% \
    | grep -v '/run/archiso/' \
    | log
}

################################################################################
# Append an error message to the log file and increment the error tally.
#
# Globals: ERRORS_LOGGED
# Arguments: A string containing a description of the error.
################################################################################
log_error() {
  log "ERROR: $1"
  (( ++ERRORS_LOGGED ))
}

################################################################################
# Facilitate installation of Golden Drake Linux.
#
# Globals: ABOUT_GDL_TITLE, ABOUT_GDL_MSG, OK, INSTALL_COMPLETE_MSG,
#   INSTALL_COMPLETE_HELP, ERRORS_LOGGED
# Arguments: None
# Returns: Number of errors logged during this run of the installer.
################################################################################
main() {
  initialize
  set_installer_language
  set_keymap
  TITLE="${ABOUT_GDL_TITLE}"
  dialog --ok-button "${OK}" --msgbox "\n${ABOUT_GDL_MSG}" 23 80
  check_internet_connection
  set_locale
  set_time_zone
  prepare_drives
  set_hostname
  set_user
  prepare_base
  select_additional_software
  install_base
  configure_system
  install_aur_software
  add_user
  finalize_and_copy_log
  dragonsay "${INSTALL_COMPLETE_MSG}"
  echo -e "${INSTALL_COMPLETE_HELP}"

  return "${ERRORS_LOGGED}"
}

main
