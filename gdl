#!/bin/bash
#
# Installer script for Golden Drake Linux (GDL): Arch for gaming and game dev!
#
# Copyright (C) 2020-2025 Golden Drake Studios: goldendrakestudios.com
# Forked originally from the Anarchy installer: anarchyinstaller.gitlab.io
#
# shellcheck disable=SC2076,SC2086

# shellcheck source=gdl.conf
source /etc/gdl.conf || exit 1
# shellcheck source=lang/english.conf
source "${LANG_FILE}" || exit 1

################################################################################
# Initialize installer. If this is the script's first (automatic) run, create
# the log file (by posting its first log message), start the network manager,
# configure pacman, and enlarge the console font if a HiDPI display is detected,
# then return the user to the command line so they can run other commands before
# (or instead of) launching the install process. Otherwise (i.e., if the log
# file already exists), prepare for installation by evaluating the hardware
# environment, setting a 'force_quit' trap, etc.
#
# Globals: GDL_VERSION, LOG_FILE, REDUCE_EXTRANEOUS_TEXT, RAM, BATTERY, VM_TYPE,
#   GPU_CHIPSET, DEFAULT_GPU_DRIVER, BASE_PACKAGES, MISC_PACKAGES, IGPU_PACKAGES
# Arguments: None
################################################################################
initialize() {
  if [[ ! -f "${LOG_FILE}" ]]; then
    log "Initializing GDL installer v${GDL_VERSION}"
    systemctl start NetworkManager.service
    sed -i '/#Parallel/s/#// ; s/#Color/Color\nILoveCandy/' /etc/pacman.conf
    sed -zi 's/#\[multilib]\n#Include/[multilib]\nInclude/' /etc/pacman.conf
    (( $(awk -F , '{print $1}' /sys/class/graphics/fb0/virtual_size) > 1920 )) \
      && setfont ter-v32n # large font for high-resolution screens
    [[ -d /tmp/gdl ]] || mkdir /tmp/gdl
    return_to_shell_prompt
  elif (( $(wc -l "${LOG_FILE}" | awk '{print $1}') > 1 )); then
    echo >>"${LOG_FILE}" # add white space
    log "Relaunching installer..."
  fi
  trap force_quit SIGINT # call 'force_quit' when Ctrl+C is pressed
  set -o pipefail # ensure $? remembers failures from piped commands
  if (( $(tput lines) < 25 )) || grep -q 'accessibility=' /proc/cmdline; then
    REDUCE_EXTRANEOUS_TEXT='true'
  fi
  if [[ -n "${BATTERY}" ]]; then
    BASE_PACKAGES+="${MISC_PACKAGES[battery]}"
    log "Battery: ${BATTERY} ($(cat "${BATTERY}/capacity")%)"
  fi
  if [[ "${VM_TYPE}" == 'none' ]]; then
    if lspci | grep 'VGA' | grep -q 'Intel'; then
      GPU_CHIPSET='Intel'
      DEFAULT_GPU_DRIVER='xf86-video-intel'
      BASE_PACKAGES+="${IGPU_PACKAGES[intel]}" # iGPU
    fi
    if lspci | grep 'VGA' | grep -Eq 'ATI|AMD'; then
      GPU_CHIPSET='AMD/ATI'
      DEFAULT_GPU_DRIVER='xf86-video-amdgpu'
      BASE_PACKAGES+="${IGPU_PACKAGES[amd]}" # possibly iGPU
    fi
    if lspci | grep 'VGA' | grep -iq 'nvidia'; then
      GPU_CHIPSET='NVIDIA'
      DEFAULT_GPU_DRIVER='nvidia-dkms'
    fi
    log "Graphics chipset: ${GPU_CHIPSET}"
  else
    log "VM environment: ${VM_TYPE}"
    [[ "${VM_TYPE}" =~ qemu|oracle|vmware ]] || VM_TYPE='other'
  fi
  RAM=$(( $(grep MemTotal /proc/meminfo | awk '{print $2}') / 1024 ))
  log "Memory: ${RAM} MiB RAM"
}

################################################################################
# Return the user to the command line with a welcome message plus help text
# telling them how to (a) relaunch the installer, (b) read ArchWiki articles
# offline in the terminal, (c) reboot, or (d) shut down.
#
# Globals: SHELL_PROMPT_WELCOME, SHELL_PROMPT_HELP, ERRORS_LOGGED
# Arguments: None
################################################################################
return_to_shell_prompt() {
  dragonsay "${SHELL_PROMPT_WELCOME}" --check-errors
  echo -e "${SHELL_PROMPT_HELP}"
  exit "${ERRORS_LOGGED}"
}

################################################################################
# Handle a sudden exit caused by the user pressing Ctrl+C.
#
# Globals: TITLE, FORCE_QUIT_TITLE, FORCE_QUIT_MSG, ERRORS_LOGGED, EXIT_CONFIRM,
#   YES, NO
# Arguments: None
################################################################################
force_quit() {
  TITLE="${FORCE_QUIT_TITLE}"
  if yesno "${EXIT_CONFIRM}" "${YES}" "${NO}" --defaultno; then
    log "User pressed Ctrl+C and cancelled installation (errors logged: \
${ERRORS_LOGGED})"
    message "${FORCE_QUIT_MSG}"
    return_to_shell_prompt
  else
    log "User pressed Ctrl+C, but then continued installation"
  fi
}

################################################################################
# Present the language menu (for the installer, not the soon-to-be-installed
# system: its language is determined by 'set_locale'). If the associated
# language file differs from the previously-sourced language file, source it to
# update all language-specific globals and edit gdl.conf to ensure the same
# language file is sourced again if the installer is closed and relaunched.
#
# Globals: TITLE, SET_LANG_TITLE, LANG_FILE, SET_LANG_MSG, ERRORS_LOGGED,
#   BOLD_RED, COLOR_RESET
# Arguments: None
################################################################################
set_installer_language() {
  TITLE="${SET_LANG_TITLE}"
  local language prev_lang_file="${LANG_FILE}"

  until language="$(dialog --no-cancel --menu "\n${SET_LANG_MSG}" 20 60 10 \
      'English' 'English' \
      'Bulgarian' 'Български' \
      'Dutch' 'Nederlands' \
      'French' 'Français' \
      'German' 'Deutsch' \
      'Greek' 'Ελληνικά' \
      'Hungarian' 'Magyar' \
      'Indonesian' 'bahasa Indonesia' \
      'Italian' 'Italiano' \
      'Latvian' 'Latviešu' \
      'Lithuanian' 'Lietuvių' \
      'Polish' 'Polski' \
      'Portuguese' 'Português' \
      'Portuguese-Brazil' 'Português do Brasil' \
      'Romanian' 'Română' \
      'Russian' 'Русский' \
      'Spanish' 'Español' \
      'Swedish' 'Svenska')"; do
    continue
  done
  LANG_FILE="/usr/share/gdl/lang/${language@L}.conf"
  if [[ "${LANG_FILE}" != "${prev_lang_file}" ]]; then
    if source "${LANG_FILE}"; then
      sed -i "s:^LANG_FILE=.*:LANG_FILE='${LANG_FILE}':" /etc/gdl.conf
    else
      log_error "Language file '${LANG_FILE}' not found"
      log "Exiting installer (errors logged: ${ERRORS_LOGGED})"
      echo -e "${BOLD_RED}ERROR:${COLOR_RESET} No file found for '${language}'"
      exit "${ERRORS_LOGGED}"
    fi
  fi
  log "Installer language: ${language}"
}

################################################################################
# Present the keymap menu.
#
# Globals: TITLE, SET_KEYMAP_TITLE, KEYMAP, SET_KEYMAP_MSG, OTHER, OK, BACK
# Arguments: None
################################################################################
set_keymap() {
  TITLE="${SET_KEYMAP_TITLE}"
  local keymap_list
  keymap_list="$(find /usr/share/kbd/keymaps -type f \
    | sed -n -e 's!^.*/!!p' \
    | grep '.map.gz' \
    | sed 's/.map.gz//g' \
    | sed 's/$/ ->/g' \
    | sort)"

  while true; do
    if KEYMAP="$(dialog --no-cancel --ok-button "${OK}" --menu \
        "\n${SET_KEYMAP_MSG}" 18 60 10 \
        'us' 'United States' \
        'uk' 'United Kingdom' \
        'sv' 'Swedish' \
        'slovene' 'Slovenian' \
        'ru' 'Russian' \
        'ro' 'Romanian' \
        'pt-latin9' 'Portugal' \
        'it' 'Italian' \
        'hu' 'Hungarian' \
        'fr' 'French' \
        'es' 'Spanish' \
        'el' 'Greek' \
        'de' 'German' \
        "${OTHER}" '->')"; then
      if [[ "${KEYMAP}" != "${OTHER}" ]] \
          || KEYMAP="$(dialog --ok-button "${OK}" --cancel-button "${BACK}" \
            --menu "\n${SET_KEYMAP_MSG}" 19 60 10 ${keymap_list})"; then
        break
      fi
    fi
  done
  localectl set-keymap "${KEYMAP}"
  loadkeys "${KEYMAP}"
  log "Keymap: ${KEYMAP}"
}

################################################################################
# Check for an internet connection. If not found, attempt to auto-connect to
# Wi-Fi (if an SSID is provided) or present options via 'nmtui'.
#
# Globals: WIFI_SSID, WIFI_PASSWORD
# Arguments: None
################################################################################
check_internet_connection() {
  until nc -zw 1 1.1.1.1 443 &>/dev/null; do
    log "Internet connection not yet established..."
    if ip address | grep -Eq 'wlp|wlo|wlan' \
        && [[ -n "${WIFI_SSID}" ]] \
        && nmcli dev wifi connect "${WIFI_SSID}" password \
          "${WIFI_PASSWORD}"; then
      log "* Using nmcli..."
    else
      log "* Using nmtui..."
      nmtui
    fi
  done
  log "Internet connection established"
}

################################################################################
# Present the locale menu.
#
# Globals: TITLE, SET_LOCALE_TITLE, LOCALE, SET_LOCALE_MSG, OTHER, OK, BACK
# Arguments: None
################################################################################
set_locale() {
  TITLE="${SET_LOCALE_TITLE}"
  local locale_list
  locale_list="$(grep -E "^#?[a-z].*UTF-8" /etc/locale.gen \
    | sed 's/#//' \
    | awk '{print $1" ->"}')"

  while true; do
    if LOCALE="$(dialog --no-cancel --ok-button "${OK}" --menu \
        "\n${SET_LOCALE_MSG}" 18 60 10 \
        'bg_BG.UTF-8' 'Bulgarian (Bulgaria)' \
        'de_DE.UTF-8' 'German (Germany)' \
        'el_GR.UTF-8' 'Greek (Greece)' \
        'en_AU.UTF-8' 'English (Australia)' \
        'en_CA.UTF-8' 'English (Canada)' \
        'en_GB.UTF-8' 'English (UK)' \
        'en_US.UTF-8' 'English (US)' \
        'es_ES.UTF-8' 'Spanish (Spain)' \
        'es_MX.UTF-8' 'Spanish (Mexico)' \
        'fr_FR.UTF-8' 'French (France)' \
        'hu_HU.UTF-8' 'Hungarian (Hungary)' \
        'id_ID.UTF-8' 'Indonesian (Indonesia)' \
        'it_IT.UTF-8' 'Italian (Italy)' \
        'ja_JP.UTF-8' 'Japanese (Japan)' \
        'ko_KR.UTF-8' 'Korean (Korea)' \
        'lt_LT.UTF-8' 'Lithuanian (Lithuania)' \
        'lv_LV.UTF-8' 'Latvian (Latvia)' \
        'nl_NL.UTF-8' 'Dutch (Netherlands)' \
        'pl_PL.UTF-8' 'Polish (Poland)' \
        'pt_BR.UTF-8' 'Portuguese (Brazil)' \
        'pt_PT.UTF-8' 'Portuguese (Portugal)' \
        'ro_RO.UTF-8' 'Romanian (Romania)' \
        'ru_RU.UTF-8' 'Russian (Russia)' \
        'sv_SE.UTF-8' 'Swedish (Sweden)' \
        'zh_CN.UTF-8' 'Chinese (China)' \
        'zh_HK.UTF-8' 'Chinese (Hong Kong)' \
        'zh_SG.UTF-8' 'Chinese (Singapore)' \
        'zh_TW.UTF-8' 'Chinese (Taiwan)' \
        "${OTHER}" '->')"; then
      if [[ "${LOCALE}" != "${OTHER}" ]] \
          || LOCALE="$(dialog --ok-button "${OK}" --cancel-button "${BACK}" \
            --menu "\n${SET_LOCALE_MSG}" 19 60 10 ${locale_list})"; then
        break
      fi
    fi
  done
  log "Locale: ${LOCALE}"
}

################################################################################
# Present the time zone menu.
#
# Globals: TITLE, SET_TIME_ZONE_TITLE, TIME_ZONE, SET_TIME_ZONE_MSG, OK, BACK
# Arguments: None
################################################################################
set_time_zone() {
  TITLE="${SET_TIME_ZONE_TITLE}"
  local zonelist sublist subzone subsubzone
  zonelist="$(find /usr/share/zoneinfo -maxdepth 1 \
    | sed -n -e 's!^.*/!!p' \
    | grep -Ev 'posix|posixrules|right|zoneinfo|.*tab|W-SU|WET|MST7MDT|CST6CDT'\
    | sort \
    | sed 's/$/ ->/g')"

  while true; do
    TIME_ZONE="$(dialog --no-cancel --ok-button "${OK}" --menu \
      "\n${SET_TIME_ZONE_MSG}" 18 60 10 ${zonelist})" || continue
    if find /usr/share/zoneinfo -maxdepth 1 -type d \
        | sed -n -e 's!^.*/!!p' \
        | grep -q "${TIME_ZONE}"; then
      sublist="$(find "/usr/share/zoneinfo/${TIME_ZONE}" -maxdepth 1 \
        | sed -n -e 's!^.*/!!p' \
        | sort \
        | sed 's/$/ ->/g' \
        | grep -v "${TIME_ZONE}")"
      if subzone="$(dialog --ok-button "${OK}" --cancel-button "${BACK}" \
          --menu "\n${SET_TIME_SUBZONE_MSG}" 18 60 10 ${sublist})"; then
        if find "/usr/share/zoneinfo/${TIME_ZONE}" -maxdepth 1 -type d \
            | sed -n -e 's!^.*/!!p' \
            | grep -q "${subzone}"; then
          sublist="$(find "/usr/share/zoneinfo/${TIME_ZONE}/${subzone}" \
              -maxdepth 1 \
            | sed -n -e 's!^.*/!!p' \
            | sort \
            | sed 's/$/ ->/g' \
            | grep -v "${subzone}")"
          if subsubzone="$(dialog --ok-button "${OK}" --cancel-button "${BACK}"\
              --menu "\n${SET_TIME_SUBZONE_MSG}" 15 60 7 ${sublist})"; then
            TIME_ZONE="${TIME_ZONE}/${subzone}/${subsubzone}"
            break
          fi
        else
          TIME_ZONE="${TIME_ZONE}/${subzone}"
          break
        fi
      fi
    else
      break
    fi
  done
  log "Time zone: ${TIME_ZONE}"
}

################################################################################
# Present partitioning options and facilitate preparing a drive (or drives) for
# Linux installation.
#
# Globals: TITLE, PREPARE_DRIVES_TITLE, PART_METHOD_MSG, RAM, PART_METHOD_AUTO,
#   PART_METHOD_AUTO_ENCRYPT, PART_METHOD_MANUAL, SYSTEM_MOUNTED, DEVICE_LIST,
#   ROOT_DRIVE, ROOT_FS, HOME_DRIVE_MSG, HOME_DRIVE, HOME_FS, UEFI_MSG, UEFI,
#   GPT_MSG, GPT, BOOT_OR_ESP_MNT, BOOT_OR_ESP_SIZE, DEFAULT_ESP_SIZE_SMALL,
#   DEFAULT_ESP_SIZE_LARGE, DEFAULT_BOOT_SIZE, SWAP_SIZE, ENABLE_HIBERNATION,
#   SET_SWAP_SIZE_MSG, SWAP_INPUT_ERROR_MSG, PART_ERROR_MSG, OK, CANCEL, YES,
#   NO, BASE_PACKAGES, MISC_PACKAGES, FS_PACKAGES
# Arguments: None
################################################################################
prepare_drives() {
  TITLE="${PREPARE_DRIVES_TITLE}"
  local partition_method partition_prefix root_gib home_gib

  log "Initial partition layout:"
  log_partitions

  until "${SYSTEM_MOUNTED}"; do
    unmount_and_close_everything --swapoff

    # Present partitioning options
    if ! partition_method="$(dialog --no-cancel --ok-button "${OK}" --menu \
        "\n${PART_METHOD_MSG}" 16 70 3 \
        "${PART_METHOD_AUTO}" '->' \
        "${PART_METHOD_AUTO_ENCRYPT}" '->' \
        "${PART_METHOD_MANUAL}" '->')"; then
      continue

    # If an auto-partitioning option is selected, present drive menu(s)
    elif [[ "${partition_method}" != "${PART_METHOD_MANUAL}" ]]; then
      if [[ "${partition_method}" == "${PART_METHOD_AUTO}" ]]; then
        log "Auto-partitioning..."
      elif [[ "${partition_method}" == "${PART_METHOD_AUTO_ENCRYPT}" ]]; then
        log "Auto-partitioning with encryption..."
      fi

      # Root drive selection
      prepare_device_menu --auto-root
      ROOT_DRIVE="$(bash /tmp/gdl/part.sh)" || continue
      root_gib="$(get_device_size "${ROOT_DRIVE}" --gib)"
      log "* Root drive: ${ROOT_DRIVE} (${root_gib} GiB)"
      ROOT_FS="$(get_filesystem)" || continue
      log "* Root filesystem: ${ROOT_FS}"

      # Home drive selection (optional)
      if (( $(wc -l <<<"${DEVICE_LIST}") > 1 )); then
        while yesno "${HOME_DRIVE_MSG}" "${YES}" "${NO}" --defaultno; do
          prepare_device_menu --auto-home
          HOME_DRIVE="$(bash /tmp/gdl/part.sh)" || continue
          home_gib="$(get_device_size "${HOME_DRIVE}" --gib)"
          log "* Home drive: ${HOME_DRIVE} (${home_gib} GiB)"
          HOME_FS="$(get_filesystem)" || continue
          log "* Home filesystem: ${HOME_FS}"
          break
        done
      fi

      # Check drive properties and set up boot
      if [[ "${ROOT_DRIVE}" =~ nvme|mmc|md ]]; then
        partition_prefix='p'
      else
        partition_prefix=''
      fi
      if efivar -l &>/dev/null && yesno "${UEFI_MSG}" "${YES}" "${NO}"; then
        GPT='true'
        UEFI='true'
        BOOT_OR_ESP_MNT='/efi'
        if (( $(cat "/sys/class/block/${ROOT_DRIVE}/queue/logical_block_size")
            <= 512 )); then
          BOOT_OR_ESP_SIZE="${DEFAULT_ESP_SIZE_SMALL}"
        else
          BOOT_OR_ESP_SIZE="${DEFAULT_ESP_SIZE_LARGE}"
        fi
        log "* UEFI/GPT setup activated (${BOOT_OR_ESP_SIZE} MiB ESP)"
      else
        BOOT_OR_ESP_MNT='/boot'
        BOOT_OR_ESP_SIZE="${DEFAULT_BOOT_SIZE}"
        if yesno "${GPT_MSG}" "${YES}" "${NO}" --defaultno; then
          GPT='true'
          log "* BIOS/GPT setup activated (${BOOT_OR_ESP_SIZE} MiB boot)"
        else
          log "* BIOS/MBR setup activated (${BOOT_OR_ESP_SIZE} MiB boot)"
        fi
      fi

      # Set swap size
      SWAP_SIZE=''
      if yesno "${CREATE_SWAP_MSG}" "${YES}" "${NO}" --defaultno; then
        while true; do
          SWAP_SIZE="$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
              --inputbox "\n${SET_SWAP_SIZE_MSG}" 12 55 \
              "$(( RAM / 1024 / 2 + 1 ))G" \
            | tr 'mg' 'MG' \
            | tr -s 'MG' \
            | tr -d 'a-zA-FH-LN-Z[:space:]')" || break
          if [[ "${SWAP_SIZE}" =~ ^[0-9]+M$ ]]; then
            SWAP_SIZE="${SWAP_SIZE/M}"
          elif [[ "${SWAP_SIZE}" =~ ^[0-9]+G$ ]]; then
            SWAP_SIZE=$(( ${SWAP_SIZE/G} * 1024 ))
          else
            log_error "Invalid swap size input: ${SWAP_SIZE}"
            message "${SWAP_INPUT_ERROR_MSG}"
            continue
          fi
          break
        done
      fi
      [[ -z "${SWAP_SIZE}" ]] && SWAP_SIZE='0'
      log "* Swap size: ${SWAP_SIZE} MiB"

      # Format selected drive(s) or go back to main partitioning menu
      wipe_drive "${ROOT_DRIVE}" "${root_gib}" "${ROOT_FS}" || continue
      if [[ -n "${HOME_DRIVE}" ]]; then
        wipe_drive "${HOME_DRIVE}" "${home_gib}" "${HOME_FS}" || continue
      fi
    fi

    # Go to appropriate sub-function
    case "${partition_method}" in
      "${PART_METHOD_AUTO}")
        if ! auto_partition; then
          log_error "Auto-partitioning failed"
          message "${PART_ERROR_MSG}"
        fi
        ;;
      "${PART_METHOD_AUTO_ENCRYPT}")
        if ! auto_partition_with_encryption; then
          log_error "Auto-partitioning with encryption failed"
          message "${PART_ERROR_MSG}"
        fi
        ;;
      "${PART_METHOD_MANUAL}")
        log "Manually partitioning..."
        manually_partition
        ;;
    esac
  done

  # Add packages, adjust settings, and log partition layout
  "${UEFI}" && BASE_PACKAGES+="${MISC_PACKAGES[efi]}"
  lsblk -no TYPE | grep -q 'lvm' && BASE_PACKAGES+="${MISC_PACKAGES[lvm]}"
  [[ "${ROOT_FS}" == 'btrfs' ]] && BASE_PACKAGES+="${MISC_PACKAGES[root-btrfs]}"
  for fs in "${!FS_PACKAGES[@]}"; do
    mount | grep -q "type ${fs}" && BASE_PACKAGES+="${FS_PACKAGES[$fs]}"
  done
  (( SWAP_SIZE >= RAM / 2 )) && ENABLE_HIBERNATION='true'
  log_partitions
}

################################################################################
# Automatically partition the drive(s) selected in 'prepare_drives' and mount
# the newly-created partitions.
#
# Globals: TITLE, AUTO_PART_TITLE, ROOT_PART, ROOT_FS, HOME_DRIVE, HOME_FS,
#   BOOT_OR_ESP, BOOT_OR_ESP_MNT, UEFI, EFI_LOAD_MSG, BOOT_LOAD_MSG,
#   MKFS_LOAD_MSG, SYSTEM_MOUNTED
# Arguments: None
# Returns: Number of errors detected.
################################################################################
auto_partition() {
  TITLE="${AUTO_PART_TITLE}"

  # Create and format partitions
  partition_root_drive || return 1
  zap_and_wipe "${BOOT_OR_ESP}" || return 1
  if "${UEFI}"; then
    (
      mkfs.vfat -F32 "/dev/${BOOT_OR_ESP}" \
        && log "  - ESP filesystem created: vfat (FAT32)"
    ) &>/dev/null &
    load_bar "${EFI_LOAD_MSG}\n\n \Z1> \Z2mkfs.vfat -F32 /dev/${BOOT_OR_ESP}\Zn"
  else # BIOS
    (
      mkfs.ext4 "/dev/${BOOT_OR_ESP}" \
        && log "  - Boot filesystem created: ext4"
    ) &>/dev/null &
    load_bar "${BOOT_LOAD_MSG}\n\n \Z1> \Z2mkfs.ext4 /dev/${BOOT_OR_ESP}\Zn"
  fi
  zap_and_wipe "${ROOT_PART}" || return 1
  (
    mkfs."${ROOT_FS}" "/dev/${ROOT_PART}" \
      && log "  - Root filesystem created: ${ROOT_FS}"
  ) &>/dev/null &
  load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${ROOT_FS} \
/dev/${ROOT_PART}\Zn"
  if [[ -n "${HOME_DRIVE}" ]]; then
    (
      mkfs."${HOME_FS}" "/dev/${HOME_DRIVE}" \
        && log "  - Home filesystem created: ${HOME_FS}"
    ) &>/dev/null &
    load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${HOME_FS} \
/dev/${HOME_DRIVE}\Zn"
  fi

  # Mount partitions
  if [[ "${ROOT_FS}" == 'btrfs' ]]; then
    create_and_mount_btrfs_subvolume @ "/dev/${ROOT_PART}" || return 1
    if [[ -z "${HOME_DRIVE}" ]]; then
      create_and_mount_btrfs_subvolume @home "/dev/${ROOT_PART}" || return 1
    fi
    create_and_mount_btrfs_subvolume @var@log "/dev/${ROOT_PART}" || return 1
    create_and_mount_btrfs_subvolume @var@cache "/dev/${ROOT_PART}" || return 1
  elif mount "/dev/${ROOT_PART}" /mnt &>/dev/null; then
    log "  - Mounted /dev/${ROOT_PART} at /mnt"
  else
    log_error "Mounting /dev/${ROOT_PART} at /mnt failed"
    return 1
  fi
  if [[ -n "${HOME_DRIVE}" ]]; then
    if [[ "${HOME_FS}" == 'btrfs' ]]; then
      create_and_mount_btrfs_subvolume @home "/dev/${HOME_DRIVE}" || return 1
    elif mount -m "/dev/${HOME_DRIVE}" /mnt/home &>/dev/null; then
      log "  - Mounted /dev/${HOME_DRIVE} at /mnt/home"
    else
      log_error "Mounting /dev/${HOME_DRIVE} at /mnt/home failed"
      return 1
    fi
  fi
  if mount -m "/dev/${BOOT_OR_ESP}" "/mnt${BOOT_OR_ESP_MNT}" &>/dev/null; then
    log "  - Mounted /dev/${BOOT_OR_ESP} at /mnt${BOOT_OR_ESP_MNT}"
    SYSTEM_MOUNTED='true'
  else
    log_error "Mounting /dev/${BOOT_OR_ESP} at /mnt${BOOT_OR_ESP_MNT} failed"
    return 1
  fi
  log "Auto-partitioning complete:"
}

################################################################################
# Automatically partition and encrypt the drive(s) selected in 'prepare_drives',
# applying "LVM on LUKS" to the root drive (including a logical swap space if a
# non-zero swap size is set), and mount the newly-created partitions.
#
# Globals: TITLE, AUTO_PART_TITLE, ROOT_PART, ROOT_FS, HOME_DRIVE, HOME_FS, NO,
#   YES, SWAP, SWAP_SIZE, BOOT_OR_ESP, BOOT_OR_ESP_MNT, UEFI, SYSTEM_MOUNTED,
#   SYSTEM_AUTO_ENCRYPTED, ENCRYPTION_PASSWORD_CONFIRM, ENCRYPTION_CONFIRM,
#   ENCRYPTION_PASSWORD_MSG, PASSWORD_EMPTY_MSG, PASSWORD_MISMATCH_MSG, ROOT_LV,
#   ENCRYPTION_LOAD_MSG, SWAP_LOAD_MSG, EFI_LOAD_MSG, PVCREATE_LOAD_MSG,
#   LVCREATE_LOAD_MSG, BOOT_LOAD_MSG, MKFS_LOAD_MSG, ROOT_PART_UUID, LVM_UUID,
#   HOME_DRIVE_UUID
# Arguments: None
# Returns: Number of errors detected.
################################################################################
auto_partition_with_encryption() {
  TITLE="${AUTO_PART_TITLE}"
  local input input_check

  # Set encryption password
  if yesno "$(eval echo \"${ENCRYPTION_CONFIRM}\")" "${YES}" "${NO}" \
      --defaultno; then
    while true; do
      if ! input="$(dialog --no-cancel --clear --insecure --passwordbox \
            "\n$(eval echo \"${ENCRYPTION_PASSWORD_MSG}\")" 12 55)" \
          || ! input_check="$(dialog --no-cancel --clear --insecure \
            --passwordbox "\n$(eval echo \"${ENCRYPTION_PASSWORD_CONFIRM}\")" \
            12 55)" \
          || [[ -z "${input}" ]]; then
        message "${PASSWORD_EMPTY_MSG}"
      elif [[ "${input}" != "${input_check}" ]]; then
        message "${PASSWORD_MISMATCH_MSG}"
      else
        break
      fi
    done
    log "* Encryption password set"
  else
    return 0 # back to 'prepare_drives'
  fi

  # Create and encrypt partitions
  partition_root_drive --no-swap || return 1
  zap_and_wipe "${ROOT_PART}" || return 1
  (
    # shellcheck disable=SC2046
    echo -n "${input}" | cryptsetup luksFormat \
      $("${UEFI}" && echo '--pbkdf pbkdf2') "/dev/${ROOT_PART}"
    "${UEFI}" && add_key_file_slot "${ROOT_PART}" "${input}"
    log "  - Root partition encrypted"
  ) &>/dev/null &
  load_bar "${ENCRYPTION_LOAD_MSG}\n\n \Z1> \Z2cryptsetup luksFormat \
/dev/${ROOT_PART}\Zn"
  ROOT_PART_UUID="$(lsblk -no UUID "/dev/${ROOT_PART}")"
  echo -n "${input}" | cryptsetup open "/dev/${ROOT_PART}" cryptlvm
  if [[ -n "${HOME_DRIVE}" ]]; then
    (
      echo -n "${input}" | cryptsetup luksFormat "/dev/${HOME_DRIVE}"
      add_key_file_slot "${HOME_DRIVE}" "${input}"
      log "  - Home partition encrypted"
    ) &>/dev/null &
    load_bar "${ENCRYPTION_LOAD_MSG}\n\n \Z1> \Z2cryptsetup luksFormat \
/dev/${HOME_DRIVE}\Zn"
    HOME_DRIVE_UUID="$(lsblk -no UUID "/dev/${HOME_DRIVE}")"
    echo -n "${input}" | cryptsetup open "/dev/${HOME_DRIVE}" crypthome
  fi
  unset input input_check

  (
    pvcreate /dev/mapper/cryptlvm \
      && log "  - Physical volume created on /dev/mapper/cryptlvm"
    vgcreate vg /dev/mapper/cryptlvm \
      && log "  - Logical volume group created: vg"
  ) &>/dev/null &
  load_bar "${PVCREATE_LOAD_MSG}\n\n \Z1> \Z2pvcreate /dev/mapper/cryptlvm\Zn"
  LVM_UUID="$(lsblk -no UUID /dev/mapper/cryptlvm)"

  if (( SWAP_SIZE > 0 )); then
    SWAP='vg/lvswap'
    (
      lvcreate -L "${SWAP_SIZE}" vg -n lvswap \
        && mkswap "/dev/${SWAP}" \
        && swapon "/dev/${SWAP}" \
        && log "  - Logical swap space created and activated: /dev/${SWAP}"
    ) &>/dev/null &
    load_bar \
      "${SWAP_LOAD_MSG}\n\n \Z1> \Z2lvcreate -L ${SWAP_SIZE} vg -n lvswap\Zn"
  fi
  ROOT_LV='vg/lvroot'
  (
    lvcreate -l 100%FREE vg -n lvroot \
      && log "  - Logical root volume created: /dev/${ROOT_LV}"
    [[ "${ROOT_FS}" == 'ext4' ]] \
      && lvreduce -L -256M "${ROOT_LV}" \
      && log "  - 256 MiB removed from lvroot to allow use of e2scrub"
  ) &>/dev/null &
  load_bar \
    "${LVCREATE_LOAD_MSG}\n\n \Z1> \Z2lvcreate -l 100%FREE vg -n lvroot\Zn"

  # Apply filesystems
  if "${UEFI}"; then
    (
      mkfs.vfat -F32 "/dev/${BOOT_OR_ESP}" \
        && log "  - ESP filesystem created: vfat (FAT32)"
    ) &>/dev/null &
    load_bar "${EFI_LOAD_MSG}\n\n \Z1> \Z2mkfs.vfat -F32 /dev/${BOOT_OR_ESP}\Zn"
  else # BIOS
    (
      mkfs.ext4 "/dev/${BOOT_OR_ESP}" \
        && log "  - Boot filesystem created: ext4"
    ) &>/dev/null &
    load_bar "${BOOT_LOAD_MSG}\n\n \Z1> \Z2mkfs.ext4 /dev/${BOOT_OR_ESP}\Zn"
  fi
  (
    mkfs."${ROOT_FS}" "/dev/${ROOT_LV}" \
      && log "  - Root filesystem created: ${ROOT_FS}"
  ) &>/dev/null &
  load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${ROOT_FS} \
/dev/${ROOT_LV}\Zn"
  if [[ -n "${HOME_DRIVE}" ]]; then
    (
      mkfs."${HOME_FS}" /dev/mapper/crypthome \
        && log "  - Home filesystem created: ${HOME_FS}"
    ) &>/dev/null &
    load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${HOME_FS} \
/dev/mapper/crypthome\Zn"
  fi

  # Mount partitions/volumes
  if [[ "${ROOT_FS}" == 'btrfs' ]]; then
    create_and_mount_btrfs_subvolume @ "/dev/${ROOT_LV}" || return 1
    if [[ -z "${HOME_DRIVE}" ]]; then
      create_and_mount_btrfs_subvolume @home "/dev/${ROOT_LV}" || return 1
    fi
    create_and_mount_btrfs_subvolume @var@log "/dev/${ROOT_LV}" || return 1
    create_and_mount_btrfs_subvolume @var@cache "/dev/${ROOT_LV}" || return 1
  elif mount "/dev/${ROOT_LV}" /mnt &>/dev/null; then
    log "  - Mounted /dev/${ROOT_LV} at /mnt"
  else
    log_error "Mounting /dev/${ROOT_LV} at /mnt failed"
    return 1
  fi
  if [[ -n "${HOME_DRIVE}" ]]; then
    if [[ "${HOME_FS}" == 'btrfs' ]]; then
      create_and_mount_btrfs_subvolume @home /dev/mapper/crypthome || return 1
    elif mount -m /dev/mapper/crypthome /mnt/home &>/dev/null; then
      log "  - Mounted /dev/mapper/crypthome at /mnt/home"
    else
      log_error "Mounting /dev/mapper/crypthome at /mnt/home failed"
      return 1
    fi
  fi
  if mount -m "/dev/${BOOT_OR_ESP}" "/mnt${BOOT_OR_ESP_MNT}" &>/dev/null; then
    log "  - Mounted /dev/${BOOT_OR_ESP} at /mnt${BOOT_OR_ESP_MNT}"
    SYSTEM_MOUNTED='true'
    SYSTEM_AUTO_ENCRYPTED='true'
  else
    log_error "Mounting /dev/${BOOT_OR_ESP} at /mnt${BOOT_OR_ESP_MNT} failed"
    return 1
  fi
  log "Auto-partitioning with encryption complete:"
}

################################################################################
# Present options for manual partitioning of available drives and handle
# formatting and mounting of newly-created partitions.
#
# Globals: TITLE, MANUAL_PART_TITLE, EDIT_PART_TITLE, DEVICE_LIST, ROOT_DRIVE,
#   ROOT_PART, ROOT_FS, GPT, UEFI, BOOT_OR_ESP_MNT, SYSTEM_MOUNTED, SWAP_SIZE,
#   SWAP, ALREADY_MOUNTED_MSG, SELECT_MNT_MSG, CUSTOM_MNT_MSG, PART_FORMAT_MSG,
#   EFI_VFAT_MSG, FS_VFAT_MSG, WRITE_CONFIRM, UNMOUNT_DRIVE_CONFIRM,
#   EDIT_DRIVE_CONFIRM, ROOT_MNT_CONFIRM, ROOT_FORMAT_CONFIRM,
#   UNMOUNT_ROOT_CONFIRM, UNMOUNT_PART_CONFIRM, SWAPOFF_CONFIRM, MNT_CONFIRM,
#   PART_FORMAT_CONFIRM, WAIT_LOAD_MSG, MKFS_LOAD_MSG, ROOT_UNMOUNTED_ERROR_MSG,
#   GPT_BIOS_ERROR_MSG, ROOT_MOUNT_ERROR_MSG, CUSTOM_MNT_CHAR_ERROR_MSG,
#   CUSTOM_MNT_ROOT_ERROR_MSG, MOUNT_ERROR_MSG, PARTITION, SIZE, MOUNT_POINT,
#   CUSTOM, EDIT, BACK, WRITE_CHANGES, OK, CANCEL, YES, NO, DONE
# Arguments: None
# Returns: Number of errors detected.
################################################################################
manually_partition() {
  local part part_size part_type part_fs part_mount part_final \
    empty_value='----' lvm_pv selected_fs

  while true; do
    # Prepare and present manual partitioning menu
    TITLE="${MANUAL_PART_TITLE}"
    prepare_device_menu --manual
    if ! part="$(bash /tmp/gdl/part.sh | sed 's/^\s\+//g;s/\s\+$//g')" \
        || [[ -z "${part}" ]]; then
      SYSTEM_MOUNTED='false'
      return 0 # back to 'prepare_drives'
    fi
    log "* Menu selection: '${part}'"

    # If user selected 'done', attempt to finish the partitioning process
    if [[ "${part}" == "${DONE}" ]]; then
      if ! "${SYSTEM_MOUNTED}"; then
        log_error "Root partition not found"
        message "${ROOT_UNMOUNTED_ERROR_MSG}"
        continue
      elif "${GPT}" && ! "${UEFI}" && ! fdisk -l | grep -q 'BIOS boot'; then
        log_error "BIOS boot partition not found"
        message "${GPT_BIOS_ERROR_MSG}"
        continue
      fi
      part_final="$( (df -h \
          | grep '/mnt' \
          | awk '{print $1,$2,$6 "\\n"}' \
          | sed 's/mnt\/\?//'; swapon \
          | awk 'NR==2 {print $1,$3,"SWAP"}') \
        | column -t)"
      yesno "${WRITE_CONFIRM}\n\n${PARTITION}  ${SIZE}  ${MOUNT_POINT}\n\n\
${part_final}" "${OK}" "${CANCEL}" --defaultno || continue

      # Add home and var subvolumes for Btrfs root (if mount points are free)
      if mount | grep -q ' /mnt type btrfs'; then
        mount | grep -q ' /mnt/home ' \
          || create_and_mount_btrfs_subvolume @home "/dev/${ROOT_PART}"
        if ! mount | grep -q ' /mnt/var '; then
          mount | grep -q ' /mnt/var/log ' \
            || create_and_mount_btrfs_subvolume @var@log "/dev/${ROOT_PART}"
          mount | grep -q ' /mnt/var/cache ' \
            || create_and_mount_btrfs_subvolume @var@cache "/dev/${ROOT_PART}"
        fi
      fi

      log "Manual partitioning complete:"

      return 0 # all done: return to 'prepare_drives'
    fi

    # If not 'done', prepare and present a disk/partition editing menu
    part_size="$(grep -w "${part}" <<<"${DEVICE_LIST}" | awk '{print $2}')"
    part_type="$(grep -w "${part}" <<<"${DEVICE_LIST}" | awk '{print $3}')"
    part_fs="$(grep -w "${part}" <<<"${DEVICE_LIST}" | awk '{print $4}')"
    part_mount="$(df \
      | grep -w "${part}" \
      | awk '{print $6}' \
      | sed 's/mnt\/\?//')"
    [[ "${part_type}" == 'lvm' ]] && part="${part/-//}"
    log "  - Device info: ${part_type} ${part_fs} ${part_size} ${part_mount}"
    [[ "${part_fs}" == 'linux_raid_member' ]] && continue # do nothing

    # If user selected an entire drive, facilitate partitioning
    if [[ "${part_type}" == 'disk' ]] \
        || [[ "${part_type}" =~ raid[0-9] && -z "${part_fs}" ]]; then
      if mount | grep -q "${part}.*on /mnt"; then
        if yesno "$(eval echo \"${UNMOUNT_DRIVE_CONFIRM}\")" "${EDIT}" \
            "${CANCEL}" --defaultno; then
          unmount_and_close_everything --swapoff
          modify_partition_table "${part}"
        fi
      elif yesno "$(eval echo \"${EDIT_DRIVE_CONFIRM}\")" "${EDIT}" \
          "${CANCEL}"; then
        modify_partition_table "${part}"
      fi

    # If user selected a partition or md device, facilitate mounting/formatting
    else
      TITLE="${EDIT_PART_TITLE}"
      # The root '/' mount point must be established before others
      if [[ -z "${ROOT_PART}" ]]; then
        # shellcheck disable=SC2015
        yesno "$(eval echo \"${ROOT_MNT_CONFIRM}\")" "${YES}" "${NO}" \
            --defaultno \
          && ROOT_FS="$(get_filesystem)" \
          && yesno "$(eval echo \"${ROOT_FORMAT_CONFIRM}\")" \
            "${WRITE_CHANGES}" "${CANCEL}" --defaultno \
          || continue
        zap_and_wipe "${part}" || return 1
        (
          mkfs."${ROOT_FS}" "/dev/${part}" \
            && log "  - Root filesystem created for /dev/${part}: ${ROOT_FS}"
        ) &>/dev/null &
        load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \
\Z2mkfs.${ROOT_FS} /dev/${part}\Zn"
        if [[ "${ROOT_FS}" == 'btrfs' ]]; then
          if ! create_and_mount_btrfs_subvolume @ "/dev/${part}"; then
            message "${ROOT_MOUNT_ERROR_MSG}"
            return 1 # back to 'prepare_drives'
          fi
        elif mount "/dev/${part}" /mnt &>/dev/null; then
          log "  - Mounted /dev/${part} at /mnt"
        else
          log_error "Mounting /dev/${part} at /mnt failed"
          message "${ROOT_MOUNT_ERROR_MSG}"
          return 1 # back to 'prepare_drives'
        fi
        SYSTEM_MOUNTED='true'
        ROOT_PART="${part}"
        if [[ "${part_type}" == "lvm" ]]; then
          lvm_pv="$(lvdisplay -m \
            | grep -A 20 "/dev/${part}" \
            | grep 'Physical volume' \
            | sed 's/^\s\+//g;s/\s\+/ /g' \
            | cut -d ' ' -f 3)"
          ROOT_DRIVE="$(lsblk -dnro PKNAME "${lvm_pv}")"
        else
          ROOT_DRIVE="$(lsblk -dnro PKNAME "/dev/${part}")"
        fi
        log "  - Root drive: ${ROOT_DRIVE}"
        if parted "/dev/${ROOT_DRIVE}" print | grep -q 'Table: gpt'; then
          GPT='true'
        else
          GPT='false'
        fi
        log "  - GPT: ${GPT}"
      # If the partition's already mounted, provide option to unmount
      elif [[ -n "${part_mount}" ]]; then
        if yesno "$(eval echo \"${ALREADY_MOUNTED_MSG}\")" "${EDIT}" "${BACK}" \
            --defaultno; then
          if [[ "${part}" == "${ROOT_PART}" ]]; then
            if yesno "$(eval echo \"${UNMOUNT_ROOT_CONFIRM}\")" "${YES}" \
                "${NO}" --defaultno; then
              unmount_and_close_everything
            fi
          elif yesno "$(eval echo \"${UNMOUNT_PART_CONFIRM}\")" "${YES}" \
              "${NO}" --defaultno; then
            if "${UEFI}" && [[ "${part_mount}" == "${BOOT_OR_ESP_MNT}" ]]; then
              UEFI='false'
              BOOT_OR_ESP_MNT=''
              log "  - Unmounting ESP..."
            fi
            (
              umount "/mnt${part_mount}" \
                && log "  - Unmounted /dev/${part} from /mnt${part_mount}"
              rm -r "/mnt${part_mount:?}"
            ) &>/dev/null &
            load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2umount /mnt${part_mount}\Zn"
          fi
        fi
      # If it's already in use as swap, provide option to 'swapoff' and wipe
      elif lsblk | grep -q "${part} .*\[SWAP\]$"; then
        if yesno "$(eval echo \"${SWAPOFF_CONFIRM}\")" "${YES}" "${NO}" \
            --defaultno; then
          SWAP=''
          SWAP_SIZE=''
          (
            swapoff "/dev/${part}"
            wipefs -a "/dev/${part}" \
              && log "  - Swap partition /dev/${part} deactivated and wiped"
            sleep 0.6
          ) &>/dev/null &
          load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2swapoff /dev/${part}\Zn"
        fi
      # If it's a swap partition not in use, reformat and 'swapon'
      elif (( $(fdisk -l \
            | grep -w "${part}" \
            | sed 's/\*//' \
            | awk '{print $6}') == 82 )) &>/dev/null \
          || (fdisk -l /dev/"$(lsblk -dnro PKNAME "/dev/${part}")" \
              | grep -q 'gpt' \
            && [[ "$(fdisk -l -o Device,Size,Type-UUID \
              | grep -w "${part}" \
              | awk '{print $3}')" == "0657FD6D-A4AB-43C4-84E5-0933C84B4F4F" ]]\
            ) &>/dev/null; then
        format_swap_partition "${part}"
      # Otherwise, present mount point menu (inc. option to create swap)
      elif yesno "$(eval echo \"${MNT_CONFIRM}\")" "${EDIT}" "${BACK}"; then
        mnt="$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
          --menu "\n$(eval echo \"${SELECT_MNT_MSG}\")" 15 60 6 \
          '/home' '->' \
          '/boot' '->' \
          '/efi' '->' \
          '/opt' '->' \
          '/usr' '->' \
          '/var' '->' \
          '/tmp' '->' \
          '[SWAP]' '->' \
          "${CUSTOM}" '->')" || continue
        if [[ "${mnt}" == '[SWAP]' ]]; then
          format_swap_partition "${part}"
          continue
        elif [[ "${mnt}" == "${CUSTOM}" ]]; then
          while true; do
            mnt="$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
                --inputbox "\n${CUSTOM_MNT_MSG}" 10 50 '/' \
              | tr -d '[:space:]' \
              | tr -s '/')" || continue 2
            if grep -q "[\[\$\!\'\"\`\\|%&#@()+=<>~;:?.,^{}]\|]" \
                <<<"${mnt}"; then
              message "${CUSTOM_MNT_CHAR_ERROR_MSG}"
            elif [[ "${mnt}" == '/' ]]; then
              message "${CUSTOM_MNT_ROOT_ERROR_MSG}"
            elif [[ -n "${mnt}" ]]; then
              [[ "${mnt}" =~ ^/ ]] || mnt="/${mnt}"
              break
            fi
          done
        fi
        log "  - Mount point: ${mnt}"
        # Provide formatting options
        if yesno "${PART_FORMAT_MSG}" "${YES}" "${NO}" --defaultno; then
          if is_esp_candidate "${part}" "${mnt}"; then
            selected_fs="$(dialog --menu "\n${EFI_VFAT_MSG}" 12 65 1 'vfat' \
              "${FS_VFAT_MSG}")" || continue
          else
            selected_fs="$(get_filesystem)" || continue
          fi
          yesno "$(eval echo \"${PART_FORMAT_CONFIRM}\")" "${WRITE_CHANGES}" \
            "${CANCEL}" --defaultno || continue
          zap_and_wipe "${part}" || return 1
          (
            case "${selected_fs}" in
              vfat) mkfs.vfat -F32 "/dev/${part}" ;;
              *) mkfs."${selected_fs}" "/dev/${part}" ;;
            esac
            log "  - Filesystem created for ${mnt}: ${selected_fs}"
          ) &>/dev/null &
          load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \
\Z2mkfs.${selected_fs} /dev/${part}\Zn"
        fi
        # Attempt to mount the partition at the given mount point
        if blkid | grep "${part}" | grep -q 'TYPE="btrfs"'; then
          create_and_mount_btrfs_subvolume "${mnt////@}" "/dev/${part}" \
            || message "${MOUNT_ERROR_MSG}"
        elif mount -m "/dev/${part}" "/mnt${mnt}" &>/dev/null; then
          if is_esp_candidate "${part}" "${mnt}" \
              && mount | grep -q " /mnt${mnt} type vfat "; then
            UEFI='true'
            BOOT_OR_ESP_MNT="${mnt}"
            log "  - Mounting ESP..."
          fi
          log "  - Mounted /dev/${part} at /mnt${mnt}"
        else
          log_error "Mounting /dev/${part} at /mnt${mnt} failed"
          message "${MOUNT_ERROR_MSG}"
        fi
      fi
    fi
  done
}

################################################################################
# Prepare a device list string, plus temp files 'part.list' and 'part.sh', for
# use in a given type of partitioning menu. (Assumes TITLE is already set.)
#
# Globals: DEVICE_LIST, ROOT_DRIVE, SELECT_DRIVE_MSG, SELECT_HOME_DRIVE_MSG,
#   MANUAL_PART_MSG, TITLE, BACKTITLE, EDIT, OK, CANCEL, DONE, WRITE_CHANGES,
#   REDUCE_EXTRANEOUS_TEXT
# Arguments: Type of menu (--auto-root, --auto-home, or --manual).
# Returns: Number of errors detected.
################################################################################
prepare_device_menu() {
  local -i counter device_count
  local device dev_size dev_type dev_fs dev_mnt dev_used dev_parent \
    empty_value='----' menu_header='               Device    Size    Type' \
    menu_msg grep_str

  # Check input
  case "$1" in
    --auto-root) menu_msg="${SELECT_DRIVE_MSG}" ;;
    --auto-home) menu_msg="${SELECT_HOME_DRIVE_MSG}" ;;
    --manual)
      menu_msg="${MANUAL_PART_MSG}"
      menu_header='       Device    Size    Used    FS    Mount    Type'
      ;;
    *)
      log_error "Invalid device menu option: $1"
      return 1
      ;;
  esac

  # Start crafting 'dialog' command
  if "${REDUCE_EXTRANEOUS_TEXT}"; then
    echo -n "dialog --stdout --colors --title \" ${TITLE} \" --ok-button " \
      >/tmp/gdl/part.sh
  else
    echo -n "dialog --stdout --colors --backtitle \"${BACKTITLE}\" --title \" \
${TITLE} \" --ok-button " >/tmp/gdl/part.sh
  fi

  # Finish crafting 'dialog' command for an auto-partitioning drive menu
  if [[ "$1" =~ ^--auto ]]; then
    # shellcheck disable=SC2028
    echo "\"${OK}\" --cancel-button \"${CANCEL}\" --menu \"\n${menu_msg}\n\n\
${menu_header}\" 16 60 5 \\" >>/tmp/gdl/part.sh
    DEVICE_LIST="$(lsblk -nio NAME,SIZE,TYPE \
      | grep -E "disk|raid[0-9]+$" \
      | sed 's/[^[:alnum:]_., ]//g' \
      | column -t \
      | sort -k 1,1 \
      | uniq \
      | awk '{print "\""$1"\"""  ""\"| "$2" | "$3"     \""" \\"}' \
      | column -t)"
    while read -r line; do
      if [[ "$1" =~ root || ! "${line}" =~ ${ROOT_DRIVE} ]]; then
        echo "${line}" >>/tmp/gdl/part.sh
      fi
    done < <(echo "${DEVICE_LIST}")

  # Finish crafting 'dialog' command for the manual partitioning menu
  else
    grep_str="$(lsblk \
      | grep ' /run' \
      | grep -o sd. \
      | tr '\n' '|')loop[0-9]+|sr[0-9]+|fd[0-9]+"
    DEVICE_LIST="$(lsblk -no NAME,SIZE,TYPE,FSTYPE \
      | grep -Ev "${grep_str}" \
      | sed 's/[^[:alnum:]_., -]//g' \
      | column -t \
      | sort -k 1,1 \
      | uniq)"
    device_count=$(wc -l <<<"${DEVICE_LIST}")
    # shellcheck disable=SC2028
    echo "\"${EDIT}\" --cancel-button \"${CANCEL}\" --menu \"\n${menu_msg}\n\n\
${menu_header}\" 21 68 9 \\" >>/tmp/gdl/part.sh
    [[ -f /tmp/gdl/part.list ]] && rm /tmp/gdl/part.list
    counter=1
    until (( counter > device_count )); do
      device="$(awk <<<"${DEVICE_LIST}" '{print $1}' | awk "NR==${counter}")"
      dev_size="$(grep -w "${device}" <<<"${DEVICE_LIST}" | awk '{print $2}')"
      dev_type="$(grep -w "${device}" <<<"${DEVICE_LIST}" | awk '{print $3}')"
      dev_fs="$(grep -w "${device}" <<<"${DEVICE_LIST}" | awk '{print $4}')"
      dev_mnt="$(df \
        | grep -w "${device}" \
        | awk '{print $6}' \
        | sed 's/mnt\/\?//')"
      if [[ "${dev_mnt}" =~ / ]]; then
        dev_used="$(df -T | grep -w "${device}" | awk '{print $6}')"
      else
        dev_used="$(swapon -s | grep -w "${device}" | awk '{print $4}')"
        if [[ -n "${dev_used}" ]]; then
          dev_used="${dev_used}%"
        fi
      fi
      [[ -z "${dev_fs}" || "${dev_fs}" == "linux_raid_member" ]] \
        && dev_fs="${empty_value}"
      [[ -z "${dev_used}" ]] && dev_used="${empty_value}"
      [[ -z "${dev_mnt}" ]] && dev_mnt="${empty_value}"
      dev_parent="$(lsblk -dnro PKNAME "/dev/${device/-//}")"
      if [[ -z "${dev_parent}" ]]; then
        dev_type="$(grep -w "${device}" <<<"${DEVICE_LIST}" | awk '{print $3}')"
      else
        dev_type="$(fdisk -lo Device,Type "/dev/${dev_parent}" \
          | grep -w "${device}" \
          | cut -d ' ' -f 2- \
          | sed -e 's/^[[:space:]]*//;s/[[:space:]]*$//;s/ /_/g')"
      fi
      echo "\"${device}\" \"${dev_size} ${dev_used} ${dev_fs} ${dev_mnt} \
${dev_type}\" \\" >>/tmp/gdl/part.list
      (( ++counter ))
    done
    column </tmp/gdl/part.list -t >>/tmp/gdl/part.sh
    echo -e "\"${DONE}\" \"${WRITE_CHANGES}\"" >>/tmp/gdl/part.sh
  fi
}

################################################################################
# Handle root drive partition setup as the first phase of auto-partitioning. A
# separate /efi or /boot partition is created for UEFI and BIOS systems
# respectively, plus a 1 MiB BIOS boot partition for BIOS/GPT systems, along
# with a swap partition unless swap size is zero or '--no-swap' was passed.
#
# Globals: GPT, UEFI, SWAP_SIZE, BOOT_OR_ESP_SIZE, BOOT_OR_ESP, ROOT_DRIVE,
#   ROOT_PART, ROOT_PART_LOAD_MSG
# Arguments: '--no-swap' if a swap partition isn't desired.
# Returns: Number of errors detected.
################################################################################
partition_root_drive() {
  log "* Setting up partitions..."
  if "${GPT}"; then
    if "${UEFI}"; then # UEFI/GPT
      if [[ -z $1 ]] && (( SWAP_SIZE > 0 )); then
        echo -e "n\n\n\n${BOOT_OR_ESP_SIZE}M\nef00\nn\n3\n\n+${SWAP_SIZE}M\n\
8200\nn\n\n\n\n\nw\ny" | gdisk "/dev/${ROOT_DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${ROOT_PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${ROOT_DRIVE}\Zn"
        format_swap_partition "${ROOT_DRIVE}${partition_prefix}3" || return 1
      else
        echo -e "n\n\n\n${BOOT_OR_ESP_SIZE}M\nef00\nn\n\n\n\n\nw\ny" \
          | gdisk "/dev/${ROOT_DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${ROOT_PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${ROOT_DRIVE}\Zn"
      fi
      BOOT_OR_ESP="${ROOT_DRIVE}${partition_prefix}1"
      ROOT_PART="${ROOT_DRIVE}${partition_prefix}2"
      log "  - EFI system partition (ESP) created: ${BOOT_OR_ESP}"
    else # BIOS/GPT
      if [[ -z $1 ]] && (( SWAP_SIZE > 0 )); then
        echo -e "o\ny\nn\n1\n\n+${BOOT_OR_ESP_SIZE}M\n\nn\n2\n\n+1M\nef02\nn\n\
4\n\n+${SWAP_SIZE}M\n8200\nn\n3\n\n\n\nw\ny" | gdisk "/dev/${ROOT_DRIVE}" \
&>/dev/null &
        load_bar "$(eval echo \"${ROOT_PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${ROOT_DRIVE}\Zn"
        format_swap_partition "${ROOT_DRIVE}${partition_prefix}4" || return 1
      else
        echo -e "o\ny\nn\n1\n\n+${BOOT_OR_ESP_SIZE}M\n\nn\n2\n\n+1M\nef02\nn\n3\
\n\n\n\nw\ny" | gdisk "/dev/${ROOT_DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${ROOT_PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${ROOT_DRIVE}\Zn"
      fi
      BOOT_OR_ESP="${ROOT_DRIVE}${partition_prefix}1"
      ROOT_PART="${ROOT_DRIVE}${partition_prefix}3"
      log "  - BIOS boot partition created: ${ROOT_DRIVE}${partition_prefix}2"
    fi
  else # BIOS/MBR
    if [[ -z $1 ]] && (( SWAP_SIZE > 0 )); then
      echo -e "o\nn\np\n1\n\n+${BOOT_OR_ESP_SIZE}M\nn\np\n3\n\n+${SWAP_SIZE}M\n\
t\n\n82\nn\np\n2\n\n\nw" | fdisk "/dev/${ROOT_DRIVE}" &>/dev/null &
      load_bar "$(eval echo \"${ROOT_PART_LOAD_MSG}\")\n\n \Z1> \Z2fdisk \
/dev/${ROOT_DRIVE}\Zn"
      format_swap_partition "${ROOT_DRIVE}${partition_prefix}3" || return 1
    else
      echo -e "o\nn\np\n1\n\n+${BOOT_OR_ESP_SIZE}M\nn\np\n2\n\n\nw" \
        | fdisk "/dev/${ROOT_DRIVE}" &>/dev/null &
      load_bar "$(eval echo \"${ROOT_PART_LOAD_MSG}\")\n\n \Z1> \Z2fdisk \
/dev/${ROOT_DRIVE}\Zn"
    fi
    BOOT_OR_ESP="${ROOT_DRIVE}${partition_prefix}1"
    ROOT_PART="${ROOT_DRIVE}${partition_prefix}2"
  fi
  "${UEFI}" || log "  - Boot partition created: ${BOOT_OR_ESP}"
  log "  - Root partition created: ${ROOT_PART}"
}

################################################################################
# Add a LUKS key slot for file-based opening of a given device, already
# encrypted via a given passphrase, thus avoiding multiple prompts for the same
# passphrase during boot. If the key file does not exist, it is created.
#
# Globals: CRYPT_KEY_FILE
# Arguments: Name of encrypted device (e.g., 'sda2') and its passphrase.
# Returns: Number of errors detected.
################################################################################
add_key_file_slot() {
  set -- "/dev/$1" "$2"

  if [[ ! -b "$1" || -z "$2" ]]; then
    log_error "Invalid argument(s) in 'add_key_file_slot'"
    return 1
  elif [[ ! -f "${CRYPT_KEY_FILE}" ]]; then
    dd bs=512 count=4 if=/dev/random of="${CRYPT_KEY_FILE}" iflag=fullblock
    chmod 000 "${CRYPT_KEY_FILE}"
  fi
  if echo -n "$2" | cryptsetup luksAddKey "$1" "${CRYPT_KEY_FILE}"; then
    log "  - File-based LUKS key slot added for $1"
  else
    log_error "Failed to add file-based LUKS key slot for $1"
    return 1
  fi
}

################################################################################
# Provide a given device's size as measured in bytes or another given unit.
#
# Arguments: Name of the device (e.g., 'sdb' or 'sdb1') and, if bytes are not
#   desired, another desired unit (--kib, --mib, or --gib).
# Outputs: Integer corresponding to the size of the device in the desired unit
#   ('0' if the device name is invalid).
################################################################################
get_device_size() {
  set -- "/dev/$1" "$2"
  local -i size=0

  if [[ -b "$1" ]]; then
    size=$(lsblk -nbo SIZE "$1" | sed -n 1p)
    case "$2" in
      --kib) (( size /= 1024 )) ;;
      --mib) (( size /= 1024 * 1024 )) ;;
      --gib) (( size /= 1024 * 1024 * 1024 )) ;;
    esac
  fi
  echo $size
}

################################################################################
# Present the filesystem menu and return its output.
#
# Globals: SELECT_FS_MSG, FS_EXT4_MSG, FS_BTRFS_MSG, FS_XFS_MSG
# Arguments: None
# Outputs: The selected filesystem (or nothing if the user hits Esc).
################################################################################
get_filesystem() {
  dialog --no-cancel --menu "\n${SELECT_FS_MSG}" 12 60 3 \
    'btrfs' "${FS_BTRFS_MSG}" \
    'ext4' "${FS_EXT4_MSG}" \
    'xfs' "${FS_XFS_MSG}"
}

################################################################################
# Determine whether a given device, or its mount point, is a good candidate for
# an EFI system partition (ESP).
#
# Arguments: Device name (e.g., sda1) and its current or future mount point.
# Returns: '0' if it is a good candidate, '1' otherwise.
################################################################################
is_esp_candidate() {
  if fdisk -l | grep "$1" | grep -q 'EFI' \
      || [[ "$2" == '/efi' || "$2" == '/boot/efi' ]] \
      || ([[ "$2" == '/boot' ]] \
          && efivar -l &>/dev/null \
          && ! mount | grep -q '/efi type vfat'); then
    return 0
  fi

  return 1
}

################################################################################
# After user confirmation, "zap" and "wipe" a given drive, removing any GPT/MBR
# data structures as well as any filesystem/raid/partition signatures.
#
# Globals: WIPE_DRIVE_CONFIRM, WRITE_CHANGES, CANCEL
# Arguments: Name of the drive (e.g., 'sda'), its size in GiB, and the
#   filesystem chosen for it (for use in WIPE_DRIVE_CONFIRM).
# Returns: '0' if the drive is wiped, '1' otherwise.
################################################################################
wipe_drive() {
  local drive="/dev/$1" drive_gib="$2" drive_fs="$3"

  if [[ -z "${drive_gib}" || -z "${drive_fs}" || ! -b "${drive}" ]]; then
    log_error "Invalid argument(s) in 'wipe_drive': $1, $2, $3"
  elif yesno "$(eval echo \"${WIPE_DRIVE_CONFIRM}\")" "${WRITE_CHANGES}" \
      "${CANCEL}" --defaultno; then
    zap_and_wipe "$1" || return 1

    return 0
  fi

  return 1
}

################################################################################
# "Zap" and "wipe" a given storage device (drive or partition), removing any
# GPT/MBR data structures as well as any filesystem/raid/partition signatures.
#
# Globals: WIPEFS_LOAD_MSG
# Arguments: Name of drive/partition to zap and wipe (e.g., 'sda2').
# Returns: Number of errors detected.
################################################################################
zap_and_wipe() {
  set -- "/dev/$1"

  if [[ ! -b "$1" ]]; then
    log_error "Invalid device path in 'zap_and_wipe': $1"
    return 1
  fi
  (
    sgdisk --zap-all "$1"
    wipefs -a "$1"
  ) &>/dev/null &
  load_bar "${WIPEFS_LOAD_MSG}\n\n \Z1> \Z2wipefs -a $1\Zn"
}

################################################################################
# Let the user select a disk utility to modify a given disk's partition table.
#
# Globals: SELECT_DISK_UTIL_MSG, CFDISK_MSG, FDISK_MSG, GDISK_MSG
# Arguments: Name of the disk to be modified (e.g., 'sda').
# Returns: Number of errors detected.
################################################################################
modify_partition_table() {
  set -- "/dev/$1"
  local disk_util

  if [[ ! -b "$1" ]]; then
    log_error "Invalid device path in 'modify_partition_table': $1"
    return 1
  elif disk_util="$(dialog --menu "\n${SELECT_DISK_UTIL_MSG}" 12 60 3 \
      'cfdisk' "${CFDISK_MSG}" \
      'fdisk' "${FDISK_MSG}" \
      'gdisk' "${GDISK_MSG}")"; then
    clear
    "${disk_util}" "$1"
    log "  - Disk $1 edited via ${disk_util}"
    clear
  fi
}

################################################################################
# Format a given partition to serve as swap space and activate it. Also assign
# the partition to SWAP and its size to SWAP_SIZE.
#
# Globals: SWAP, SWAP_SIZE, SWAP_LOAD_MSG
# Arguments: Name of the partition (e.g., 'sda3').
# Returns: Number of errors detected.
################################################################################
format_swap_partition() {
  if [[ ! -b "/dev/$1" ]]; then
    log_error "Invalid device name in 'format_swap_partition': $1"
    return 1
  fi

  SWAP="$1"
  SWAP_SIZE="$(get_device_size "${SWAP}" --mib)"
  (
    wipefs -a "/dev/${SWAP}" \
      && mkswap "/dev/${SWAP}" \
      && swapon "/dev/${SWAP}" \
      && log "  - Swap partition formatted and activated: /dev/${SWAP}"
    sleep 0.6
  ) &>/dev/null &
  load_bar "${SWAP_LOAD_MSG}\n\n \Z1> \Z2mkswap /dev/${SWAP}\Zn"
}

################################################################################
# Attempt to create a new Btrfs subvolume of a given name (which must follow the
# '@' = '/' schema) for a given Btrfs device, then mount it based on its name
# (replacing '@' with '/').
#
# Globals: BTRFS_MOUNT_OPTIONS
# Arguments: New subvolume name (starting with '@') and full Btrfs device path.
# Returns: Number of errors detected.
################################################################################
create_and_mount_btrfs_subvolume() {
  local subvol="$1" device="$2" mount_point
  local -i errors=0

  # Check and process arguments
  log "  - Creating Btrfs subvolume '${subvol}' on ${device}..."
  if [[ "${subvol}" =~ ^@ ]]; then
    mount_point="/mnt${subvol//@//}" # replace all '@' with '/'
    if mount | grep -q " ${mount_point} "; then
      log_error "Mount point ${mount_point} already occupied"
      (( ++errors ))
    elif [[ ! -b "${device}" ]]; then
      log_error "Invalid device path: ${device}"
      (( ++errors ))
    fi
  else
    log_error "Subvolume name '${subvol}' should start with '@'"
    (( ++errors ))
  fi

  # If both arguments seem valid, attempt to create and mount a new subvolume
  if (( errors == 0 )); then
    if mount -m -o "${BTRFS_MOUNT_OPTIONS}" "${device}" /btr &>/dev/null; then
      if mount | grep '/btr' | grep -q 'type btrfs'; then
        if btrfs subvolume create "/btr/${subvol}" &>/dev/null; then
          if mount -m -o "${BTRFS_MOUNT_OPTIONS},subvol=${subvol}" "${device}" \
              "${mount_point}" &>/dev/null; then
            log "  - Mounted '${subvol}' at ${mount_point}"
          else
            log_error "Mounting '${subvol}' at ${mount_point} failed"
            (( ++errors ))
          fi
        else
          log_error "Unable to create subvolume '${subvol}'"
          (( ++errors ))
        fi
      else
        log_error "No Btrfs partition found on ${device}"
        (( ++errors ))
      fi
    else
      log_error "Failed to mount ${device}"
      (( ++errors ))
    fi
    umount /btr &>/dev/null
    rm -r /btr &>/dev/null
  fi

  return $errors
}

################################################################################
# Unmount everything under /mnt, close all encrypted devices, and (optionally)
# turn off swap.
#
# Globals: SYSTEM_MOUNTED, SYSTEM_AUTO_ENCRYPTED, ROOT_DRIVE, ROOT_PART, UEFI,
#   GPT, HOME_DRIVE, BOOT_OR_ESP, BOOT_OR_ESP_MNT, ENABLE_HIBERNATION, SWAP,
#   SWAP_SIZE, WAIT_LOAD_MSG
# Arguments: '--swapoff' if swap should be deactivated.
################################################################################
unmount_and_close_everything() {
  local -i attempts=0 max_attempts=3

  SYSTEM_MOUNTED='false'
  SYSTEM_AUTO_ENCRYPTED='false'
  ENABLE_HIBERNATION='false'
  GPT='false'
  UEFI='false'
  ROOT_DRIVE=''
  ROOT_PART=''
  HOME_DRIVE=''
  BOOT_OR_ESP=''
  BOOT_OR_ESP_MNT=''

  log "* Checking for devices to unmount/deactivate/close..."
  while [[ "$1" == '--swapoff' && -n $(swapon --show) ]] \
      && (( attempts < max_attempts )); do
    SWAP=''
    SWAP_SIZE=''
    log "  - Deactivating swap..."
    swapoff -a &>/dev/null &
    load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2swapoff -a\Zn"
    (( ++attempts ))
  done
  attempts=0
  while lsblk | grep -q '/mnt' && (( attempts < max_attempts )); do
    log "  - Unmounting everything under /mnt..."
    umount -R /mnt &>/dev/null &
    load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2umount -R /mnt\Zn"
    (( ++attempts ))
  done
  attempts=0
  while [[ ! $(dmsetup ls) =~ ^No ]] && (( attempts < max_attempts )); do
    for device in $(dmsetup ls | awk '{print $1}' | sort -r); do
      cryptsetup close "$1" &>/dev/null \
        && log "  - Encrypted device '$1' successfully closed"
    done
    (( ++attempts ))
  done
}

################################################################################
# Prompt user for a hostname until a valid hostname is provided.
#
# Globals: TITLE, SET_HOSTNAME_TITLE, HOSTNAME, OK, SET_HOSTNAME_MSG,
#   HOSTNAME_ERROR_MSG
# Arguments: None
################################################################################
set_hostname() {
  TITLE="${SET_HOSTNAME_TITLE}"
  while true; do
    if HOSTNAME="$(dialog --ok-button "${OK}" --no-cancel --inputbox \
          "\n${SET_HOSTNAME_MSG}" 12 55 "${HOSTNAME}" | tr -d '[:space:]')" \
        && [[ -n "${HOSTNAME}" ]]; then
      if grep -q "^[0-9]\|[\[\$\!\'\"\`\\|%&#@()+=<>~;:/?.,^{}]\|]" \
          <<<"${HOSTNAME}"; then
        message "${HOSTNAME_ERROR_MSG}"
      else
        break
      fi
    fi
  done
  log "Hostname: ${HOSTNAME}"
}

################################################################################
# Prompt user for a username and full name and ensure all input is valid, then
# call 'set_password' to handle password input. (For now, GDL does not support
# creating more than one user during installation.)
#
# Globals: TITLE, ADD_USER_TITLE, USERNAME, FULL_NAME, OK, SET_USERNAME_MSG,
#   USERNAME_EMPTY_ERROR_MSG, USERNAME_CHAR_ERROR_MSG, SET_FULL_NAME_MSG,
#   FULL_NAME_ERROR_MSG
# Arguments: None
################################################################################
set_user() {
  TITLE="${ADD_USER_TITLE}"
  while true; do
    if ! USERNAME="$(dialog --no-cancel --ok-button "${OK}" --inputbox \
          "\n${SET_USERNAME_MSG}" 12 55 | tr -d '[:space:]')" \
        || [[ -z "${USERNAME}" ]]; then
      message "${USERNAME_EMPTY_ERROR_MSG}"
    elif grep -q "^[0-9]\|[A-Z]\|[]:/?#@\!\$&'()*+,;=%[]" <<<"${USERNAME}"; then
      message "${USERNAME_CHAR_ERROR_MSG}"
    else
      log "Username: ${USERNAME}"
      while true; do
        if FULL_NAME="$(dialog --no-cancel --ok-button "${OK}" --inputbox \
            "\n${SET_FULL_NAME_MSG}" 12 55)"; then
          if [[ "${FULL_NAME}" =~ ,|: ]]; then
            message "${FULL_NAME_ERROR_MSG}"
          else
            set_password
            break
          fi
        fi
      done
      break
    fi
  done
}

################################################################################
# Prompt user for a password ('root' will use the same password).
#
# Globals: TITLE, SET_PASSWORD_TITLE, PASSWORD, SSL_KEY, USER_PASSWORD_MSG,
#   USER_PASSWORD_CONFIRM, PASSWORD_EMPTY_MSG, PASSWORD_MISMATCH_MSG, USERNAME
# Arguments: None
################################################################################
set_password() {
  TITLE="${SET_PASSWORD_TITLE}"
  local input input_check

  while true; do
    if ! input="$(dialog --no-cancel --clear --insecure --passwordbox \
          "\n$(eval echo \"${USER_PASSWORD_MSG}\")" 12 60)" \
        || ! input_check="$(dialog --no-cancel --clear --insecure \
          --passwordbox "\n$(eval echo \"${USER_PASSWORD_CONFIRM}\")" 12 60)" \
        || [[ -z "${input}" ]]; then
      message "${PASSWORD_EMPTY_MSG}"
    elif [[ "${input}" != "${input_check}" ]]; then
      message "${PASSWORD_MISMATCH_MSG}"
    else
      break
    fi
  done
  PASSWORD="$(echo "${input}" | openssl enc -aes-256-cbc -a -salt -pbkdf2 \
    -iter 1000 -pass "pass:${SSL_KEY}")"
  unset input input_check
  log "Password set for user: ${USERNAME}"
}

################################################################################
# Provide desktop environment (DE) options and add to the base and AUR package
# lists according to chosen DE, detected hardware, etc.
#
# Globals: TITLE, INSTALLATION_TITLE, BASE_PACKAGES, AUR_PACKAGES, CPU_PACKAGES,
#   GPU_PACKAGES, MISC_PACKAGES, MISC_AUR_PACKAGES, DESKTOP_ENV_AUR_PACKAGES,
#   DESKTOP_ENV_PACKAGES, VM_GUEST_PACKAGES, DESKTOP_ENV, DISPLAY_MANAGER, UEFI,
#   TOUCHPAD_MSG, OS_PROBER_MSG, ROOT_FS, VM_TYPE, DEFAULT, DEFAULT_GPU_DRIVER,
#   GPU_CHIPSET, DESKTOP_ENV_MSG, GPU_VESA_MSG, GPU_DRIVER_MSG, GPU_DEFAULT_MSG,
#   GPU_AMDGPU_MSG, GPU_ATI_MSG, GPU_NVIDIA_OPEN_MSG, GPU_NVIDIA_MSG, YES, NO,
#   GPU_INTEL_MSG, OK
# Arguments: None
################################################################################
prepare_base() {
  TITLE="${INSTALLATION_TITLE}"
  local gpu_driver
  log "Preparing base packages..."

  # Set desktop environment
  until DESKTOP_ENV="$(dialog --stdout --no-cancel --ok-button "${OK}" --menu \
      "\n${DESKTOP_ENV_MSG}" 13 60 4 \
      'KDE Plasma' '->' \
      'GNOME' '->' \
      'Cinnamon' '->' \
      'Xfce' '->')"; do
    continue
  done
  DESKTOP_ENV="$(echo "${DESKTOP_ENV@L}" | tr ' ' '-')"
  BASE_PACKAGES+="${DESKTOP_ENV_PACKAGES[$DESKTOP_ENV]}"
  AUR_PACKAGES+="${DESKTOP_ENV_AUR_PACKAGES[$DESKTOP_ENV]}"
  log "* Desktop environment: ${DESKTOP_ENV}"

  # Set display manager (login manager)
  case "${DESKTOP_ENV}" in
    kde-plasma) DISPLAY_MANAGER='sddm' ;; # default to SDDM for KDE Plasma
    gnome) DISPLAY_MANAGER='gdm' ;; # default to GDM for GNOME
    *) DISPLAY_MANAGER='lightdm' ;; # default to LightDM for Cinnamon/Xfce
  esac
  BASE_PACKAGES+="${MISC_PACKAGES[$DISPLAY_MANAGER]}"
  AUR_PACKAGES+="${MISC_AUR_PACKAGES[$DISPLAY_MANAGER]}"
  log "* Display manager: ${DISPLAY_MANAGER}"

  # Add packages based on hardware and user input
  for cpu in "${!CPU_PACKAGES[@]}"; do
    grep -q "${cpu}" /proc/cpuinfo && BASE_PACKAGES+="${CPU_PACKAGES[$cpu]}"
  done
  if yesno "${TOUCHPAD_MSG}" "${YES}" "${NO}" --defaultno; then
    BASE_PACKAGES+="${MISC_PACKAGES[touchpad]}"
    log "* Added touchpad support"
  fi
  if yesno "${OS_PROBER_MSG}" "${YES}" "${NO}" --defaultno; then
    BASE_PACKAGES+="${MISC_PACKAGES[multi-boot]}"
    log "* Added dual/multi-boot support"
  fi

  # Add graphics/VM packages
  if [[ "${VM_TYPE}" != 'none' ]]; then
    BASE_PACKAGES+="${VM_GUEST_PACKAGES[$VM_TYPE]}" \
      && log "* Added VM guest utils"
  else # not a VM
    if [[ "${GPU_CHIPSET}" == 'NVIDIA' ]]; then
      until gpu_driver="$(dialog --ok-button "${OK}" --no-cancel --menu \
          "\n$(eval echo \"${GPU_DRIVER_MSG}\")" 18 60 7 \
          "${DEFAULT}" "${GPU_DEFAULT_MSG}" \
          'nvidia-dkms' "${GPU_NVIDIA_MSG}" \
          'nvidia-open-dkms' "${GPU_NVIDIA_OPEN_MSG}" \
          'xf86-video-nouveau' "${GPU_NVIDIA_OPEN_MSG}" \
          'xf86-video-intel' "${GPU_INTEL_MSG}" \
          'xf86-video-vesa' "${GPU_VESA_MSG}" \
          'xf86-video-amdgpu' "${GPU_AMDGPU_MSG}" \
          'xf86-video-ati' "${GPU_ATI_MSG}")"; do
        continue
      done
    else
      until gpu_driver="$(dialog --ok-button "${OK}" --no-cancel --menu \
          "\n$(eval echo \"${GPU_DRIVER_MSG}\")" 17 60 6 \
          "${DEFAULT}" "${GPU_DEFAULT_MSG}" \
          'xf86-video-amdgpu' "${GPU_AMDGPU_MSG}" \
          'xf86-video-ati' "${GPU_ATI_MSG}" \
          'xf86-video-intel' "${GPU_INTEL_MSG}" \
          'xf86-video-vesa' "${GPU_VESA_MSG}" \
          'nvidia-dkms' "${GPU_NVIDIA_MSG}" \
          'nvidia-open-dkms' "${GPU_NVIDIA_OPEN_MSG}" \
          'xf86-video-nouveau' "${GPU_NVIDIA_OPEN_MSG}")"; do
        continue
      done
    fi
    [[ "${gpu_driver}" == "${DEFAULT}" ]] && gpu_driver="${DEFAULT_GPU_DRIVER}"
    BASE_PACKAGES+="${gpu_driver} ${GPU_PACKAGES[$gpu_driver]}"
    log "* Added graphics driver: ${gpu_driver}"
  fi
}

################################################################################
# Present categorized software menus and add selected and supplemental packages
# to the base package list (some may be moved to the AUR list later).
#
# Globals: TITLE, SELECT_SOFTWARE_MSG, BASE_PACKAGES, AUR_PACKAGES, DESKTOP_ENV,
#   OPTIONAL_SOFTWARE_LISTS, DEFAULT_OPTIONAL_SOFTWARE, MISC_AUR_PACKAGES, BACK,
#   MISC_PACKAGES, WINE_PACKAGES, LOCALE, INSTALLATION_TITLE, INSTALL_CONFIRM,
#   ERRORS_LOGGED, ROOT_FS, OK, and various menu titles and package descriptions
# Arguments: None
################################################################################
select_additional_software() {
  local package_desc_var_name new_software=" ${DEFAULT_OPTIONAL_SOFTWARE} " \
     selections
  local -a current_list options
  local -i i j list_len menu_num=0 num_menus=${#OPTIONAL_SOFTWARE_LISTS[@]}

  [[ "${ROOT_FS}" == 'btrfs' ]] && new_software+='timeshift '

  # Present software menus
  while (( menu_num < num_menus )); do
    readarray -t current_list < <(echo "${OPTIONAL_SOFTWARE_LISTS[menu_num]}")
    list_len=${#current_list[@]}
    TITLE="${!current_list[0]}"
    options=()
    j=0
    for (( i = 1; i < list_len; ++i )); do
      options[j++]="${current_list[i]}" # package name
      package_desc_var_name="SOFTWARE_${current_list[i]@U}"
      package_desc_var_name="${package_desc_var_name//-/_}"
      options[j++]="${!package_desc_var_name}" # package description
      options[j++]="$([[ "${new_software}" =~ " ${current_list[i]} " ]] \
        && echo 'ON' \
        || echo 'OFF')"
    done
    if (( menu_num == 0 )); then
      if selections=" $(dialog --no-cancel --ok-button "${OK}" --checklist \
          "\n${SELECT_SOFTWARE_MSG}" 0 0 0 "${options[@]}") "; then
        (( menu_num++ ))
      fi
    elif selections=" $(dialog --ok-button "${OK}" --cancel-button "${BACK}" \
        --checklist "\n${SELECT_SOFTWARE_MSG}" 0 0 0 "${options[@]}") "; then
      (( menu_num++ ))
    else
      (( menu_num-- ))
      continue
    fi
    for (( i = 1; i < list_len; ++i )); do
      if [[ "${selections}" =~ " ${current_list[i]} " ]]; then
        [[ "${new_software}" =~ " ${current_list[i]} " ]] \
          || new_software+="${current_list[i]} "
      else
        new_software="${new_software// ${current_list[i]} / }"
      fi
    done
    if (( menu_num == num_menus )); then
      TITLE="${INSTALLATION_TITLE}"
      yesno "${INSTALL_CONFIRM}" "${OK}" "${BACK}" --defaultno \
        || (( menu_num-- ))
    fi
  done

  # Remove conflicting software
  [[ "${new_software}" =~ office-fresh && "${new_software}" =~ office-still ]] \
    && new_software="${new_software// libreoffice-still / }"

  # Add selected and supplemental software to appropriate package lists
  log "Optional packages:${new_software}"
  [[ "${new_software}" =~ lutris|bottles|playonlinux ]] \
    && BASE_PACKAGES+="${WINE_PACKAGES}"
  [[ "${LOCALE}" =~ zh_|yue_|_CN|_HK|_SG|_TW|ja_|ko_ \
    || "${new_software}" =~ ibus ]] && BASE_PACKAGES+="${MISC_PACKAGES[cjk]}"
  for new_package in ${new_software}; do
    package_desc_var_name="SOFTWARE_${new_package@U}"
    package_desc_var_name="${package_desc_var_name//-/_}"
    if [[ "${!package_desc_var_name}" =~ AUR ]]; then
      AUR_PACKAGES+="${new_package} "
    else
      BASE_PACKAGES+="${new_package} "
    fi
    case "${new_package}" in
      insync) AUR_PACKAGES+="${MISC_AUR_PACKAGES[insync-$DESKTOP_ENV]}" ;;
      timeshift)
        [[ "${ROOT_FS}" == 'btrfs' ]] \
          && AUR_PACKAGES+="${MISC_AUR_PACKAGES[timeshift-btrfs]}"
        ;;
      unityhub)
        if [[ "${new_software}" =~ ' code ' ]]; then
          BASE_PACKAGES+="${MISC_PACKAGES[unity-vscode]}"
          AUR_PACKAGES+="${MISC_AUR_PACKAGES[unity-vscode]}"
        elif [[ "${new_software}" =~ visual-studio-code-bin ]]; then
          BASE_PACKAGES+="${MISC_PACKAGES[unity-vscode]}"
        fi
        ;;
      *)
        BASE_PACKAGES+="${MISC_PACKAGES[$new_package]}"
        AUR_PACKAGES+="${MISC_AUR_PACKAGES[$new_package]}"
        ;;
    esac
  done
}

################################################################################
# Organize base package list, move any packages not found in official repos to
# the AUR list, and install base packages via pacstrap. If pacstrap fails,
# upload log file to termbin and present the resulting URL before exiting.
#
# Globals: BASE_PACKAGES, AUR_PACKAGES, ERRORS_LOGGED, PACSTRAP_ERROR_MSG,
#   LOG_FILE
# Arguments: None
################################################################################
install_base() {
  local log_url pacstrap_list=''

  # Ensure system clock is accurate (if done earlier, annoying messages appear)
  timedatectl set-ntp true

  # Update keyring
  log "Updating Arch Linux keyring..."
  dragonsay "Updating Arch Linux keyring..."
  pacman-key --init 2> >(tee -a "${LOG_FILE}")
  while ! pacman -Sy archlinux-keyring --needed --noconfirm \
      2> >(tee -a "${LOG_FILE}") && try_again "Keyring update failed"; do
    continue
  done

  # Clean and sort package lists, moving packages to AUR list as appropriate
  # (this also helps protect against future changes to package availability)
  BASE_PACKAGES="$(tr <<<"${BASE_PACKAGES}" ' ' '\n' \
    | sort \
    | uniq \
    | tr '\n' ' ')"
  for package in ${BASE_PACKAGES}; do
    if (pacman -Si "${package}" || pacman -Sg "${package}") &>/dev/null; then
      pacstrap_list+="${package} "
      echo "Package '${package}' confirmed"
    else
      AUR_PACKAGES+="${package} "
      echo "Package '${package}' not found in official repos: moved to AUR list"
    fi
  done
  log "Base package list: ${pacstrap_list}"
  AUR_PACKAGES="$(tr <<<"${AUR_PACKAGES}" ' ' '\n' | sort | uniq | tr '\n' ' ')"
  log "AUR package list: ${AUR_PACKAGES}"

  # Begin installation
  log "Installing base packages..."
  dragonsay "Installing base packages..."
  while true; do
    if pacstrap /mnt ${pacstrap_list} 2> >(tee -a "${LOG_FILE}"); then
      log "Base installation completed successfully"
      break
    elif ! try_again "Pacstrap failed"; then
      log "Uplodaing log to termbin... (errors logged: ${ERRORS_LOGGED})"
      log_url="$(nc termbin.com 9999 <"${LOG_FILE}")"
      log "Log uploaded to termbin: ${log_url}"
      message "${PACSTRAP_ERROR_MSG} ${log_url}"
      return_to_shell_prompt
    fi
  done
}

################################################################################
# Configure the freshly-installed GDL system.
#
# Globals: SYSTEM_AUTO_ENCRYPTED, BASE_PACKAGES, UEFI, ROOT_DRIVE, ROOT_PART,
#   ROOT_FS, ROOT_LV, ROOT_PART_UUID, BOOT_OR_ESP, BOOT_OR_ESP_MNT, HOME_DRIVE,
#   HOME_FS, HOME_DRIVE_UUID, SWAP, SWAP_SIZE, RAM, HOSTNAME, PASSWORD, SSL_KEY,
#   CRYPT_KEY_FILE, ENABLE_HIBERNATION, LOCALE, KEYMAP, TIME_ZONE, VM_TYPE,
#   DISPLAY_MANAGER, DESKTOP_ENV, BTRFS_MOUNT_OPTIONS
# Arguments: None
################################################################################
configure_system() {
  local pw fstab='/mnt/etc/fstab' extra='/usr/share/gdl/extra' \
    gdl_system_file='/mnt/etc/tmpfiles.d/gdl-system.conf' \
    grub='/mnt/etc/default/grub' grub_theme='/boot/grub/themes/gdl' \
    grub_install_command='grub-install'

  log "Configuring system..."
  dragonsay "Configuring system..."

  # Initial fstab config
  genfstab -U /mnt >>"${fstab}" && log "* Generated fstab"

  # Optimize system and enable SysRq keyboard shortcuts via systemd-tmpfiles
  cp "${extra}/gdl-system.conf" "${gdl_system_file}" \
    && log "* Added ${gdl_system_file:4}"

  # GRUB config
  mkdir -p "/mnt${grub_theme}"
  cp -rT "${extra}/grub" "/mnt${grub_theme}"
  if (! mount | grep -q ' /mnt/boot ' && [[ "${ROOT_FS}" != 'btrfs' ]]) \
      || mount | grep -q ' /mnt/boot type [^b]'; then
    sed -i 's/GRUB_DEFAULT=0/GRUB_DEFAULT=saved/' "${grub}"
    sed -i 's/#GRUB_SAVEDEFAULT/GRUB_SAVEDEFAULT/' "${grub}"
  fi
  sed -i 's/GRUB_TIMEOUT=5/GRUB_TIMEOUT=3/' "${grub}"
  sed -i "s/GRUB_GFXM.*/GRUB_GFXMODE=1920x1080,1366x768,auto/" "${grub}"
  sed -i "s:#GRUB_COLOR_N.*:GRUB_COLOR_NORMAL=\"red/black\":" "${grub}"
  sed -i "s:#GRUB_COLOR_H.*:GRUB_COLOR_HIGHLIGHT=\"yellow/black\":" "${grub}"
  sed -i "s:#GRUB_THEME.*:GRUB_THEME=\"${grub_theme}/theme.txt\":" "${grub}"
  if "${SYSTEM_AUTO_ENCRYPTED}"; then
    [[ -f "${CRYPT_KEY_FILE}" ]] && mv "${CRYPT_KEY_FILE}" /mnt/etc
    sed -i "s!quiet!cryptdevice=UUID=${ROOT_PART_UUID}:cryptlvm:allow-discards \
root=/dev/${ROOT_LV}!" "${grub}"
    "${UEFI}" && sed -i "s!ards !&cryptkey=rootfs:${CRYPT_KEY_FILE} !" "${grub}"
    sed -i "s/#GRUB_ENABLE_CRYPT.*/GRUB_ENABLE_CRYPTODISK=y/" "${grub}"
  else
    sed -i 's/ quiet//' "${grub}"
  fi
  if [[ "${BASE_PACKAGES}" =~ nvidia ]]; then
    sed -i '/LINUX_DEF/s/.$/ nvidia-drm.modeset=1&/' "${grub}"
  fi
  if "${ENABLE_HIBERNATION}"; then
    sed -i "/LINUX_DEF/s/.$/ resume=UUID=$(lsblk -no UUID "/dev/${SWAP}")&/" \
      "${grub}"
  fi
  if "${UEFI}"; then
    grub_install_command+=" --target=x86_64-efi --bootloader-id=GRUB \
--efi-directory=${BOOT_OR_ESP_MNT}"
  else
    grub_install_command+=" /dev/${ROOT_DRIVE}"
  fi
  while true; do
    if arch-chroot /mnt ${grub_install_command} --recheck; then
      sed -i "s:reinstallgrub=':&sudo ${grub_install_command} \&\& updategrub:"\
        "${extra}/skel/.bashrc" # for future GRUB repair (rarely needed)
      sed -i 's:id=GRUB:&\\\n :' "${extra}/skel/.bashrc" # fix line length
      if "${UEFI}"; then
        if [[ ! -f "/mnt${BOOT_OR_ESP_MNT}/EFI/BOOT/bootx64.efi" ]]; then
          mkdir "/mnt${BOOT_OR_ESP_MNT}/EFI/BOOT"
          cp "/mnt${BOOT_OR_ESP_MNT}/EFI/GRUB/grubx64.efi" \
            "/mnt${BOOT_OR_ESP_MNT}/EFI/BOOT/bootx64.efi" # needed in some cases
        fi
        log "* Installed GRUB (UEFI)"
      else
        log "* Installed GRUB (BIOS)"
      fi
      break
    else
      try_again "GRUB installation failed" || break
    fi
  done

  # NVIDIA GPU config
  if [[ "${BASE_PACKAGES}" =~ nvidia ]]; then
    sed -i 's/^MODULES=(/&nvidia nvidia_modeset nvidia_uvm nvidia_drm /' \
      /mnt/etc/mkinitcpio.conf
    echo -e 'options nvidia-drm modeset=1\nblacklist nouveau' \
      >/mnt/etc/modprobe.d/nvidia.conf
    sed -i 's:^FILES=(:&/etc/modprobe.d/nvidia.conf :;s/ )/)/' \
      /mnt/etc/mkinitcpio.conf
    log "* Enabled NVIDIA DRM (Direct Rendering Manager)"
    if lspci | grep 'VGA' | grep -Eq 'Intel|ATI|AMD'; then
      echo 'GAMEMODERUNEXEC=prime-run' >>/mnt/etc/environment
      log "* Configured GameMode to always enable NVIDIA PRIME render offload"
    fi
  fi

  # Btrfs config
  if mount | grep -q 'type btrfs'; then
    sed -i 's/^MODULES=(/&btrfs /;s/ )/)/' /mnt/etc/mkinitcpio.conf \
      && log "* Configured system for Btrfs"
  fi

  # XFS config
  if mount | grep -q 'type xfs'; then
    sed -i 's/^MODULES=(/&xfs /;s/ )/)/' /mnt/etc/mkinitcpio.conf \
      && log "* Configured system for XFS"
  fi

  # NVMe config
  if mount | grep -q 'nvme'; then
    sed -i 's/^MODULES=(/&nvme /;s/ )/)/' /mnt/etc/mkinitcpio.conf \
      && log "* Configured system for NVMe"
  fi

  # Additional fstab, crypttab, and mkinitcpio config
  if "${SYSTEM_AUTO_ENCRYPTED}"; then
    # Unencrypted boot/EFI partition
    if "${UEFI}"; then
      echo "/dev/${BOOT_OR_ESP} ${BOOT_OR_ESP_MNT} vfat rw,relatime,fmask=0022,\
dmask=0022,codepage=437,iocharset=utf8,shortname=mixed,utf8,errors=remount-ro \
0 2" >"${fstab}"
    else
      echo "/dev/${BOOT_OR_ESP} ${BOOT_OR_ESP_MNT} ext4 defaults 0 2" \
        >"${fstab}"
    fi
    # Encrypted root partition
    if [[ "${ROOT_FS}" == 'btrfs' ]]; then
      echo "/dev/${ROOT_LV} / btrfs ${BTRFS_MOUNT_OPTIONS},subvol=@ 0 0
/dev/${ROOT_LV} /var/log btrfs ${BTRFS_MOUNT_OPTIONS},subvol=@var@log 0 0
/dev/${ROOT_LV} /var/cache btrfs ${BTRFS_MOUNT_OPTIONS},subvol=@var@cache 0 0" \
        >>"${fstab}"
      if [[ -z "${HOME_DRIVE}" ]]; then
        echo "/dev/${ROOT_LV} /home btrfs ${BTRFS_MOUNT_OPTIONS},subvol=@home \
0 0" >>"${fstab}"
      fi
    else
      echo "/dev/${ROOT_LV} / ${ROOT_FS} defaults 0 1" >>"${fstab}"
    fi
    # Encrypted home partition
    if [[ -n "${HOME_DRIVE}" ]]; then
      if [[ "${HOME_FS}" == 'btrfs' ]]; then
        echo "/dev/mapper/crypthome /home btrfs ${BTRFS_MOUNT_OPTIONS},subvol=\
@home 0 0" >>"${fstab}"
      else
        echo "/dev/mapper/crypthome /home ${HOME_FS} defaults 0 1" >>"${fstab}"
      fi
      echo "crypthome UUID=${HOME_DRIVE_UUID} ${CRYPT_KEY_FILE}" \
        >>/mnt/etc/crypttab
    fi
    # Encrypted SWAP
    if (( SWAP_SIZE > 0 )); then
      echo "/dev/${SWAP} none swap defaults 0 0" >>"${fstab}"
    fi
    # mkinitcpio
    sed -i "s/^HOOKS=.*/HOOKS=(base udev autodetect microcode modconf kms \
keyboard keymap block encrypt lvm2 filesystems fsck)/" /mnt/etc/mkinitcpio.conf
    "${UEFI}" && sed -i "s:^FILES=(:&${CRYPT_KEY_FILE} :;s/ )/)/" \
      /mnt/etc/mkinitcpio.conf
    log "* Configured system for encryption"
  else # not auto-encrypted
    sed -i "s/^HOOKS=.*/HOOKS=(base udev autodetect microcode modconf kms \
keyboard keymap block filesystems fsck)/" /mnt/etc/mkinitcpio.conf
  fi
  if "${ENABLE_HIBERNATION}"; then
    sed -i 's/^HOOKS=.*filesystems/& resume/' /mnt/etc/mkinitcpio.conf \
      && log "* Configured system for hibernation"
    (( SWAP_SIZE <= RAM )) \
      && echo 'w /sys/power/image_size - - - - 0' >>"${gdl_system_file}" \
      && log "  - Image size minimized via ${gdl_system_file:4}"
  fi
  sed -i 's/	/ /g' "${fstab}" # remove tabs
  sed -i 's/ \+/ /g' "${fstab}" # remove extraneous spaces
  sed -Ei '/btrfs|xfs/s/0 [^0]$/0 0/' "${fstab}" # remove fsck for btrfs/xfs
  while true; do
    if arch-chroot /mnt mkinitcpio -P; then
      log "* Created new initramfs"
      break
    else
      try_again "Failed to create new initramfs" || break
    fi
  done

  # Locale config
  sed -i "/#${LOCALE}/s/#//" /mnt/etc/locale.gen
  sed -i '/#en_US.UTF-8/s/#//' /mnt/etc/locale.gen
  echo "LANG=${LOCALE}" >/mnt/etc/locale.conf
  arch-chroot /mnt locale-gen
  if [[ "${LOCALE}" =~ zh_|yue_|ja_ ]]; then
    sed -i 's/%A, %B %-e, %Y/%Y年%B%-e日/' \
      "${extra}/lightdm/lightdm-gtk-greeter.conf"
    sed -i 's/%-l:%M:%S %p, %A, %B %-e, %Y/%Y年%B%-e日 %A%p%I:%M:%S/' \
      "${extra}/xfce/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-panel.xml"
    sed -i 's/%A, %B %-e/%Y年%B%-e日/ ; /weekday/s/true/false/' \
      "${extra}/skel/.config/gdl-config-script"
  fi
  log "* Set system locale: ${LOCALE}"

  # Keyboard config
  echo "KEYMAP=${KEYMAP}" >>/mnt/etc/vconsole.conf
  echo -e "Section \"InputClass\"\nIdentifier \"system-keyboard\"\n\
MatchIsKeyboard \"on\"\nOption \"XkbLayout\" \"${KEYMAP}\"\nEndSection" \
    >/mnt/etc/X11/xorg.conf.d/00-keyboard.conf
  log "* Set system keymap: ${KEYMAP}"

  # Time zone and hardware clock config
  ln -sf "/usr/share/zoneinfo/${TIME_ZONE}" /mnt/etc/localtime \
    && log "* Set system time zone: ${TIME_ZONE}"
  arch-chroot /mnt hwclock --systohc && log "* Generated /etc/adjtime"

  # Here be daemons...
  log "* Configuring systemd services..."

  # Package cache cleanup
  arch-chroot /mnt pacman -Q pacman-contrib &>/dev/null \
    && enable_service paccache.timer

  # VM config
  case "${VM_TYPE}" in
    qemu) enable_service qemu-guest-agent.service ;;
    oracle) enable_service vboxservice.service ;;
    vmware)
      cat /mnt/proc/version >/mnt/etc/arch-release
      enable_service vmtoolsd.service
      enable_service vmware-vmblock-fuse.service
      mkdir -pv /mnt/etc/init.d/rc{0..6}.d
      ;;
  esac
  if [[ "${VM_TYPE}" != 'none' && "${DESKTOP_ENV}" == 'xfce' ]]; then
    sed -Ei '/cpufreq|cpugraph|sensors|value="[578]"/d' \
      "${extra}/xfce/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-panel.xml"
    rm "${extra}/xfce/.config/xfce4/panel/xfce4-sensors-plugin-7.rc" \
      "${extra}/xfce/.config/xfce4/panel/cpu"*
  fi

  # Network, firewall, and bluetooth config
  arch-chroot /mnt pacman -Q networkmanager &>/dev/null \
    && enable_service NetworkManager.service
  if arch-chroot /mnt pacman -Q ufw &>/dev/null; then
    arch-chroot /mnt ufw enable
    enable_service ufw.service
    arch-chroot /mnt pacman -Q kdeconnect &>/dev/null \
      && arch-chroot /mnt ufw allow 1714:1764/udp \
      && arch-chroot /mnt ufw allow 1714:1764/tcp \
      && log "  - Opened UFW ports for KDE Connect"
  fi
  if lsusb | grep -qi 'bluetooth' || dmesg | grep -qi 'bluetooth'; then
    enable_service bluetooth.service
  fi

  # Display manager (login manager) config
  [[ -d /mnt/etc/lightdm ]] && cp -rT "${extra}/lightdm" /mnt/etc/lightdm
  if [[ "${DESKTOP_ENV}" == 'kde-plasma' ]]; then
    mkdir /mnt/etc/sddm.conf.d
    echo -e "[Autologin]\nRelogin=false\nSession=\nUser=\n\n[General]\n\
HaltCommand=/usr/bin/systemctl poweroff\nRebootCommand=/usr/bin/systemctl \
reboot\n\n[Theme]\nCurrent=breeze\n\n[Users]\nMaximumUid=60513\n\
MinimumUid=1000" >/mnt/etc/sddm.conf.d/kde_settings.conf
    sed -i "s:background.*:background=/usr/share/backgrounds/gdl/\
gds-drake-dark-1920x1080.jpg:" /mnt/usr/share/sddm/themes/breeze/theme.conf
  fi
  enable_service "${DISPLAY_MANAGER}.service"

  # CPU, temperature, and power management
  arch-chroot /mnt pacman -Q cpupower &>/dev/null \
    && enable_service cpupower.service
  arch-chroot /mnt pacman -Q thermald &>/dev/null \
    && enable_service thermald.service
  arch-chroot /mnt pacman -Q tlp &>/dev/null && enable_service tlp.service

  # Kernel module cleanup
  arch-chroot /mnt pacman -Q kernel-modules-hook &>/dev/null \
    && enable_service linux-modules-cleanup.service

  # Weekly TRIM for all drives that support 'discard'
  enable_service fstrim.timer

  # CUPS printing system
  arch-chroot /mnt pacman -Q cups &>/dev/null && enable_service cups.socket

  # Avahi (for discovering printers and other devices/services)
  if arch-chroot /mnt pacman -Q avahi &>/dev/null; then
    enable_service avahi-daemon.service
    sed -i 's/hosts: mymachines/& mdns_minimal [NOTFOUND=return]/' \
      /mnt/etc/nsswitch.conf
  fi

  # GRUB Btrfs snapshot support
  arch-chroot /mnt pacman -Q grub-btrfs &>/dev/null \
    && enable_service grub-btrfsd.service

  # Cursor theme
  tar xf /usr/share/gdl/extra/breeze-amber.tar.xz -C /mnt/usr/share/icons \
    && log "* Manually installed Breeze Amber cursor theme"

  # Desktop config
  cp -rT "${extra}/${DESKTOP_ENV}" "${extra}/skel"
  if [[ "${DESKTOP_ENV}" == 'kde-plasma' ]]; then
    arch-chroot /mnt pacman -S appstream --noconfirm # fix Discover issue
    sed -i 's:export VIS.*:&\nexport SSH_ASKPASS=/usr/bin/ksshaskpass\n\
export SSH_ASKPASS_REQUIRE=prefer:' "${extra}/skel/.bashrc"
  elif [[ "${DESKTOP_ENV}" != 'gnome' ]]; then # Cinnamon/Xfce
    # shellcheck disable=SC2016
    sed -i 's:export VIS.*:&\nexport SSH_AUTH_SOCK=$XDG_RUNTIME_DIR/gcr/ssh\n\
export GTK_THEME=Matcha-dark-aliz:' "${extra}/skel/.bashrc"
    if [[ "${DESKTOP_ENV}" == 'xfce' ]]; then
      mv "${extra}/skel/toggle-touchpad" /mnt/usr/local/bin
      echo "
xset -b                              # turn off alert bell/beep
setxkbmap -option 'numpad:microsoft' # adjust shift+numpad behavior
xfce-superkey                        # open Whisker Menu via Super key" \
        >>"${extra}/skel/.xprofile"
    fi
  fi
  if arch-chroot /mnt pacman -Q ibus &>/dev/null \
      && [[ "${DESKTOP_ENV}" != 'gnome' ]]; then
    echo -e "\n# IBus\nexport GTK_IM_MODULE=ibus\nexport QT_IM_MODULE=ibus\n\
export XMODIFIERS=@im=ibus\npgrep ibus-daemon || ibus-daemon -rxRd" \
      >>"${extra}/skel/.xprofile"
    [[ "${DESKTOP_ENV}" == 'kde-plasma' ]] \
      && echo -e "\n[Wayland]\nInputMethod[\$e]=/usr/share/applications/org.\
freedesktop.IBus.Panel.Wayland.Gtk3.desktop" >>"${extra}/skel/.config/kwinrc"
  fi
  mkdir -p /mnt/usr/share/backgrounds/gdl
  cp -rT "${extra}/wallpapers" /mnt/usr/share/backgrounds/gdl
  cp -rT "${extra}/icons" /mnt/usr/share/pixmaps
  cp -rT "${extra}/skel" /mnt/etc/skel
  log "* Configured desktop environment"

  # Pacman config
  [[ -f /mnt/var/lib/pacman/db.lck ]] && rm /mnt/var/lib/pacman/db.lck
  sed -Ei '/#Ver|#Par/s/#// ; s/#Color/Color\nILoveCandy/' /mnt/etc/pacman.conf
  sed -zi 's/#\[multilib]\n#Include/[multilib]\nInclude/' /mnt/etc/pacman.conf
  log "* Configured pacman"

  # Hostname config
  echo "${HOSTNAME}" >/mnt/etc/hostname
  echo -e "127.0.0.1 localhost\n::1 localhost\n127.0.1.1 \
${HOSTNAME}.localdomain ${HOSTNAME}" >>/mnt/etc/hosts
  log "* Set system hostname: ${HOSTNAME}"

  # Set root user password
  pw="$(echo "${PASSWORD}" | openssl enc -aes-256-cbc -a -d -salt -pbkdf2 \
    -iter 1000 -pass "pass:${SSL_KEY}")"
  printf "%s\n%s" "${pw}" "${pw}" | arch-chroot /mnt passwd root
  unset pw

  # Allow privilege elevation via sudo
  sed -i '/%wheel ALL=(ALL:ALL) ALL/s/^# //' /mnt/etc/sudoers

  # Link `vi` to `vim`
  ln -s vim /mnt/usr/bin/vi

  # Ensure proper MIDI support for certain media players
  ln -s libfluidsynth.so.3 /mnt/usr/lib/libfluidsynth.so.2
  mkdir -p /mnt/usr/share/sounds/sf2
  ln -s /usr/share/soundfonts/FluidR3_GM.sf2 /mnt/usr/share/sounds/sf2/

  # Add a group for GameMode to ensure it can "renice" processes
  arch-chroot /mnt pacman -Q gamemode &>/dev/null \
    && arch-chroot /mnt groupadd -g 2000 gamemode
}

################################################################################
# Enable a given systemd service within the newly-installed system.
#
# Arguments: Name of the service.
# Returns: Number of errors detected.
################################################################################
enable_service() {
  if [[ -n "$1" ]] && arch-chroot /mnt systemctl enable "$1"; then
    log "  - Enabled '$1'"
  else
    log_error "Failed to enable '$1'"
    return 1
  fi
}

################################################################################
# Install AUR helper 'yay' (yay-bin) and use it to install AUR packages. If a
# package fails, provide the option to try again.
#
# Globals: AUR_PACKAGES, ROOT_FS, ROOT_PART, ROOT_LV, SYSTEM_AUTO_ENCRYPTED,
#   DESKTOP_ENV, LVM_UUID
# Arguments: None
################################################################################
install_aur_software() {
  local pw uuid package supplement failed_packages=''

  # Ensure superfluous 'debug' packages are not installed by 'yay'
  sed -i '/^OPTIONS=/s/ debug/ !debug/' /mnt/etc/makepkg.conf

  # Create a temporary user for installing and using 'yay'
  log "Installing AUR helper 'yay' (yay-bin)..."
  dragonsay "Setting up AUR support..."
  pw="$(</dev/urandom tr -dc "@#*%&_A-Z-a-z-0-9" | head -c16)"
  mkdir /mnt/yaytemp
  chmod 777 /mnt/yaytemp
  arch-chroot /mnt useradd -rNM -d /yaytemp -s /usr/bin/nologin yaybuilder
  arch-chroot /mnt sh -c "echo -e '${pw}\n${pw}\n' | passwd yaybuilder"
  echo 'yaybuilder ALL=(ALL:ALL) NOPASSWD: ALL
root ALL=(yaybuilder) NOPASSWD: ALL' >/mnt/etc/sudoers.d/yaybuilder

  # Install 'yay'
  while true; do
    if arch-chroot /mnt sh -c "cd /yaytemp \
        && sudo -u yaybuilder git clone https://aur.archlinux.org/yay-bin.git \
        && cd yay-bin \
        && sudo -u yaybuilder makepkg -si --noconfirm"; then
      log "Installing AUR packages..."
      break
    elif ! try_again "Failed to install AUR helper 'yay'"; then
      AUR_PACKAGES=''
      break
    fi
  done

  # Install AUR packages
  while [[ -n "${AUR_PACKAGES}" ]]; do
    failed_packages=''
    for package in ${AUR_PACKAGES}; do
      dragonsay "Installing ${package}..."
      if (! arch-chroot /mnt sudo -u yaybuilder yay -Si "${package}" \
            && ! arch-chroot /mnt sudo -u yaybuilder yay -Sg "${package}") \
          || ! arch-chroot /mnt sudo -u yaybuilder yay -Syu "${package}" \
            --needed --noconfirm; then
        failed_packages+="${package} "
      else
        log "* Installed '${package}'"
      fi
    done
    if [[ -n "${failed_packages}" ]]; then
      try_again "$(wc -w <<<"${failed_packages}") package(s) failed to \
install: ${failed_packages}" || break
    fi
    AUR_PACKAGES="${failed_packages}"
  done
  [[ -n "${failed_packages}" ]] && log "Failed package(s): ${failed_packages}"

  # Install locale-based supplemental packages
  if arch-chroot /mnt pacman -Q firefox &>/dev/null; then
    supplement='firefox-i18n-'
    case "${LOCALE}" in
      ca*val*) supplement+='ca-valencia' ;; # Catalan (Valencia)
      en_CA*) supplement+='en-ca' ;; # English (Canada)
      en_US*) supplement+='en-us' ;; # English (United States)
      en_*) supplement+='en-gb' ;; # English (Great Britain)
      es_AR*) supplement+='es-ar' ;; # Spanish (Argentina)
      es_CL*) supplement+='es-cl' ;; # Spanish (Chile)
      es_MX*) supplement+='es-mx' ;; # Spanish (Mexico)
      es_*) supplement+='es-es' ;; # Spanish (Spain)
      fy_*) supplement+='fy-nl' ;; # Frisian
      ga_*) supplement+='ga-ie' ;; # Irish
      gn_*|gug_*) supplement+='gn' ;; # Guarani
      gu_*) supplement+='gu-in' ;; # Gujarati
      hi_*) supplement+='hi-in' ;; # Hindi
      hy_*) supplement+='hy-am' ;; # Armenian
      ne_*) supplement+='ne-np' ;; # Nepali
      nb_*) supplement+='nb-no' ;; # Norwegian (Bokmål)
      nn_*) supplement+='nn-no' ;; # Norwegian (Nynorsk)
      pa_*) supplement+='pa-in' ;; # Punjabi
      pt_BR*) supplement+='pt-br' ;; # Portuguese (Brazil)
      pt_*) supplement+='pt-pt' ;; # Portuguese (Portugal)
      sv_*) supplement+='sv-se' ;; # Swedish
      *_CN*|zh_SG*) supplement+='zh-cn' ;; # Chinese (simplified)
      zh_*|yue_*|*_TW*) supplement+='zh-tw' ;; # Chinese (traditional)
      *) supplement+="$(echo "${LOCALE}" | cut -d '_' -f 1)" ;; # other
    esac
    arch-chroot /mnt pacman -S "${supplement}" --noconfirm \
      && log "* Installed ${supplement}"
  fi
  if arch-chroot /mnt pacman -Qs libreoffice &>/dev/null; then
    if arch-chroot /mnt pacman -Q libreoffice-still &>/dev/null; then
      supplement='libreoffice-still-'
    else
      supplement='libreoffice-fresh-'
    fi
    case "${LOCALE}" in
      bn_IN*) supplement+='bn-in' ;; # Bengali (India)
      ca_*val*) supplement+='ca-valencia' ;; # Catalan (Valencia)
      en_ZA*) supplement+='en-za' ;; # English (South Africa)
      en_[^U]*) supplement+='en-gb' ;; # English (Great Britain)
      gn_*|gug_*) supplement+='gug' ;; # Guarani
      kmr_*) supplement+='kmr-latn' ;; # Kurdish
      pa_*) supplement+='pa-in' ;; # Punjabi
      pt_BR*) supplement+='pt-br' ;; # Portuguese (Brazil)
      sa_*) supplement+='sa-in' ;; # Sanskrit
      sr_*lat*) supplement+='sr-latn' ;; # Serbian (Latin)
      sw_*) supplement+='sw-tz' ;; # Swahili
      zh_CN*|zh_SG*) supplement+='zh-cn' ;; # Chinese (simplified)
      zh_*|yue_*|*_TW*) supplement+='zh-tw' ;; # Chinese (traditional)
      *) supplement+="$(echo "${LOCALE}" | cut -d '_' -f 1)" ;; # other
    esac
    arch-chroot /mnt pacman -S "${supplement}" --noconfirm \
      && log "* Installed ${supplement}"
  fi

  # Timeshift config
  if arch-chroot /mnt pacman -Q timeshift &>/dev/null; then
    log "* Configuring Timeshift..."
    enable_service cronie.service
    if [[ "${ROOT_FS}" == 'btrfs' ]]; then
      sed -i 's!/.snapshots!--timeshift-auto!' \
        /mnt/usr/lib/systemd/system/grub-btrfsd.service
      cp /mnt/etc/timeshift/default.json /mnt/etc/timeshift/timeshift.json
      sed -i '/do_first_run/s/true/false/' /mnt/etc/timeshift/timeshift.json
      sed -i '/schedule_daily/s/false/true/' /mnt/etc/timeshift/timeshift.json
      sed -i "/btrfs_mode/s/false/true\",\n  \"date_format\" : \"%F %T/" \
        /mnt/etc/timeshift/timeshift.json
      if "${SYSTEM_AUTO_ENCRYPTED}"; then
        sed -i "/parent_device_uuid/s/\"\"/\"${LVM_UUID}\"/" \
          /mnt/etc/timeshift/timeshift.json
        uuid="$(lsblk -no UUID "/dev/${ROOT_LV}")"
      else
        uuid="$(lsblk -no UUID "/dev/${ROOT_PART}")"
      fi
      sed -i "/backup_device_uuid/s/\"\"/\"${uuid}\"/" \
        /mnt/etc/timeshift/timeshift.json
      arch-chroot /mnt timeshift --list # to complete Timeshift setup
      log "  - Set backup device UUID for Timeshift"
    fi
  fi
  if arch-chroot /mnt pacman -Q timeshift-autosnap &>/dev/null; then
    sed -i '/snapshotDescription/s/=.*/=auto/ ; /updateGrub/s/true/false/' \
      /mnt/etc/timeshift-autosnap.conf
  fi

  # VMware config
  if arch-chroot /mnt pacman -Q vmware-workstation &>/dev/null; then
    enable_service vmware-usbarbitrator.path
    enable_service vmware-networks.path
  fi

  # Additional KDE Plasma config
  if [[ "${DESKTOP_ENV}" == 'kde-plasma' ]]; then
    sed -i 's/Papirus-Maia/BeautyLine/' "/mnt/usr/share/plasma/\
look-and-feel/com.gitlab.cscs.matchama/contents/defaults"
    sed -i 's/Papirus-Dark-Maia/BeautyLine/' "/mnt/usr/share/plasma/\
look-and-feel/com.gitlab.cscs.matchama-dark/contents/defaults"
  fi

  # Clean things up
  log "Cleaning up..."
  arch-chroot /mnt sudo -u yaybuilder yay -Yc --noconfirm
  arch-chroot /mnt userdel -f yaybuilder
  rm /mnt/etc/passwd- /mnt/etc/sudoers.d/yaybuilder
  rm -r /mnt/yaytemp
  arch-chroot /mnt fc-cache -f # (re)build font information cache files

  # Update GRUB config
  while true; do
    if arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg; then
      log "GRUB configuration updated"
      break
    else
      try_again "Failed to update GRUB configuration" || break
    fi
  done
}

################################################################################
# Add the previously-defined user to the newly-installed system.
#
# Globals: USERNAME, FULL_NAME, DEFAULT_GROUPS, PASSWORD, SSL_KEY, VM_TYPE
# Arguments: None
# Returns: Number of errors detected.
################################################################################
add_user() {
  local pw, command="useradd -mG ${DEFAULT_GROUPS}"

  dragonsay "Adding user '${USERNAME}'..."
  arch-chroot /mnt pacman -Q gamemode &>/dev/null && command+=',gamemode'
  arch-chroot /mnt pacman -Q virtualbox &>/dev/null && command+=',vboxusers'
  [[ "${VM_TYPE}" == 'oracle' ]] && command+=',vboxsf'
  [[ -n "${FULL_NAME}" ]] && command+=" -c '${FULL_NAME}'"
  command+=" -s /bin/bash ${USERNAME}"

  # Add user
  if ! arch-chroot /mnt sh -c "${command}"; then
    log_error "Failed to add user: ${USERNAME}"
    return 1
  fi
  log "User added: ${USERNAME}"

  # Set password
  pw="$(echo "${PASSWORD}" | openssl enc -aes-256-cbc -a -d -salt -pbkdf2 \
    -iter 1000 -pass "pass:${SSL_KEY}")"
  if ! printf "%s\n%s" "${pw}" "${pw}" \
      | arch-chroot /mnt passwd "${USERNAME}"; then
    unset pw
    log_error "Failed to set password for user: ${USERNAME}"
    return 1
  fi
  unset pw

  # Provide default user image
  cp /mnt/etc/skel/.face "/mnt/var/lib/AccountsService/icons/${USERNAME}"
  echo -e "[User]\nIcon=/var/lib/AccountsService/icons/${USERNAME}\n\
SystemAccount=false" >"/mnt/var/lib/AccountsService/users/${USERNAME}"
}

################################################################################
# Add final details to the log file, then copy it to the new user's home.
#
# Globals: LOG_FILE, ERRORS_LOGGED, USERNAME
# Arguments: None
################################################################################
finalize_and_copy_log() {
  log "GDL installation complete (errors logged: ${ERRORS_LOGGED})"
  log_partitions --chroot
  sed -i '$ d' "${LOG_FILE}"
  cp "${LOG_FILE}" "/mnt/home/${USERNAME}"
  chown 1000:1000 "/mnt/home/${USERNAME}/gdl.log"
}

################################################################################
# Custom 'dialog' function. Unless extraneous text is reduced, a backtitle is
# included which may also show remaining battery capacity. Output is directed to
# STDOUT instead of dialog's default of STDERR.
#
# Globals: TITLE, BACKTITLE, DEFAULT_BACKTITLE, BATTERY, REDUCE_EXTRANEOUS_TEXT
# Arguments: The desired text plus additional 'dialog' options.
################################################################################
dialog() {
  sleep 0.1 # to help avoid accidental keyboard input carryover
  if "${REDUCE_EXTRANEOUS_TEXT}"; then
    /usr/bin/dialog --stdout --colors --title " ${TITLE} " "$@"
  else
    BACKTITLE="${DEFAULT_BACKTITLE}"
    if [[ -n "${BATTERY}" ]]; then
      BACKTITLE+=" | Battery: $(cat "${BATTERY}/capacity")%"
    fi
    /usr/bin/dialog --stdout --colors --backtitle "${BACKTITLE}" --title \
      " ${TITLE} " "$@"
  fi
}

################################################################################
# Present a message in an 'ok' dialog box.
#
# Globals: OK
# Arguments: The desired message text.
################################################################################
message() {
  dialog --ok-button "${OK}" --msgbox "\n$1" 0 0
}

################################################################################
# Present a message in a 'yes/no' dialog box.
#
# Arguments: The desired body text plus 'yes' and 'no' button texts. If a fourth
#   argument is provided, the dialog box uses '--defaultno'.
# Returns: Dialog exit status.
################################################################################
yesno() {
  local body="$1" yes_button="$2" no_button="$3"

  if (( $# == 4 )); then
    dialog --defaultno --yes-label "${yes_button}" --no-label "${no_button}" \
      --yesno "\n${body}" 0 0
  else
    dialog --yes-label "${yes_button}" --no-label "${no_button}" --yesno \
      "\n${body}" 0 0
  fi

  return $?
}

################################################################################
# Present a dialog box with a "gauge" (loading bar) that gradually fills up as
# background processes are completed.
#
# Arguments: The desired text to display above the loading bar.
################################################################################
load_bar() {
  {
    local -i progress=1

    # shellcheck disable=SC2009
    while [[ -n $! ]] && ps | grep -q $!; do
      sleep 0.1
      echo $progress
      if (( progress < 100 )); then
        (( ++progress ))
      fi
    done
    echo 100
    sleep 0.6 # provide a bit more time for reading text before moving on
  } | dialog --gauge "\n$1" 9 79 0
}

################################################################################
# Present (and log) a given error message and prompt the user to choose whether
# to attempt the task again. This is used in "emergencies" during installation,
# such as when a package fails to install (internet issues, etc.).
#
# Globals: BOLD_RED, WHITE, COLOR_RESET
# Arguments: A description of the error.
# Returns: '0' if the user wants to try again, '1' otherwise.
################################################################################
try_again() {
  local try

  log_error "$1"
  echo -e "${BOLD_RED}ERROR: ${WHITE}$1${COLOR_RESET}"
  while true; do
    echo -en "Try again? (y/n) " && read -r try
    if [[ "${try}" =~ ^[Yy] ]]; then
      log "Trying again..."
      return 0
    elif [[ "${try}" =~ ^[Nn] ]]; then
      log "Giving up..."
      return 1
    fi
  done
}

################################################################################
# Present a message as if spoken by an ASCII dragon via 'cowsay' (or simply echo
# the message if extraneous text is reduced).
#
# Globals: REDUCE_EXTRANEOUS_TEXT, ERRORS_LOGGED
# Arguments: The text to be presented. A second argument of '--check-errors'
#   compels the dragon to attack an ASCII cow if errors are detected.
################################################################################
dragonsay() {
  sleep 0.6 # provide a bit more time for reading previous text
  clear
  if "${REDUCE_EXTRANEOUS_TEXT}"; then
    echo -e "$1\n"
  elif [[ "$2" == '--check-errors' ]] && (( ERRORS_LOGGED > 0 )); then
    cowsay -f dragon-and-cow "$1"
  else
    cowsay -f dragon "$1"
  fi
  sleep 0.6 # provide a bit more time for reading current text
}

################################################################################
# Append a given string (or stdin) to the log file.
#
# Globals: LOG_FILE
# Arguments: A string of text (or piped command output).
################################################################################
log() {
  local output

  if [[ -n "$1" ]]; then # manual logging
    echo "[$(date '+%F %T')]: $1" >>"${LOG_FILE}"
  else # stdin
    echo >>"${LOG_FILE}" # add white space
    while read -r output; do
      echo "${output}" >>"${LOG_FILE}"
    done
    echo >>"${LOG_FILE}" # add white space
  fi
}

################################################################################
# Append partition information to the log file via custom command.
#
# Arguments: '--chroot' if the command should be run within the new system.
################################################################################
log_partitions() {
  if [[ "$1" == '--chroot' ]]; then
    arch-chroot /mnt df -Th | log
  else
    lsblk -io NAME,SIZE,TYPE,MOUNTPOINTS,FSTYPE,FSUSED,FSUSE% \
      | grep -Ev ' loop | rom ' \
      | log
  fi
}

################################################################################
# Append an error message to the log file and increment the error tally.
#
# Globals: ERRORS_LOGGED
# Arguments: A string containing a description of the error.
################################################################################
log_error() {
  log "ERROR: $1"
  (( ++ERRORS_LOGGED ))
}

################################################################################
# Facilitate installation of Golden Drake Linux.
#
# Globals: ABOUT_GDL_TITLE, ABOUT_GDL_MSG, OK, INSTALL_COMPLETE_MSG,
#   INSTALL_COMPLETE_HELP, ERRORS_LOGGED
# Arguments: None
# Returns: Number of errors logged during this run of the installer.
################################################################################
main() {
  initialize
  set_installer_language
  set_keymap
  TITLE="${ABOUT_GDL_TITLE}"
  dialog --ok-button "${OK}" --msgbox "\n${ABOUT_GDL_MSG}" 23 80
  check_internet_connection
  set_locale
  set_time_zone
  prepare_drives
  set_hostname
  set_user
  prepare_base
  select_additional_software
  install_base
  configure_system
  install_aur_software
  add_user
  finalize_and_copy_log
  dragonsay "${INSTALL_COMPLETE_MSG}"
  echo -e "${INSTALL_COMPLETE_HELP}"

  return "${ERRORS_LOGGED}"
}

main
