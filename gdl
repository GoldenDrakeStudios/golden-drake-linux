#!/bin/bash
#
# Installer script for Golden Drake Linux (GDL): Arch for gamers and game devs!
#
# Copyright (C) 2020-2021 Golden Drake Studios: goldendrakestudios.com
# Forked originally from the Anarchy installer: anarchyinstaller.gitlab.io
#
# shellcheck disable=SC1090,SC2154,SC2034,SC2086,SC2153,SC2155

source /etc/gdl.conf || exit 1
source "${LANG_FILE}" || exit 1

################################################################################
# Initialize installer. If this is the script's first (automatic) run, create
# the log file (by posting its first log message), start the network manager,
# and customize pacman.conf, then return the user to the command line so they
# can run other commands before (or instead of) launching the install process.
# Otherwise (i.e., if the log file already exists), prepare for installation by
# evaluating the hardware environment, setting a 'force_quit' trap, etc.
#
# Globals: LOG_FILE, REDUCE_EXTRANEOUS_TEXT, USB, BATTERY, WIFI_AVAILABLE,
#   BLUETOOTH_AVAILABLE, VM_TYPE, GRAPHICS_CHIPSET, DEFAULT_GRAPHICS_DRIVER
# Arguments: None
################################################################################
initialize() {
  if [[ ! -f "${LOG_FILE}" ]]; then
    log "Initializing GDL installer..."
    systemctl start NetworkManager.service
    sed -i 's/#Color/Color\nILoveCandy/' /etc/pacman.conf
    sed -i 's/#ParallelDownloads/ParallelDownloads/' /etc/pacman.conf
    sed -zi 's/#\[multilib]\n#Include/[multilib]\nInclude/' /etc/pacman.conf
    return_to_shell_prompt
  elif grep -q 'force quit' "${LOG_FILE}"; then
    log "Relaunching installer..."
  fi
  trap force_quit SIGINT # call 'force_quit' when Ctrl+C is pressed
  set -o pipefail # ensure $? remembers failures from piped commands
  [[ -d /tmp/gdl ]] || mkdir /tmp/gdl
  if (( $(tput lines) < 25 )) || grep -q 'accessibility=' /proc/cmdline; then
    REDUCE_EXTRANEOUS_TEXT='true'
  fi
  if ! ip addr | grep -Eq 'wlp|wlo|wlan'; then
    WIFI_AVAILABLE='false'
  fi
  log "* Wi-Fi adapter detected: ${WIFI_AVAILABLE}"
  if dmesg | grep -qi 'blue'; then
    BLUETOOTH_AVAILABLE='true'
  fi
  log "* Bluetooth adapter detected: ${BLUETOOTH_AVAILABLE}"
  if lsblk | grep 'run' | grep -qo 'sd.'; then
    USB="$(lsblk | grep 'run' | grep -o 'sd.')"
  fi
  log "* USB devices detected: ${USB}"
  if [[ -d /sys/class/power_supply/BAT0 ]]; then
    BATTERY='/sys/class/power_supply/BAT0'
  elif [[ -d /sys/class/power_supply/BAT1 ]]; then
    BATTERY='/sys/class/power_supply/BAT1'
  fi
  log "* Battery detected: ${BATTERY}"
  if [[ "${VM_TYPE}" == 'none' ]]; then
    if lspci | grep VGA | grep -iq 'nvidia'; then
      GRAPHICS_CHIPSET='NVIDIA'
      DEFAULT_GRAPHICS_DRIVER='nvidia'
    elif lspci | grep VGA | grep -Eq 'ATI|AMD'; then
      GRAPHICS_CHIPSET='AMD/ATI'
      DEFAULT_GRAPHICS_DRIVER='xf86-video-ati'
    elif lspci | grep VGA | grep -q 'Intel'; then
      GRAPHICS_CHIPSET='Intel'
      DEFAULT_GRAPHICS_DRIVER='xf86-video-intel'
    fi
    log "* Graphics chipset detected: ${GRAPHICS_CHIPSET}"
  else
    log "* VM environment detected: ${VM_TYPE}"
  fi
}

################################################################################
# Return the user to the command line with a welcome message plus help text
# telling them how to (a) relaunch the installer, (b) read Arch Wiki articles
# offline in the terminal, (c) reboot, or (d) shut down.
#
# Globals: SHELL_PROMPT_WELCOME, SHELL_PROMPT_HELP
# Arguments: None
################################################################################
return_to_shell_prompt() {
  clear
  dragonsay "${SHELL_PROMPT_WELCOME}"
  echo -e "${SHELL_PROMPT_HELP}"
  exit
}

################################################################################
# Handle a sudden exit caused by the user pressing Ctrl+C.
#
# Globals: TITLE, FORCE_QUIT_MSG
# Arguments: None
################################################################################
force_quit() {
  log "User force quit the installer"
  TITLE="${FORCE_QUIT_TITLE}"
  message "${FORCE_QUIT_MSG}"
  return_to_shell_prompt
}

################################################################################
# Present the language menu (for the installer, not the soon-to-be-installed
# system: its language will be determined by 'set_locale'). If the associated
# language file differs from the previously-sourced language file, source it to
# update all language-specific globals and edit gdl.conf to ensure the same
# language file is sourced again if the installer is closed and relaunched.
#
# Globals: TITLE, SET_LANG_TITLE, SET_LANG_MSG, LANG_FILE
# Arguments: None
################################################################################
set_installer_language() {
  TITLE="${SET_LANG_TITLE}"
  local language prev_lang_file="${LANG_FILE}"

  while ! language="$(dialog --no-cancel --menu "\n${SET_LANG_MSG}" 20 60 10 \
      'English' '->' \
      'Bulgarian' 'Български' \
      'Dutch' 'Nederlands' \
      'French' 'Français' \
      'German' 'Deutsch' \
      'Greek' 'Ελληνικά' \
      'Hungarian' 'Magyar' \
      'Indonesian' 'bahasa Indonesia' \
      'Italian' 'Italiano' \
      'Latvian' 'Latviešu' \
      'Lithuanian' 'Lietuvių' \
      'Polish' 'Polski' \
      'Portuguese' 'Português' \
      'Portuguese-Brazilian' 'Português do Brasil' \
      'Romanian' 'Română' \
      'Russian' 'Русский' \
      'Spanish' 'Español' \
      'Swedish' 'Svenska')"; do
    continue
  done
  case "${language}" in
    Bulgarian|bg_*) LANG_FILE='/usr/share/gdl/lang/bulgarian.conf' ;;
    Dutch|nl_*) LANG_FILE='/usr/share/gdl/lang/dutch.conf' ;;
    French|fr_*) LANG_FILE='/usr/share/gdl/lang/french.conf' ;;
    German|de_*) LANG_FILE='/usr/share/gdl/lang/german.conf' ;;
    Greek|el_*) LANG_FILE='/usr/share/gdl/lang/greek.conf' ;;
    Hungarian|hu_*) LANG_FILE='/usr/share/gdl/lang/hungarian.conf' ;;
    Indonesian|id_*) LANG_FILE='/usr/share/gdl/lang/indonesia.conf' ;;
    Italian|it_*) LANG_FILE='/usr/share/gdl/lang/italian.conf' ;;
    Latvian|lv_*) LANG_FILE='/usr/share/gdl/lang/latvian.conf' ;;
    Lithuanian|lt_*) LANG_FILE='/usr/share/gdl/lang/lithuanian.conf' ;;
    Polish|pl_*) LANG_FILE='/usr/share/gdl/lang/polish.conf' ;;
    Portuguese|pt_PT*) LANG_FILE='/usr/share/gdl/lang/portuguese.conf' ;;
    Portuguese-B*|pt_BR*) LANG_FILE='/usr/share/gdl/lang/portuguese-br.conf' ;;
    Romanian|ro_*) LANG_FILE='/usr/share/gdl/lang/romanian.conf' ;;
    Russian|ru_*) LANG_FILE='/usr/share/gdl/lang/russian.conf' ;;
    Spanish|es_*) LANG_FILE='/usr/share/gdl/lang/spanish.conf' ;;
    Swedish|sv_*) LANG_FILE='/usr/share/gdl/lang/swedish.conf' ;;
    *) LANG_FILE='/usr/share/gdl/lang/english.conf' ;;
  esac
  if [[ "${LANG_FILE}" != "${prev_lang_file}" ]]; then
    source "${LANG_FILE}" || exit 1
    sed -i "s:^LANG_FILE=.*:LANG_FILE='${LANG_FILE}':" /etc/gdl.conf
  fi
  log "Set installer language: ${language}"
}

################################################################################
# Present the keymap menu.
#
# Globals: KEYMAP, SET_KEYMAP_TITLE, SET_KEYMAP_MSG, etc.
# Arguments: None
################################################################################
set_keymap() {
  TITLE="${SET_KEYMAP_TITLE}"
  local keymap_list
  keymap_list="$(find /usr/share/kbd/keymaps -type f | sed -n -e 's!^.*/!!p' |
    grep '.map.gz' | sed 's/.map.gz//g' | sed 's/$/ ->/g' | sort)"

  while true; do
    if KEYMAP="$(dialog --no-cancel --ok-button "${OK}" --menu \
        "\n${SET_KEYMAP_MSG}" 18 60 10 \
        'us' 'United States' \
        'uk' 'United Kingdom' \
        'sv' 'Swedish' \
        'slovene' 'Slovenian' \
        'ru' 'Russian' \
        'ro' 'Romanian' \
        'pt-latin9' 'Portugal' \
        'it' 'Italian' \
        'hu' 'Hungarian' \
        'fr' 'French' \
        'es' 'Spanish' \
        'el' 'Greek' \
        'de' 'German' \
        "${OTHER}" '->')"; then
      if [[ "${KEYMAP}" != "${OTHER}" ]] ||
          KEYMAP="$(dialog --ok-button "${OK}" --cancel-button "${BACK}" \
          --menu "\n${SET_KEYMAP_MSG}" 19 60 10 ${keymap_list})"; then
        break
      fi
    fi
  done
  localectl set-keymap "${KEYMAP}"
  loadkeys "${KEYMAP}"
  log "Set keymap: ${KEYMAP}"
}

################################################################################
# Check for an internet connection, connect to Wi-Fi if necessary, then update
# the system clock.
#
# Globals: WIFI_AVAILABLE, WIFI_SSID, WIFI_PASSWORD
# Arguments: None
################################################################################
check_internet_connection() {
  while ! nc -zw 1 1.1.1.1 443; do
    log "Internet connection not yet established..."
    if "${WIFI_AVAILABLE}" && [[ -n "${WIFI_SSID}" ]] &&
        nmcli dev wifi connect "${WIFI_SSID}" password "${WIFI_PASSWORD}"; then
      log "* Using nmcli..."
    else
      log "* Using nmtui..."
      nmtui
    fi
    sleep 1
  done
  timedatectl set-ntp true # ensure system clock is accurate
  log "Internet connection established"
}

################################################################################
# Present the locale menu.
#
# Globals: LOCALE, SET_LOCALE_TITLE, SET_LOCALE_MSG, etc.
# Arguments: None
################################################################################
set_locale() {
  TITLE="${SET_LOCALE_TITLE}"
  local locale_list
  locale_list="$(grep -E "^#?[a-z].*UTF-8" /etc/locale.gen | sed 's/#//' |
    awk '{print $1" ->"}')"

  while true; do
    if LOCALE="$(dialog --no-cancel --ok-button "${OK}" --menu \
        "\n${SET_LOCALE_MSG}" 18 60 10 \
        'de_DE.UTF-8' 'German' \
        'el_GR.UTF-8' 'Greek' \
        'en_AU.UTF-8' 'English (Australia)' \
        'en_CA.UTF-8' 'English (Canada)' \
        'en_GB.UTF-8' 'English (UK)' \
        'en_US.UTF-8' 'English (US)' \
        'es_ES.UTF-8' 'Spanish (Spain)' \
        'es_MX.UTF-8' 'Spanish (Mexico)' \
        'fr_FR.UTF-8' 'French' \
        'hu_HU.UTF-8' 'Hungarian' \
        'it_IT.UTF-8' 'Italian' \
        'lv_LV.UTF-8' 'Latvian' \
        'pt_BR.UTF-8' 'Portuguese (Brazil)' \
        'pt_PT.UTF-8' 'Portuguese (Portugal)' \
        'ro_RO.UTF-8' 'Romanian' \
        'ru_RU.UTF-8' 'Russian' \
        'sv_SE.UTF-8' 'Swedish' \
        "${OTHER}" '->')"; then
      if [[ "${LOCALE}" != "${OTHER}" ]] ||
          LOCALE="$(dialog --ok-button "${OK}" --cancel-button "${BACK}" \
          --menu "\n${SET_LOCALE_MSG}" 19 60 10 ${locale_list})"; then
        break
      fi
    fi
  done
  log "Set locale: ${LOCALE}"
}

################################################################################
# Present the time zone menu.
#
# Globals: TIME_ZONE, SET_TIME_ZONE_TITLE, SET_TIME_ZONE_MSG, etc.
# Arguments: None
################################################################################
set_time_zone() {
  TITLE="${SET_TIME_ZONE_TITLE}"
  local zonelist sublist subzone subsubzone
  zonelist="$(find /usr/share/zoneinfo -maxdepth 1 | sed -n -e 's!^.*/!!p' |
    grep -Ev 'posix|posixrules|right|zoneinfo|.*tab|W-SU|WET|MST7MDT|CST6CDT' |
    sort | sed 's/$/ ->/g')"

  while true; do
    TIME_ZONE="$(dialog --no-cancel --ok-button "${OK}" --menu \
      "\n${SET_TIME_ZONE_MSG}" 18 60 10 ${zonelist})"
    if find /usr/share/zoneinfo -maxdepth 1 -type d | sed -n -e 's!^.*/!!p' |
        grep -q "${TIME_ZONE}"; then
      sublist="$(find /usr/share/zoneinfo/"${TIME_ZONE}" -maxdepth 1 |
        sed -n -e 's!^.*/!!p' | sort | sed 's/$/ ->/g' |
        grep -v "${TIME_ZONE}")"
      if subzone="$(dialog --ok-button "${OK}" --cancel-button "${BACK}" \
          --menu "\n${SET_TIME_SUBZONE_MSG}" 18 60 10 ${sublist})"; then
        if find /usr/share/zoneinfo/"${TIME_ZONE}" -maxdepth 1 -type d |
            sed -n -e 's!^.*/!!p' | grep -q "${subzone}"; then
          sublist="$(find /usr/share/zoneinfo/"${TIME_ZONE}/${subzone}" \
            -maxdepth 1 | sed -n -e 's!^.*/!!p' | sort | sed 's/$/ ->/g' |
            grep -v "${subzone}")"
          if subsubzone="$(dialog --ok-button "${OK}" --cancel-button "${BACK}"\
              --menu "\n${SET_TIME_SUBZONE_MSG}" 15 60 7 ${sublist})"; then
            TIME_ZONE="${TIME_ZONE}/${subzone}/${subsubzone}"
            break
          fi
        else
          TIME_ZONE="${TIME_ZONE}/${subzone}"
          break
        fi
      fi
    else
      break
    fi
  done
  log "Set time zone: ${TIME_ZONE}"
}

################################################################################
# Present partitioning options and facilitate preparing a drive (or drives) for
# Linux installation.
#
# Globals: DRIVE, FS, GPT, UEFI, ROOT, BOOT, ESP_MNT, SWAP_SIZE, etc.
# Arguments: None
################################################################################
prepare_drives() {
  TITLE="${PREPARE_DRIVES_TITLE}"
  local partition_method partition_prefix drive_bytes drive_mib drive_gib \
    drive_menu_header='               Device    Size    Type'

  log "Initial partition layout:"
  lsblk -o NAME,SIZE,TYPE,MOUNTPOINTS,FSTYPE,FSVER,FSUSE% | log
  if df | grep -q '/mnt'; then
    (
      umount -R /mnt
      swapoff -a
    ) &>/dev/null &
    load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2umount -R /mnt\Zn"
  fi

  until "${SYSTEM_MOUNTED}"; do
    GPT='false'
    UEFI='false'
    DRIVE=''
    ROOT=''
    BOOT=''
    ESP_MNT=''

    # Present partitioning options
    if ! partition_method="$(dialog --no-cancel --ok-button "${OK}" --menu \
        "\n${PART_METHOD_MSG}" 16 64 3 \
        "${PART_METHOD_AUTO}" '->' \
        "${PART_METHOD_AUTO_ENCRYPT}" '->' \
        "${PART_METHOD_MANUAL}" '->')"; then
      continue

    # If an auto-partitioning option is selected, prepare the drive menu
    elif [[ "${partition_method}" != "${PART_METHOD_MANUAL}" ]]; then
      if [[ "${partition_method}" == "${PART_METHOD_AUTO}" ]]; then
        log "User chose automatic partitioning"
      elif [[ "${partition_method}" == "${PART_METHOD_AUTO_ENCRYPT}" ]]; then
        log "User chose automatic partitioning with encrypted LVM"
      fi
      rm /tmp/gdl/part.sh &>/dev/null # remove old temp file (if one exists)
      # shellcheck disable=SC2028
      if "${REDUCE_EXTRANEOUS_TEXT}"; then
        echo "dialog --stdout --colors --title \" ${TITLE} \" --ok-button \
\"${OK}\" --cancel-button \"${CANCEL}\" --menu \"\n${SELECT_DRIVE_MSG}\n\n\
${drive_menu_header}\" 16 60 5 \\" >/tmp/gdl/part.sh
      else
        echo "dialog --stdout --colors --backtitle \"${BACKTITLE}\" --title \" \
${TITLE} \" --ok-button \"${OK}\" --cancel-button \"${CANCEL}\" --menu \"\n\
${SELECT_DRIVE_MSG}\n\n${drive_menu_header}\" 16 60 5 \\" >/tmp/gdl/part.sh
      fi
      lsblk -nio NAME,SIZE,TYPE | grep -E "disk|raid[0-9]+$" |
        sed 's/[^[:alnum:]_., ]//g' | column -t | sort -k 1,1 | uniq |
        awk '{print "\""$1"\"""  ""\"| "$2" | "$3"     \""" \\"}' |
        column -t >>/tmp/gdl/part.sh

      # Present the drive and filesystem menus
      DRIVE="$(bash /tmp/gdl/part.sh)" || continue
      FS="$(get_filesystem)" || continue

      # Check the selected drive's properties
      if grep -Eq 'nvme|mmc|md' <<<"${DRIVE}"; then
        partition_prefix='p'
      else
        partition_prefix=''
      fi
      drive_bytes="$(lsblk -nibo NAME,SIZE | grep -w "${DRIVE}" |
        awk '{print $2}')"
      drive_mib=$(( drive_bytes / 1024 / 1024 ))
      drive_gib=$(( drive_mib / 1024 ))
      log "* Drive size: ${drive_mib} MiB"
      if efivar -l &>/dev/null && yesno "${UEFI_MSG}" "${YES}" "${NO}"; then
        GPT='true'
        UEFI='true'
        log "* UEFI boot and GPT partition scheme activated"
      fi
      if ! "${UEFI}" && yesno "${GPT_MSG}" "${YES}" "${NO}" 'defaultno'; then
        GPT='true'
        log "* GPT partition scheme activated"
      fi

      # Set swap size
      SWAP_SIZE='0'
      if yesno "${CREATE_SWAP_MSG}" "${YES}" "${NO}" 'defaultno'; then
        while true; do
          SWAP_SIZE=$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
            --inputbox "\n${SET_SWAP_SIZE_MSG}" 11 55 '512M') || break
          if grep -q 'M$' <<<"${SWAP_SIZE}"; then
            SWAP_SIZE="$(sed 's/M//;s/\..*//' <<<"${SWAP_SIZE}")"
          elif grep -q 'G$' <<<"${SWAP_SIZE}"; then
            SWAP_SIZE="$(echo "${SWAP_SIZE/G} * 1024" | bc | sed 's/\..*//')"
          else
            message "${SWAP_INPUT_ERROR_MSG}"
            continue
          fi
          if (( SWAP_SIZE > drive_mib - 9216 )); then
            message "${SWAP_SIZE_ERROR_MSG}"
          else
            break
          fi
        done
      fi
      log "* Swap size: ${SWAP_SIZE} MiB"

      # Format the selected drive (or go back to the main partitioning menu)
      if yesno "$(eval echo \"${FORMAT_DRIVE_CONFIRM}\")" "${WRITE_CHANGES}" \
          "${CANCEL}" 'defaultno'; then
        (
          sgdisk --zap-all /dev/"${DRIVE}"
          wipefs -a /dev/"${DRIVE}"
        ) &>/dev/null &
        load_bar "${WIPEFS_LOAD_MSG}\n\n \Z1> \Z2wipefs -a /dev/${DRIVE}\Zn"
        log "* Device formatted: /dev/${DRIVE}"
      else
        continue
      fi
    fi

    # Go to the appropriate sub-function
    case "${partition_method}" in
      "${PART_METHOD_AUTO}")
        auto_partition
        if ! "${SYSTEM_MOUNTED}"; then
          message "${PART_ERROR_MSG}"
        fi
        ;;
      "${PART_METHOD_AUTO_ENCRYPT}")
        auto_partition_with_encryption
        if ! "${SYSTEM_MOUNTED}"; then
          message "${PART_ERROR_MSG}"
        fi
        ;;
      "${PART_METHOD_MANUAL}")
        log "User chose manual partitioning"
        manually_partition
        ;;
    esac
  done
  log "Final partition layout:"
  lsblk -o NAME,SIZE,TYPE,MOUNTPOINTS,FSTYPE,FSVER,FSUSE% | log
}

################################################################################
# Auto-partition the drive selected in 'prepare_drives'.
#
# Globals: DRIVE, FS, GPT, UEFI, ROOT, BOOT, ESP_MNT, SWAP_SIZE, SYSTEM_MOUNTED,
#   etc. (also uses 'partition_prefix' from 'prepare_drives')
# Arguments: None (the target drive should already be stored in DRIVE)
################################################################################
auto_partition() {
  TITLE="${AUTO_PART_TITLE}"

  # Create partitions
  if "${GPT}"; then
    if "${UEFI}"; then # UEFI/GPT
      if (( SWAP_SIZE > 0 )); then
        echo -e \
          "n\n\n\n512M\nef00\nn\n3\n\n+${SWAP_SIZE}M\n8200\nn\n\n\n\n\nw\ny" |
          gdisk /dev/"${DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
        format_swap_partition "${DRIVE}${partition_prefix}3"
      else # no swap
        echo -e "n\n\n\n512M\nef00\nn\n\n\n\n\nw\ny" |
          gdisk /dev/"${DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
      fi
      BOOT="${DRIVE}${partition_prefix}1"
      ROOT="${DRIVE}${partition_prefix}2"
    else # BIOS/GPT
      if (( SWAP_SIZE > 0 )); then
        echo -e "o\ny\nn\n1\n\n+212M\n\nn\n2\n\n+1M\nEF02\nn\n4\n\n+\
${SWAP_SIZE}M\n8200\nn\n3\n\n\n\nw\ny" | gdisk /dev/"${DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
        format_swap_partition "${DRIVE}${partition_prefix}4"
      else # no swap
        echo -e "o\ny\nn\n1\n\n+212M\n\nn\n2\n\n+1M\nef02\nn\n3\n\n\n\nw\ny" |
          gdisk /dev/"${DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
      fi
      BOOT="${DRIVE}${partition_prefix}1"
      ROOT="${DRIVE}${partition_prefix}3"
    fi
  else # BIOS/MBR
    if (( SWAP_SIZE > 0 )); then
      echo -e "o\nn\np\n1\n\n+212M\nn\np\n3\n\n+${SWAP_SIZE}M\nt\n\n82\nn\np\n2\
\n\n\nw" | fdisk /dev/"${DRIVE}" &>/dev/null &
      load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2fdisk \
/dev/${DRIVE}\Zn"
      format_swap_partition "${DRIVE}${partition_prefix}3"
    else # no swap
      echo -e "o\nn\np\n1\n\n+212M\nn\np\n2\n\n\nw" |
        fdisk /dev/"${DRIVE}" &>/dev/null &
      load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2fdisk \
/dev/${DRIVE}\Zn"
    fi
    BOOT="${DRIVE}${partition_prefix}1"
    ROOT="${DRIVE}${partition_prefix}2"
  fi
  log "* Boot partition created: ${BOOT}"
  log "* Root partition created: ${ROOT}"

  # Format partitions
  if "${UEFI}"; then
    (
      sgdisk --zap-all /dev/"${BOOT}"
      wipefs -a /dev/"${BOOT}"
      mkfs.vfat -F32 /dev/"${BOOT}"
    ) &>/dev/null &
    load_bar "${EFI_LOAD_MSG}\n\n \Z1> \Z2mkfs.vfat -F32 /dev/${BOOT}\Zn"
    ESP_MNT='/boot'
    log "* EFI system partition (ESP): ${BOOT}"
    log "* ESP mount point: ${ESP_MNT}"
    log "* Boot filesystem created: vfat"
  else # BIOS
    (
      sgdisk --zap-all /dev/"${BOOT}"
      wipefs -a /dev/"${BOOT}"
      # shellcheck disable=SC1001
      mkfs.ext4 -O \^64bit /dev/"${BOOT}"
    ) &>/dev/null &
    load_bar "${BOOT_LOAD_MSG}\n\n \Z1> \Z2mkfs.ext4 /dev/${BOOT}\Zn"
    log "* Boot mount point: /boot"
    log "* Boot filesystem created: ext4"
  fi
  (
    sgdisk --zap-all /dev/"${ROOT}"
    wipefs -a /dev/"${ROOT}"
    mkfs."${FS}" /dev/"${ROOT}"
  ) &>/dev/null &
  load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${FS} \
/dev/${ROOT}\Zn"
  log "* Root filesystem created: ${FS}"

  # Mount partitions
  if mount /dev/"${ROOT}" /mnt &>/dev/null; then
    log "* Mounted /dev/${ROOT} at /mnt"
    mkdir /mnt/boot
    if mount /dev/"${BOOT}" /mnt/boot &>/dev/null; then
      log "* Mounted /dev/${BOOT} at /mnt/boot"
      SYSTEM_MOUNTED='true'
    else
      log "* ERROR: Mounting /dev/${BOOT} at /mnt/boot failed"
    fi
  else
    log "* ERROR: Mounting /dev/${ROOT} at /mnt failed"
  fi
}

################################################################################
# Auto-partition and set up LVM for the drive selected in 'prepare_drives' and
# encrypt the root volume (boot is unencrypted; encryption for tmp and swap are
# handled later in 'configure_system').
#
# Globals: DRIVE, FS, GPT, UEFI, ROOT, BOOT, ESP_MNT, SWAP_SIZE, SYSTEM_MOUNTED,
#   SYSTEM_AUTO_ENCRYPTED, etc. (plus 'partition_prefix' from 'prepare_drives')
# Arguments: None (the target drive should already be stored in DRIVE)
################################################################################
auto_partition_with_encryption() {
  TITLE="${AUTO_PART_TITLE}"
  local input input_check

  # Set encryption password
  if yesno "$(eval echo \"${ENCRYPTION_CONFIRM}\")" "${YES}" "${NO}" \
      'defaultno'; then
    while true; do
      if ! input="$(dialog --no-cancel --clear --insecure --passwordbox \
          "\n$(eval echo \"${ENCRYPTION_PASSWORD_MSG}\")" 12 55)" ||
          ! input_check="$(dialog --no-cancel --clear --insecure --passwordbox \
          "\n$(eval echo \"${ENCRYPTION_PASSWORD_CONFIRM}\")" 12 55)" ||
          [[ -z "${input}" ]]; then
        message "${PASSWORD_EMPTY_MSG}"
      elif [[ "${input}" != "${input_check}" ]]; then
        message "${PASSWORD_MISMATCH_MSG}"
      else
        break
      fi
    done
  else
    return # back to 'prepare_drives'
  fi

  # Set up physical partitions
  if "${GPT}"; then
    if "${UEFI}"; then # UEFI/GPT
      echo -e "n\n\n\n512M\nef00\nn\n\n\n\n\nw\ny" |
        gdisk /dev/"${DRIVE}" &>/dev/null &
      load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
      BOOT="${DRIVE}${partition_prefix}1"
      ROOT="${DRIVE}${partition_prefix}2"
    else # BIOS/GPT
      echo -e "o\ny\nn\n1\n\n+512M\n\nn\n2\n\n+1M\nef02\nn\n3\n\n\n\nw\ny" |
        gdisk /dev/"${DRIVE}" &>/dev/null &
      load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
      BOOT="${DRIVE}${partition_prefix}1"
      ROOT="${DRIVE}${partition_prefix}3"
    fi
  else # BIOS/MBR
    echo -e "o\nn\np\n1\n\n+512M\nn\np\n2\n\n\nw" |
      fdisk /dev/"${DRIVE}" &>/dev/null &
    load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2fdisk \
/dev/${DRIVE}\Zn"
    BOOT="${DRIVE}${partition_prefix}1"
    ROOT="${DRIVE}${partition_prefix}2"
  fi
  log "* Boot partition created: ${BOOT}"
  log "* Root partition created: ${ROOT}"
  (
    sgdisk --zap-all /dev/"${ROOT}"
    sgdisk --zap-all /dev/"${BOOT}"
    wipefs -a /dev/"${ROOT}"
    wipefs -a /dev/"${BOOT}"
  ) &>/dev/null &
  load_bar "${WIPEFS_LOAD_MSG}\n\n \Z1> \Z2wipefs -a /dev/${ROOT}\Zn"
  log "* Boot and root partitions wiped"
  (
    lvm pvcreate /dev/"${ROOT}"
    lvm vgcreate lvm /dev/"${ROOT}"
  ) &>/dev/null &
  load_bar "${PVCREATE_LOAD_MSG}\n\n \Z1> \Z2lvm pvcreate /dev/${ROOT}\Zn"
  log "* Physical root volume created: /dev/${ROOT}"

  # Set up logical volumes and encrypt the root volume
  if (( SWAP_SIZE > 0 )); then
    lvm lvcreate -L "${SWAP_SIZE}M" -n swap lvm &>/dev/null &
    load_bar "${SWAP_LOAD_MSG}\n\n \Z1> \Z2lvm lvcreate -L ${SWAP_SIZE}M -n \
swap lvm\Zn"
    log "* Logical swap space created"
  fi
  (
    lvm lvcreate -L 500M -n tmp lvm
    lvm lvcreate -l 100%FREE -n lvroot lvm
  ) &>/dev/null &
  load_bar "${LVCREATE_LOAD_MSG}\n\n \Z1> \Z2lvm lvcreate -l 100%FREE -n \
lvroot lvm\Zn"
  log "* Logical root volume created: lvroot"
  log "* Logical temp filesystem created: tmp"
  (
    printf "%s" "${input}" |
      cryptsetup luksFormat -c aes-xts-plain64 -s 512 /dev/lvm/lvroot -
    printf "%s" "${input}" | cryptsetup open --type luks /dev/lvm/lvroot root -
  ) &>/dev/null &
  load_bar "${ENCRYPTION_LOAD_MSG}\n\n \Z1> \Z2cryptsetup luksFormat -c \
aes-xts-plain64 -s 512 /dev/lvm/lvroot\Zn"
  unset input input_check
  log "* Logical root volume encrypted"
  (
    wipefs -a /dev/mapper/root
    mkfs."${FS}" /dev/mapper/root
  ) &>/dev/null &
  load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${FS} \
/dev/mapper/root\Zn"
  log "* Root filesystem created: ${FS}"

  # Format boot partition (unencrypted)
  if "${UEFI}"; then
    mkfs.vfat -F32 /dev/"${BOOT}" &>/dev/null &
    load_bar "${EFI_LOAD_MSG}\n\n \Z1> \Z2mkfs.vfat -F32 /dev/${BOOT}\Zn"
    ESP_MNT='/boot'
    log "* EFI system partition (ESP): ${BOOT}"
    log "* ESP mount point: ${ESP_MNT}"
    log "* Boot filesystem created: vfat"
  else # BIOS
    # shellcheck disable=SC1001
    mkfs.ext4 -O \^64bit /dev/"${BOOT}" &>/dev/null &
    load_bar "${BOOT_LOAD_MSG}\n\n \Z1> \Z2mkfs.ext4 /dev/${BOOT}\Zn"
    log "* Boot filesystem created: ext4"
  fi

  # Mount partitions
  if mount /dev/mapper/root /mnt &>/dev/null; then
    log "* Mounted /dev/mapper/root at /mnt"
    mkdir /mnt/boot
    if mount /dev/"${BOOT}" /mnt/boot &>/dev/null; then
      log "* Mounted /dev/${BOOT} at /mnt/boot"
      SYSTEM_MOUNTED='true'
      SYSTEM_AUTO_ENCRYPTED='true'
    else
      log "* ERROR: Mounting /dev/${BOOT} at /mnt/boot failed"
    fi
  else
    log "* ERROR: Mounting /dev/mapper/root at /mnt failed"
  fi
}

################################################################################
# Present options for manual partitioning of available drives.
#
# Globals: DRIVE, FS, GPT, UEFI, ROOT, BOOT, ESP_MNT, SYSTEM_MOUNTED, etc.
# Arguments: None
################################################################################
manually_partition() {
  local -i counter device_count
  local device dev_list dev_size dev_type dev_fs dev_mnt dev_used dev_parent \
    dev_menu_header='       Device    Size    Used    FS    Mount    Type' \
    part part_size part_type part_fs part_mount part_final disk_util \
    empty_value='----'

  while true; do
    # Prepare the manual partitioning menu via temp files part.sh/part.list
    TITLE="${MANUAL_PART_TITLE}"
    rm /tmp/gdl/part.sh /tmp/gdl/part.list &>/dev/null # rm old files (if any)
    dev_list="$(lsblk -no NAME,SIZE,TYPE,FSTYPE |
      grep -Ev "${USB}|loop[0-9]+|sr[0-9]+|fd[0-9]+" |
      sed 's/[^[:alnum:]_., -]//g' | column -t | sort -k 1,1 | uniq)"
    device_count="$(wc -l <<<"${dev_list}")"
    if "${REDUCE_EXTRANEOUS_TEXT}"; then
      # shellcheck disable=SC2028
      echo "dialog --stdout --colors --title \" ${TITLE} \" --ok-button \
\"${EDIT}\" --cancel-button \"${CANCEL}\" --menu \"\n${MANUAL_PART_MSG}\n
${dev_menu_header}\" 20 68 8 \\" >/tmp/gdl/part.sh
    else
      # shellcheck disable=SC2028
      echo "dialog --stdout --colors --backtitle \"${BACKTITLE}\" --title \
\" ${TITLE} \" --ok-button \"${EDIT}\" --cancel-button \"${CANCEL}\" --menu \
\"\n${MANUAL_PART_MSG}\n\n${dev_menu_header}\" 21 68 9 \\" >/tmp/gdl/part.sh
    fi
    counter=1
    until (( counter > device_count )); do
      device="$(awk <<<"${dev_list}" '{print $1}' | awk "NR==${counter}")"
      dev_size="$(grep -w "${device}" <<<"${dev_list}" | awk '{print $2}')"
      dev_type="$(grep -w "${device}" <<<"${dev_list}" | awk '{print $3}')"
      dev_fs="$(grep -w "${device}" <<<"${dev_list}" | awk '{print $4}')"
      dev_mnt="$(df | grep -w "${device}" | awk '{print $6}' |
        sed 's/mnt\/\?//')"
      if grep -q '/' <<<"${dev_mnt}"; then
        dev_used="$(df -T | grep -w "${device}" | awk '{print $6}')"
      else
        dev_used=$(swapon -s | grep -w "${device}" | awk '{print $4}')
        if [[ -n "${dev_used}" ]]; then
          dev_used="${dev_used}%"
        fi
      fi
      [[ -z "${dev_fs}" || "${dev_fs}" == "linux_raid_member" ]] &&
        dev_fs="${empty_value}"
      [[ -z "${dev_used}" ]] && dev_used="${empty_value}"
      [[ -z "${dev_mnt}" ]] && dev_mnt="${empty_value}"
      dev_parent="$(lsblk -dnro PKNAME /dev/"${device/-//}")"
      if [[ -z "${dev_parent}" ]]; then
        dev_type="$(grep -w "${device}" <<<"${dev_list}" | awk '{print $3}')"
      else
        dev_type="$(fdisk -lo Device,Type /dev/"${dev_parent}" |
          grep -w "${device}" | cut -d ' ' -f 2- |
          sed -e 's/^[[:space:]]*//;s/[[:space:]]*$//;s/ /_/g')"
      fi
      echo "\"${device}\" \"${dev_size} ${dev_used} ${dev_fs} ${dev_mnt} \
${dev_type}\" \\" >>/tmp/gdl/part.list
      (( ++counter ))
    done
    column </tmp/gdl/part.list -t >>/tmp/gdl/part.sh
    echo -e "\"${DONE}\" \"${WRITE_CHANGES}\"" >>/tmp/gdl/part.sh

    # Present the manual partitioning menu and get user input
    if ! part="$(bash /tmp/gdl/part.sh | sed 's/^\s\+//g;s/\s\+$//g')" ||
        [[ -z "${part}" ]]; then
      SYSTEM_MOUNTED='false'
      return # back to 'prepare_drives'
    fi
    log "* Manual partitioning menu selection: ${part}"

    # If user selected 'done', attempt to finish the partitioning process
    if [[ "${part}" == "${DONE}" ]]; then
      if ! "${SYSTEM_MOUNTED}"; then
        message "${ROOT_UNMOUNTED_ERROR_MSG}"
        continue
      elif "${GPT}" && ! "${UEFI}" && ! fdisk -l | grep -q 'BIOS boot'; then
        message "${GPT_BIOS_ERROR_MSG}"
        continue
      elif [[ -z "${BOOT}" ]]; then
        BOOT="${ROOT}"
      fi
      part_final="$( (df -h | grep '/mnt' | awk '{print $1,$2,$6 "\\n"}' |
        sed 's/mnt\/\?//'; swapon | awk 'NR==2 {print $1,$3,"SWAP"}') |
        column -t)"
      yesno "${WRITE_CONFIRM}\n\n${PARTITION}  ${SIZE}  ${MOUNT_POINT}\n\n\
${part_final}" "${OK}" "${CANCEL}" 'defaultno' || continue
      return # all done: return to 'prepare_drives'
    fi

    # If not 'done', prepare and present a disk/partition editing menu
    part_size="$(grep -w "${part}" <<<"${dev_list}" | awk '{print $2}')"
    part_type="$(grep -w "${part}" <<<"${dev_list}" | awk '{print $3}')"
    part_fs="$(grep -w "${part}" <<<"${dev_list}" | awk '{print $4}')"
    part_mount="$(df | grep -w "${part}" | awk '{print $6}' |
      sed 's/mnt\/\?//')"
    if [[ "${part_fs}" == "linux_raid_member" ]]; then
      continue
    elif [[ "${part_type}" == "lvm" ]]; then
      part="${part/-//}"
    fi

    # If user selected an entire drive, facilitate partitioning
    if [[ "${part_type}" == "disk" ]] ||
        (grep -Eq 'raid[0-9]+' <<<"${part_type}" && [[ -z "${part_fs}" ]]); then
      if df | grep -w "${part}" | grep -q '/mnt' && yesno "$(eval echo \
          \"${UNMOUNT_DRIVE_CONFIRM}\")" "${EDIT}" "${CANCEL}" 'defaultno'; then
        (
          umount -R /mnt
          swapoff -a
        ) &>/dev/null &
        load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2umount -R /mnt\Zn"
        SYSTEM_MOUNTED='false'
        DRIVE=''
        if disk_util="$(get_disk_util)"; then
          clear
          "${disk_util}" /dev/"${part}"
          log "* Disk /dev/${part} edited via ${disk_util}"
          clear
        fi
      elif yesno "$(eval echo \"${EDIT_DRIVE_CONFIRM}\")" "${EDIT}" \
          "${CANCEL}" && disk_util="$(get_disk_util)"; then
        clear
        "${disk_util}" /dev/"${part}"
        log "* Disk /dev/${part} edited via ${disk_util}"
        clear
      fi

    # If user selected a partition or md device, facilitate mounting/formatting
    else
      TITLE="${EDIT_PART_TITLE}"
      # The root '/' mount point must be established before others
      if [[ -z "${ROOT}" ]]; then
        case "${part_size}" in
          [1-9]T | 9G | [1-9][0-9]*[GT] | 9.*[GT] | 9,*[GT])
            # shellcheck disable=SC2015
            yesno "$(eval echo \"${ROOT_MNT_CONFIRM}\")" "${YES}" "${NO}" \
              'defaultno' && FS="$(get_filesystem)" || continue
            if yesno "$(eval echo \"${ROOT_FORMAT_CONFIRM}\")" \
                "${WRITE_CHANGES}" "${CANCEL}" 'defaultno'; then
              (
                sgdisk --zap-all /dev/"${part}"
                wipefs -a /dev/"${part}"
                mkfs."${FS}" /dev/"${part}"
              ) &>/dev/null &
              load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \
\Z2mkfs.${FS} /dev/${part}\Zn"
              log "* Root filesystem created for /dev/${part}: ${FS}"
              if mount /dev/"${part}" /mnt &>/dev/null; then
                log "* Mounted /dev/${part} at /mnt"
                SYSTEM_MOUNTED='true'
                ROOT="${part}"
                if [[ "${part_type}" == "lvm" ]]; then
                  lvm_pv="$(lvdisplay -m | grep -A 20 /dev/"${part}" |
                    grep 'Physical volume' | sed 's/^\s\+//g;s/\s\+/ /g' |
                    cut -d ' ' -f 3)"
                  DRIVE="$(lsblk -dnro PKNAME "${lvm_pv}")"
                else
                  DRIVE="$(lsblk -dnro PKNAME /dev/"${part}")"
                fi
                if parted /dev/"${DRIVE}" print | grep -q 'Table: gpt'; then
                  GPT='true'
                else
                  GPT='false'
                fi
              else
                SYSTEM_MOUNTED='false'
                log "* ERROR: Mounting /dev/${part} at /mnt failed"
                message "${ROOT_MOUNT_ERROR_MSG}"
                return # back to 'prepare_drives'
              fi
            fi
            ;;
          *) message "${ROOT_SIZE_ERROR_MSG}" ;;
        esac
      # If the partition's already mounted, provide suitable options
      elif [[ -n "${part_mount}" ]]; then
        if yesno "$(eval echo \"${ALREADY_MOUNTED_MSG}\")" "${EDIT}" "${BACK}" \
            'defaultno'; then
          if [[ "${part}" == "${ROOT}" ]]; then
            if yesno "$(eval echo \"${UNMOUNT_ROOT_CONFIRM}\")" "${YES}" \
                "${NO}" 'defaultno'; then
              SYSTEM_MOUNTED='false'
              UEFI='false'
              DRIVE=''
              ROOT=''
              BOOT=''
              ESP_MNT=''
              umount -R /mnt &>/dev/null &
              load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2umount -R /mnt\Zn"
            fi
          else
            if [[ "${part_mount}" == "[SWAP]" ]] && yesno "$(eval echo \
                \"${SWAPOFF_CONFIRM}\")" "${YES}" "${NO}" 'defaultno'; then
              swapoff /dev/"${part}" &>/dev/null &
              load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2swapoff /dev/${part}\Zn"
            elif yesno "$(eval echo \"${UNMOUNT_PART_CONFIRM}\")" "${YES}" \
                "${NO}" 'defaultno'; then
              umount /mnt/"${part_mount}" &>/dev/null &
              load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2umount \
/mnt/${part_mount}\Zn"
              rm -r /mnt/"${part_mount:?}"
              if [[ "${part}" == "${BOOT}" ]]; then
                BOOT=''
              fi
              if [[ "${part}" == "${ESP_MNT}" ]]; then
                UEFI='false'
                ESP_MNT=''
              fi
            fi
          fi
        fi
      # If it's a swap partition, optionally format and attempt to 'swapon'
      elif (( $(fdisk -l | grep -w "${part}" | sed 's/\*//' |
              awk '{print $6}') == 82 )) ||
          (fdisk -l /dev/"$(lsblk -dnro PKNAME /dev/"${part}")" |
           grep -q 'gpt' && [[ "$(fdisk -l -o Device,Size,Type-UUID |
           grep -w "${part}" | awk '{print $3}')" == \
           "0657FD6D-A4AB-43C4-84E5-0933C84B4F4F" ]]); then
        if yesno "${SWAP_FORMAT_CONFIRM}" "${YES}" "${NO}"; then
          format_swap_partition "${part}"
        elif ! swapon /dev/"${part}" &>/dev/null; then
          message "${SWAPON_ERROR_MSG}"
        fi
      # If the partition's not yet mounted, provide mount point options
      elif yesno "$(eval echo \"${MNT_CONFIRM}\")" "${EDIT}" "${BACK}"; then
        mnt="$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
          --menu "\n$(eval echo \"${SELECT_MNT_MSG}\")" 15 60 6 \
          '/home' '->' \
          '/boot' '->' \
          '/efi' '->' \
          '/opt' '->' \
          '/usr' '->' \
          '/var' '->' \
          '/tmp' '->' \
          "${CUSTOM}" '->')" || continue
        if [[ "${mnt}" == "${CUSTOM}" ]]; then
          while true; do
            mnt="$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
              --inputbox "\n${CUSTOM_MNT_MSG}" 10 50 '/')" || continue 2
            if grep -q "[\[\$\!\'\"\`\\|%&#@()+=<>~;:?.,^{}]\|]" \
                <<<"${mnt}"; then
              message "${CUSTOM_MNT_CHAR_ERROR_MSG}"
            elif [[ "${mnt}" == '/' ]]; then
              message "${CUSTOM_MNT_ROOT_ERROR_MSG}"
            else
              [[ "${mnt}" =~ ^/.+ ]] || mnt="/${mnt}"
              break
            fi
          done
        fi
        # Provide formatting options
        if yesno "${PART_FORMAT_MSG}" "${YES}" "${NO}" 'defaultno'; then
          if [[ "${mnt}" == '/efi' || "${mnt}" == '/boot/efi' ]] ||
              fdisk -l | grep "${part}" | grep -q 'EFI'; then
            FS="$(dialog --menu "\n${EFI_VFAT_MSG}" 12 65 1 'vfat' \
              "${FS_VFAT_MSG}")" || continue
          else
            FS="$(get_filesystem)" || continue
          fi
          yesno "$(eval echo \"${PART_FORMAT_CONFIRM}\")" "${WRITE_CHANGES}" \
            "${CANCEL}" 'defaultno' || continue
          (
            sgdisk --zap-all /dev/"${part}"
            wipefs -a /dev/"${part}"
            case "${FS}" in
              vfat) mkfs.vfat -F32 /dev/"${part}" ;;
              *) mkfs."${FS}" /dev/"${part}" ;;
            esac
          ) &>/dev/null &
          load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${FS} \
/dev/${part}\Zn"
          log "* Filesystem created for ${mnt}: ${FS}"
        fi
        # Attempt to mount the partition at the given mount point
        if mkdir -p /mnt"${mnt}" &&
            mount /dev/"${part}" /mnt"${mnt}" &>/dev/null; then
          log "* Mounted /dev/${part} at /mnt${mnt}"
          if [[ "${mnt}" == '/boot' ]]; then
            BOOT="${part}"
          fi
          if [[ "${mnt}" == '/efi' || "${mnt}" == '/boot/efi' ]] ||
              fdisk -l | grep "${part}" | grep -q 'EFI'; then
            UEFI='true'
            ESP_MNT="${mnt}"
          fi
        else
          log "* ERROR: Mounting /dev/${part} at /mnt${mnt} failed"
          message "${MOUNT_ERROR_MSG}"
        fi
      fi
    fi
  done
}

################################################################################
# Present the filesystem menu and provide its output.
#
# Globals: SELECT_FS_MSG, FS_EXT4_MSG, FS_BTRFS_MSG, FS_XFS_MSG
# Arguments: None
# Outputs: The selected filesystem (or nothing if the user hits Esc).
################################################################################
get_filesystem() {
  dialog --no-cancel --menu "\n${SELECT_FS_MSG}" 12 60 3 \
    'ext4' "${FS_EXT4_MSG}" \
    'btrfs' "${FS_BTRFS_MSG}" \
    'xfs' "${FS_XFS_MSG}"
}

################################################################################
# Present the disk utility menu and provide its output.
#
# Globals: SELECT_DISK_UTIL_MSG, CFDISK_MSG, FDISK_MSG, GDISK_MSG
# Arguments: None
# Outputs: The selected disk utility (or nothing if the user hits Esc).
################################################################################
get_disk_util() {
  dialog --menu "\n${SELECT_DISK_UTIL_MSG}" 12 60 3 \
    'cfdisk' "${CFDISK_MSG}" \
    'fdisk' "${FDISK_MSG}" \
    'gdisk' "${GDISK_MSG}"
}

################################################################################
# Formats a given partition to serve as a swap partition.
#
# Globals: SWAP_LOAD_MSG
# Arguments: A string indicating the target partition.
################################################################################
format_swap_partition() {
  local partition="$1"

  if [[ -z "${partition}" ]]; then
    log "* ERROR: No argument passed to 'format_swap_partition'"
    return 1
  elif grep -vq '/dev/' <<<"${partition}"; then
    partition="/dev/${partition}"
  fi
  (
    wipefs -a "${partition}"
    mkswap "${partition}"
    swapon "${partition}"
  ) &>/dev/null &
  load_bar "${SWAP_LOAD_MSG}\n\n \Z1> \Z2mkswap ${partition}\Zn"
  log "* Swap space formatted and activated: ${partition}"
}

################################################################################
# Prompt user for a hostname until a valid hostname is provided.
#
# Globals: HOSTNAME, SET_HOSTNAME_MSG, HOSTNAME_ERROR_MSG, etc.
# Arguments: None
################################################################################
set_hostname() {
  TITLE="${SET_HOSTNAME_TITLE}"
  while true; do
    if HOSTNAME="$(dialog --ok-button "${OK}" --no-cancel --inputbox \
        "\n${SET_HOSTNAME_MSG}" 12 55 "${HOSTNAME}" | sed 's/ //g')" &&
        [[ -n "${HOSTNAME}" ]]; then
      if grep -q "^[0-9]\|[\[\$\!\'\"\`\\|%&#@()+=<>~;:/?.,^{}]\|]" \
          <<<"${HOSTNAME}"; then
        message "${HOSTNAME_ERROR_MSG}"
      else
        break
      fi
    fi
  done
}

################################################################################
# Prompt user for a username and full name and ensure all input is valid, then
# call 'set_password' to handle password input. (For now, GDL does not support
# creating more than one user during installation.)
#
# Globals: USERNAME, FULL_NAME, SET_USERNAME_MSG, SET_FULL_NAME_MSG, etc.
# Arguments: None
################################################################################
set_user() {
  TITLE="${ADD_USER_TITLE}"
  while true; do
    if ! USERNAME="$(dialog --no-cancel --ok-button "${OK}" --inputbox \
        "\n${SET_USERNAME_MSG}" 12 55)" ||
        [[ -z "${USERNAME}" ]]; then
      message "${USERNAME_EMPTY_ERROR_MSG}"
    elif grep -q "^[0-9]\|[A-Z]\|[]:/?#@\!\$&'()*+,;=%[]" <<<"${USERNAME}"; then
      message "${USERNAME_CHAR_ERROR_MSG}"
    else
      log "Username set: ${USERNAME}"
      while true; do
        if FULL_NAME="$(dialog --no-cancel --ok-button "${OK}" --inputbox \
            "\n${SET_FULL_NAME_MSG}" 12 55)"; then
          if grep -q ',' <<<"${FULL_NAME}"; then
            message "${FULL_NAME_ERROR_MSG}"
          else
            set_password
            break
          fi
        fi
      done
      break
    fi
  done
}

################################################################################
# Prompt user for a password ('root' will use the same password).
#
# Globals: PASSWORD, SSL_KEY, USER_PASSWORD_MSG, PASSWORD_MISMATCH_MSG, etc.
# Arguments: None
################################################################################
set_password() {
  TITLE="${SET_PASSWORD_TITLE}"
  local input input_check

  while true; do
    if ! input="$(dialog --no-cancel --clear --insecure --passwordbox \
        "\n$(eval echo \"${USER_PASSWORD_MSG}\")" 11 55)" ||
        ! input_check="$(dialog --no-cancel --clear --insecure --passwordbox \
        "\n$(eval echo \"${USER_PASSWORD_CONFIRM}\")" 11 55)" ||
        [[ -z "${input}" ]]; then
      message "${PASSWORD_EMPTY_MSG}"
    elif [[ "${input}" != "${input_check}" ]]; then
      message "${PASSWORD_MISMATCH_MSG}"
    else
      break
    fi
  done
  PASSWORD="$(echo "${input}" | openssl enc -aes-256-cbc -a -salt -pbkdf2 \
    -iter 1000 -pass pass:"${SSL_KEY}")"
  unset input input_check
  log "Password set for user: ${USERNAME}"
}

################################################################################
# Add to the list of base packages according to hardware and user input.
#
# Globals: BASE_PACKAGES, WIFI_AVAILABLE, BLUETOOTH_AVAILABLE, TOUCHPAD_MSG,
#   OS_PROBER_MSG, UEFI, LOCALE, VM_TYPE, GRAPHICS_CHIPSET, etc.
# Arguments: None
################################################################################
prepare_base() {
  TITLE="${INSTALLATION_TITLE}"
  local additional_packages
  log "Preparing base packages..."

  if grep -q 'AuthenticAMD' /proc/cpuinfo; then
    BASE_PACKAGES+='amd-ucode '
    log "* Added AMD microcode"
  elif grep -q 'GenuineIntel' /proc/cpuinfo; then
    BASE_PACKAGES+='intel-ucode '
    log "* Added Intel microcode"
  fi
  if "${WIFI_AVAILABLE}" ||
      yesno "${WIFI_MSG}" "${YES}" "${NO}" 'defaultno'; then
    BASE_PACKAGES+='wireless_tools wpa_supplicant '
    log "* Added wireless utilities"
  fi
  if "${BLUETOOTH_AVAILABLE}"; then
    BASE_PACKAGES+='blueman bluez bluez-utils pulseaudio-bluetooth '
    log "* Added bluetooth support"
  fi
  if yesno "${TOUCHPAD_MSG}" "${YES}" "${NO}" 'defaultno'; then
    BASE_PACKAGES+='xf86-input-libinput '
    log "* Added touchpad support"
  fi
  if yesno "${OS_PROBER_MSG}" "${YES}" "${NO}" 'defaultno'; then
    BASE_PACKAGES+='os-prober '
    log "* Added os-prober"
  fi
  if "${UEFI}"; then
    BASE_PACKAGES+='efibootmgr '
    log "* Added efibootmgr"
  fi
  if mount | grep -q 'type btrfs'; then
    BASE_PACKAGES+='grub-btrfs '
    log "* Added grub-btrfs"
  fi

  # Add LibreOffice language pack (if available)
  case "${LOCALE}" in
    af_*) BASE_PACKAGES+='libreoffice-fresh-af ' ;; # Afrikaans
    am_*) BASE_PACKAGES+='libreoffice-fresh-am ' ;; # Amharic
    ar_*) BASE_PACKAGES+='libreoffice-fresh-ar ' ;; # Arabic
    as_*) BASE_PACKAGES+='libreoffice-fresh-as ' ;; # Assamese
    ast_*) BASE_PACKAGES+='libreoffice-fresh-ast ' ;; # Asturianu
    be_*) BASE_PACKAGES+='libreoffice-fresh-be ' ;; # Belarusian
    bg_*) BASE_PACKAGES+='libreoffice-fresh-bg ' ;; # Bulgarian
    bn_IN*) BASE_PACKAGES+='libreoffice-fresh-bn-in ' ;; # Bengali (India)
    bn_*) BASE_PACKAGES+='libreoffice-fresh-bn ' ;; # Bengali
    bo_*) BASE_PACKAGES+='libreoffice-fresh-bo ' ;; # Tibetan
    br_*) BASE_PACKAGES+='libreoffice-fresh-br ' ;; # Breton
    brx_*) BASE_PACKAGES+='libreoffice-fresh-brx ' ;; # Bodo
    bs_*) BASE_PACKAGES+='libreoffice-fresh-bs ' ;; # Bosnian
    ca_*val*) BASE_PACKAGES+='libreoffice-fresh-ca-valencia ' ;; # Catalan (V.)
    ca_*) BASE_PACKAGES+='libreoffice-fresh-ca ' ;; # Catalan
    ckb_*) BASE_PACKAGES+='libreoffice-fresh-ckb ' ;; # Central Kurdish/Sorani
    cs_*) BASE_PACKAGES+='libreoffice-fresh-cs ' ;; # Czech
    cy_*) BASE_PACKAGES+='libreoffice-fresh-cy ' ;; # Welsh
    da_*) BASE_PACKAGES+='libreoffice-fresh-da ' ;; # Danish
    de_*) BASE_PACKAGES+='libreoffice-fresh-de ' ;; # German
    dgo_*) BASE_PACKAGES+='libreoffice-fresh-dgo ' ;; # Dogri
    dsb_*) BASE_PACKAGES+='libreoffice-fresh-dsb ' ;; # Sorbian (Lower)
    dz_*) BASE_PACKAGES+='libreoffice-fresh-dz ' ;; # Dzongkha
    el_*) BASE_PACKAGES+='libreoffice-fresh-el ' ;; # Greek
    en_ZA*) BASE_PACKAGES+='libreoffice-fresh-en-za ' ;; # English (S. Africa)
    en_[^U]*) BASE_PACKAGES+='libreoffice-fresh-en-gb ' ;; # English (GB)
    eo_*) BASE_PACKAGES+='libreoffice-fresh-eo ' ;; # Esperanto
    es_*) BASE_PACKAGES+='libreoffice-fresh-es ' ;; # Spanish
    et_*) BASE_PACKAGES+='libreoffice-fresh-et ' ;; # Estonian
    eu_*) BASE_PACKAGES+='libreoffice-fresh-eu ' ;; # Basque
    fa_*) BASE_PACKAGES+='libreoffice-fresh-fa ' ;; # Persian
    fi_*) BASE_PACKAGES+='libreoffice-fresh-fi ' ;; # Finnish
    fr_*) BASE_PACKAGES+='libreoffice-fresh-fr ' ;; # French
    fur_*) BASE_PACKAGES+='libreoffice-fresh-fur ' ;; # Friulian/Friulan
    fy_*) BASE_PACKAGES+='libreoffice-fresh-fy ' ;; # Frisian/Frysk/Fries
    ga_*) BASE_PACKAGES+='libreoffice-fresh-ga ' ;; # Irish
    gd_*) BASE_PACKAGES+='libreoffice-fresh-gd ' ;; # Gaelic (Scottish)
    gl_*) BASE_PACKAGES+='libreoffice-fresh-gl ' ;; # Galician
    gn_*|gug_*) BASE_PACKAGES+='libreoffice-fresh-gug ' ;; # Guarani
    gu_*) BASE_PACKAGES+='libreoffice-fresh-gu ' ;; # Gujarati
    he_*) BASE_PACKAGES+='libreoffice-fresh-he ' ;; # Hebrew
    hi_*) BASE_PACKAGES+='libreoffice-fresh-hi ' ;; # Hindi
    hr_*) BASE_PACKAGES+='libreoffice-fresh-hr ' ;; # Croatian
    hsb_*) BASE_PACKAGES+='libreoffice-fresh-hsb ' ;; # Sorbian (Upper)
    hu_*) BASE_PACKAGES+='libreoffice-fresh-hu ' ;; # Hungarian
    id_*) BASE_PACKAGES+='libreoffice-fresh-id ' ;; # Indonesian
    is_*) BASE_PACKAGES+='libreoffice-fresh-is ' ;; # Icelandic
    it_*) BASE_PACKAGES+='libreoffice-fresh-it ' ;; # Italian
    ja_*) BASE_PACKAGES+='libreoffice-fresh-ja ' ;; # Japanese
    ka_*) BASE_PACKAGES+='libreoffice-fresh-ka ' ;; # Georgian
    kab_*) BASE_PACKAGES+='libreoffice-fresh-kab ' ;; # Kabyle, Taqbaylit, etc.
    kk_*) BASE_PACKAGES+='libreoffice-fresh-kk ' ;; # Kazakh
    km_*) BASE_PACKAGES+='libreoffice-fresh-km ' ;; # Khmer
    kmr_*) BASE_PACKAGES+='libreoffice-fresh-kmr-latn ' ;; # Kurdish
    kn_*) BASE_PACKAGES+='libreoffice-fresh-kn ' ;; # Kannada
    ko_*) BASE_PACKAGES+='libreoffice-fresh-ko ' ;; # Korean
    kok_*) BASE_PACKAGES+='libreoffice-fresh-kok ' ;; # Konkani
    ks_*) BASE_PACKAGES+='libreoffice-fresh-ks ' ;; # Kashmiri
    lb_*) BASE_PACKAGES+='libreoffice-fresh-lb ' ;; # Luxembourgish
    lo_*) BASE_PACKAGES+='libreoffice-fresh-lo ' ;; # Lao
    lt_*) BASE_PACKAGES+='libreoffice-fresh-lt ' ;; # Lithuanian
    lv_*) BASE_PACKAGES+='libreoffice-fresh-lv ' ;; # Latvian
    mai_*) BASE_PACKAGES+='libreoffice-fresh-mai ' ;; # Maithili
    mk_*) BASE_PACKAGES+='libreoffice-fresh-mk ' ;; # Macedonian
    ml_*) BASE_PACKAGES+='libreoffice-fresh-ml ' ;; # Malayalam
    mn_*) BASE_PACKAGES+='libreoffice-fresh-mn ' ;; # Mongolian
    mni_*) BASE_PACKAGES+='libreoffice-fresh-mni ' ;; # Manipuri
    mr_*) BASE_PACKAGES+='libreoffice-fresh-mr ' ;; # Marathi
    my_*) BASE_PACKAGES+='libreoffice-fresh-my ' ;; # Burmese
    nb_*) BASE_PACKAGES+='libreoffice-fresh-nb ' ;; # Norwegian (Bokmål)
    ne_*) BASE_PACKAGES+='libreoffice-fresh-ne ' ;; # Nepali
    nl_*) BASE_PACKAGES+='libreoffice-fresh-nl ' ;; # Dutch
    nn_*) BASE_PACKAGES+='libreoffice-fresh-nn ' ;; # Norwegian (Nynorsk)
    nr_*) BASE_PACKAGES+='libreoffice-fresh-nr ' ;; # Ndebele
    nso_*) BASE_PACKAGES+='libreoffice-fresh-nso ' ;; # Sotho (Northern)
    oc_*) BASE_PACKAGES+='libreoffice-fresh-oc ' ;; # Occitan
    om_*) BASE_PACKAGES+='libreoffice-fresh-om ' ;; # Oromo
    or_*) BASE_PACKAGES+='libreoffice-fresh-or ' ;; # Oriya
    pa_*) BASE_PACKAGES+='libreoffice-fresh-pa-in ' ;; # Punjabi
    pl_*) BASE_PACKAGES+='libreoffice-fresh-pl ' ;; # Polish
    pt_BR*) BASE_PACKAGES+='libreoffice-fresh-pt-br ' ;; # Portuguese (Brazil)
    pt_*) BASE_PACKAGES+='libreoffice-fresh-pt ' ;; # Portuguese
    ro_*) BASE_PACKAGES+='libreoffice-fresh-ro ' ;; # Romanian
    ru_*) BASE_PACKAGES+='libreoffice-fresh-ru ' ;; # Russian
    rw_*) BASE_PACKAGES+='libreoffice-fresh-rw ' ;; # Kinyarwanda
    sa_*) BASE_PACKAGES+='libreoffice-fresh-sa-in ' ;; # Sanskrit
    sat_*) BASE_PACKAGES+='libreoffice-fresh-sat ' ;; # Santali
    sd_*) BASE_PACKAGES+='libreoffice-fresh-sd ' ;; # Sindhi
    si_*) BASE_PACKAGES+='libreoffice-fresh-si ' ;; # Sinhala
    sid_*) BASE_PACKAGES+='libreoffice-fresh-sid ' ;; # Sidama
    sk_*) BASE_PACKAGES+='libreoffice-fresh-sk ' ;; # Slovak
    sl_*) BASE_PACKAGES+='libreoffice-fresh-sl ' ;; # Slovenian
    sq_*) BASE_PACKAGES+='libreoffice-fresh-sq ' ;; # Albanien
    sr_*lat*) BASE_PACKAGES+='libreoffice-fresh-sr-latn ' ;; # Serbian (Latin)
    sr_*) BASE_PACKAGES+='libreoffice-fresh-sr ' ;; # Serbian
    ss_*) BASE_PACKAGES+='libreoffice-fresh-ss ' ;; # Swati
    st_*) BASE_PACKAGES+='libreoffice-fresh-st ' ;; # Sotho (Southern)
    sv_*) BASE_PACKAGES+='libreoffice-fresh-sv ' ;; # Swedish
    sw_*) BASE_PACKAGES+='libreoffice-fresh-sw-tz ' ;; # Swahili
    szl_*) BASE_PACKAGES+='libreoffice-fresh-szl ' ;; # Silesian
    ta_*) BASE_PACKAGES+='libreoffice-fresh-ta ' ;; # Tamil
    te_*) BASE_PACKAGES+='libreoffice-fresh-te ' ;; # Telugu
    tg_*) BASE_PACKAGES+='libreoffice-fresh-tg ' ;; # Tajik
    th_*) BASE_PACKAGES+='libreoffice-fresh-th ' ;; # Thai
    tn_*) BASE_PACKAGES+='libreoffice-fresh-tn ' ;; # Tswana
    tr_*) BASE_PACKAGES+='libreoffice-fresh-tr ' ;; # Turkish
    ts_*) BASE_PACKAGES+='libreoffice-fresh-ts ' ;; # Tsonga
    tt_*) BASE_PACKAGES+='libreoffice-fresh-tt ' ;; # Tatar
    ug_*) BASE_PACKAGES+='libreoffice-fresh-ug ' ;; # Uighur
    uk_*) BASE_PACKAGES+='libreoffice-fresh-uk ' ;; # Ukranian
    uz_*) BASE_PACKAGES+='libreoffice-fresh-uz ' ;; # Uzbek
    ve_*) BASE_PACKAGES+='libreoffice-fresh-ve ' ;; # Venda
    vec_*) BASE_PACKAGES+='libreoffice-fresh-vec ' ;; # Venetian
    vi_*) BASE_PACKAGES+='libreoffice-fresh-vi ' ;; # Vietnamese
    xh_*) BASE_PACKAGES+='libreoffice-fresh-xh ' ;; # Xhosa
    zh_CN*|zh_SG*) BASE_PACKAGES+='libreoffice-fresh-zh-cn ' ;; # Simp. Chinese
    zh_*|yue_*|*_TW*) BASE_PACKAGES+='libreoffice-fresh-zh-tw ' ;; # T. Chinese
    zu_*) BASE_PACKAGES+='libreoffice-fresh-zu ' ;; # Zulu
  esac

  # Graphics and VM packages
  if [[ "${VM_TYPE}" != 'none' ]]; then
    case "${VM_TYPE}" in
      qemu)
        additional_packages='spice-vdagent qemu-guest-agent'
        log "* Added QEMU guest utils: ${additional_packages}"
        ;;
      oracle)
        additional_packages='virtualbox-guest-utils'
        log "* Added VirtualBox guest utils: ${additional_packages}"
        ;;
      vmware)
        additional_packages='xf86-video-vmware xf86-input-vmmouse open-vm-tools
          net-tools gtkmm'
        log "* Added VMware guest utils: ${additional_packages}"
        ;;
      *)
        additional_packages='xf86-video-fbdev'
        log "* Added generic VM guest utils: ${additional_packages}"
        ;;
    esac
  else
    if [[ "${GRAPHICS_CHIPSET}" == 'NVIDIA' ]]; then
      until additional_packages="$(dialog --ok-button "${OK}" --no-cancel \
          --menu "\n$(eval echo \"${GRAPHICS_DRIVER_MSG}\")" 18 60 7 \
          "${DEFAULT}" "${GRAPHICS_DEFAULT_MSG}" \
          'nvidia' "${GRAPHICS_NVIDIA_MSG}" \
          'xf86-video-nouveau' "${GRAPHICS_NOUVEAU_MSG}" \
          'xf86-video-intel' "${GRAPHICS_INTEL_MSG}" \
          'xf86-video-vesa' "${GRAPHICS_VESA_MSG}" \
          'xf86-video-ati' "${GRAPHICS_ATI_MSG}" \
          'xf86-video-amdgpu' "${GRAPHICS_AMDGPU_MSG}")"; do
        continue
      done
    else
      until additional_packages="$(dialog --ok-button "${OK}" --no-cancel \
          --menu "\n$(eval echo \"${GRAPHICS_DRIVER_MSG}\")" 17 60 6 \
          "${DEFAULT}" "${GRAPHICS_DEFAULT_MSG}" \
          'xf86-video-ati' "${GRAPHICS_ATI_MSG}" \
          'xf86-video-amdgpu' "${GRAPHICS_AMDGPU_MSG}" \
          'xf86-video-intel' "${GRAPHICS_INTEL_MSG}" \
          'xf86-video-vesa' "${GRAPHICS_VESA_MSG}" \
          'nvidia' "${GRAPHICS_NVIDIA_MSG}" \
          'xf86-video-nouveau' "${GRAPHICS_NOUVEAU_MSG}")"; do
        continue
      done
    fi
    if [[ "${additional_packages}" == "${DEFAULT}" ]]; then
      additional_packages="${DEFAULT_GRAPHICS_DRIVER}"
    fi
    if [[ "${additional_packages}" == 'nvidia' ]]; then
      additional_packages+=' nvidia-dkms nvidia-utils lib32-nvidia-utils
        nvidia-settings nvidia-libgl nvidia-prime'
    elif [[ "${additional_packages}" == 'xf86-video-ati' ||
            "${additional_packages}" == 'xf86-video-amdgpu' ]]; then
      additional_packages+=' vulkan-radeon lib32-vulkan-radeon'
    elif [[ "${additional_packages}" == 'xf86-video-intel' ]]; then
      additional_packages+=' vulkan-intel lib32-vulkan-intel
        lib32-libva-intel-driver'
    fi
    log "* Added graphics driver packages: ${additional_packages}"
  fi
  BASE_PACKAGES+="${additional_packages} "
}

################################################################################
# Present categorized software selection menus and add selected packages (plus
# supplemental packages, as appropriate) to the list of AUR/optional packages.
#
# Globals: AUR_AND_OPTIONAL_PACKAGES, BASE_PACKAGES, LUTRIS_PACKAGES, etc.
# Arguments: None
################################################################################
select_additional_software() {
  local -a software options
  local -i category_num=0 num_categories=13

  while (( category_num < num_categories )); do
    case "${category_num}" in
      0)
        TITLE="${MISC_GAMES_SOFTWARE_TITLE}"
        options=('lutris' "${SOFTWARE_LUTRIS}" OFF \
          'steam' "${SOFTWARE_STEAM}" OFF \
          'itch' "(AUR) ${SOFTWARE_ITCH}" OFF \
          'heroic-games-launcher-bin' \
            "(AUR) ${SOFTWARE_HEROIC_GAMES_LAUNCHER_BIN}" OFF \
          'playonlinux' "${SOFTWARE_PLAYONLINUX}" OFF \
          'innoextract' "${SOFTWARE_INNOEXTRACT}" OFF \
          'libretro' "${SOFTWARE_LIBRETRO}" OFF \
          'dosbox' "${SOFTWARE_DOSBOX}" OFF \
          'scummvm' "${SOFTWARE_SCUMMVM}" OFF)
          ;;
      1)
        TITLE="${ACTION_GAMES_SOFTWARE_TITLE}"
        options=('supertux' "${SOFTWARE_SUPERTUX}" OFF \
          'frogatto' "${SOFTWARE_FROGATTO}" OFF \
          'alex4' "${SOFTWARE_ALEX4}" OFF \
          'asciiportal' "${SOFTWARE_ASCIIPORTAL}" OFF \
          'mari0' "${SOFTWARE_MARI0}" OFF \
          'xonotic' "${SOFTWARE_XONOTIC}" OFF \
          'warsow' "${SOFTWARE_WARSOW}" OFF \
          'sauerbraten' "${SOFTWARE_SAUERBRATEN}" OFF \
          'assaultcube-reloaded' "(AUR) ${SOFTWARE_ASSAULTCUBE_RELOADED}" OFF \
          'openarena' "(AUR) ${SOFTWARE_OPENARENA}" OFF \
          'astromenace' "${SOFTWARE_ASTROMENACE}" OFF \
          'chromium-bsu' "${SOFTWARE_CHROMIUM_BSU}" OFF \
          'starfighter' "(AUR) ${SOFTWARE_STARFIGHTER}" OFF \
          'teeworlds' "${SOFTWARE_TEEWORLDS}" OFF \
          'bzflag' "(AUR) ${SOFTWARE_BZFLAG}" OFF)
          ;;
      2)
        TITLE="${ADVENTURE_GAMES_SOFTWARE_TITLE}"
        options=('bass' "${SOFTWARE_BASS}" OFF \
          'fotaq' "(AUR) ${SOFTWARE_FOTAQ}" OFF \
          'lure' "(AUR) ${SOFTWARE_LURE}" OFF \
          'drascula' "(AUR) ${SOFTWARE_DRASCULA}" OFF \
          'zsdx' "(AUR) ${SOFTWARE_ZSDX}" OFF \
          'sdlpop' "(AUR) ${SOFTWARE_SDLPOP}" OFF \
          'zork1' "(AUR) ${SOFTWARE_ZORK1}" OFF \
          'zork2' "(AUR) ${SOFTWARE_ZORK2}" OFF \
          'zork3' "(AUR) ${SOFTWARE_ZORK3}" OFF \
          'open-adventure' "(AUR) ${SOFTWARE_OPEN_ADVENTURE}" OFF)
          ;;
      3)
        TITLE="${ROLEPLAYING_GAMES_SOFTWARE_TITLE}"
        options=('openmw' "${SOFTWARE_OPENMW}" OFF \
          'openmw-tes3mp' "(AUR) ${SOFTWARE_OPENMW_TES3MP}" OFF \
          'daggerfall-unity-aur-bin' "(AUR) \
            ${SOFTWARE_DAGGERFALL_UNITY_AUR_BIN}" OFF \
          'freedroidrpg' "${SOFTWARE_FREEDROIDRPG}" OFF \
          'flare-game' "(AUR) ${SOFTWARE_FLARE_GAME}" OFF \
          'naev' "${SOFTWARE_NAEV}" OFF \
          'rogue' "${SOFTWARE_ROGUE}" OFF \
          'angband' "${SOFTWARE_ANGBAND}" OFF \
          'umoria' "(AUR) ${SOFTWARE_UMORIA}" OFF \
          'nethack' "${SOFTWARE_NETHACK}" OFF \
          'tome4' "(AUR) ${SOFTWARE_TOME4}" OFF \
          'stone-soup' "${SOFTWARE_STONE_SOUP}" OFF \
          'cataclysm-dda-tiles' "${SOFTWARE_CATACLYSM_DDA_TILES}" OFF \
          'doomrl' "(AUR) ${SOFTWARE_DOOMRL}" OFF \
          'planeshift' "(AUR) ${SOFTWARE_PLANESHIFT}" OFF \
          'runescape-launcher' "(AUR) ${SOFTWARE_RUNESCAPE_LAUNCHER}" OFF \
          'runelite' "(AUR) ${SOFTWARE_RUNELITE}" OFF \
          'manaplus' "${SOFTWARE_MANAPLUS}" OFF)
          ;;
      4)
        TITLE="${STRATEGY_GAMES_SOFTWARE_TITLE}"
        options=('0ad' "${SOFTWARE_0AD}" OFF \
          'widelands' "${SOFTWARE_WIDELANDS}" OFF \
          'megaglest' "${SOFTWARE_MEGAGLEST}" OFF \
          'warzone2100' "${SOFTWARE_WARZONE2100}" OFF \
          'boswars' "(AUR) ${SOFTWARE_BOSWARS}" OFF \
          'curseofwar' "${SOFTWARE_CURSEOFWAR}" OFF \
          'wesnoth' "${SOFTWARE_WESNOTH}" OFF \
          'pingus' "${SOFTWARE_PINGUS}" OFF \
          'hedgewars' "${SOFTWARE_HEDGEWARS}" OFF \
          'warmux' "(AUR) ${SOFTWARE_WARMUX}" OFF \
          'freeciv' "${SOFTWARE_FREECIV}" OFF \
          'singularity' "${SOFTWARE_SINGULARITY}" OFF)
          ;;
      5)
        TITLE="${RACING_GAMES_SOFTWARE_TITLE}"
        options=('supertuxkart' "${SOFTWARE_SUPERTUXKART}" OFF \
          'extremetuxracer' "${SOFTWARE_EXTREMETUXRACER}" OFF \
          'armagetronad' "${SOFTWARE_ARMAGETRONAD}" OFF \
          'gltron' "(AUR) ${SOFTWARE_GLTRON}" OFF \
          'torcs' "(AUR) ${SOFTWARE_TORCS}" OFF)
          ;;
      6)
        TITLE="${SIM_GAMES_SOFTWARE_TITLE}"
        options=('dwarffortress' "${SOFTWARE_DWARFFORTRESS}" OFF \
          'lincity-ng' "${SOFTWARE_LINCITY_NG}" OFF \
          'simutrans' "${SOFTWARE_SIMUTRANS}" OFF \
          'flightgear' "(AUR) ${SOFTWARE_FLIGHTGEAR}" OFF \
          'minetest' "${SOFTWARE_MINETEST}" OFF \
          'minecraft-launcher' "(AUR) ${SOFTWARE_MINECRAFT_LAUNCHER}" OFF)
          ;;
      7)
        TITLE="${DEV_SOFTWARE_TITLE}"
        options=('godot' "${SOFTWARE_GODOT}" OFF \
          'love' "${SOFTWARE_LOVE}" OFF \
          'solarus' "(AUR) ${SOFTWARE_SOLARUS}" OFF \
          'spring' "${SOFTWARE_SPRING}" OFF \
          'unityhub' "(AUR) ${SOFTWARE_UNITYHUB}" OFF \
          'unreal-engine' "(AUR) ${SOFTWARE_UNREAL_ENGINE}" OFF \
          'tiled' "${SOFTWARE_TILED}" OFF \
          'android-studio' "(AUR) ${SOFTWARE_ANDROID_STUDIO}" OFF \
          'allegro' "${SOFTWARE_ALLEGRO}" OFF \
          'python-pygame' "${SOFTWARE_PYTHON_PYGAME}" OFF \
          'panda3d' "(AUR) ${SOFTWARE_PANDA3D}" OFF \
          'pygtk' "(AUR) ${SOFTWARE_PYGTK}" OFF \
          'scratch' "${SOFTWARE_SCRATCH}" OFF \
          'atom' "${SOFTWARE_ATOM}" OFF \
          'code' "${SOFTWARE_CODE}" OFF \
          'geany' "${SOFTWARE_GEANY}" OFF \
          'emacs' "${SOFTWARE_EMACS}" OFF)
          ;;
      8)
        TITLE="${GRAPHICS_SOFTWARE_TITLE}"
        options=('gimp' "${SOFTWARE_GIMP}" OFF \
          'inkscape' "${SOFTWARE_INKSCAPE}" OFF \
          'blender' "${SOFTWARE_BLENDER}" OFF \
          'goxel' "(AUR) ${SOFTWARE_GOXEL}" OFF \
          'magicavoxel' "(AUR) ${SOFTWARE_MAGICAVOXEL}" OFF \
          'libresprite' "(AUR) ${SOFTWARE_LIBRESPRITE}" OFF \
          'aseprite' "(AUR) ${SOFTWARE_ASEPRITE}" OFF \
          'mtpaint' "${SOFTWARE_MTPAINT}" OFF \
          'mypaint' "${SOFTWARE_MYPAINT}" OFF \
          'krita' "${SOFTWARE_KRITA}" OFF)
          ;;
      9)
        TITLE="${MULTIMEDIA_SOFTWARE_TITLE}"
        options=('obs-studio' "${SOFTWARE_OBS_STUDIO}" OFF \
          'openshot' "${SOFTWARE_OPENSHOT}" OFF \
          'kdenlive' "${SOFTWARE_KDENLIVE}" OFF \
          'simplescreenrecorder' "${SOFTWARE_SIMPLESCREENRECORDER}" OFF \
          'youtube-dl' "${SOFTWARE_YOUTUBE_DL}" OFF \
          'minitube' "${SOFTWARE_MINITUBE}" OFF \
          'spotify' "(AUR) ${SOFTWARE_SPOTIFY}" OFF \
          'audacity' "${SOFTWARE_AUDACITY}" OFF \
          'lmms' "${SOFTWARE_LMMS}" OFF \
          'pulseaudio-equalizer' "${SOFTWARE_PULSEAUDIO_EQUALIZER}" OFF)
          ;;
      10)
        TITLE="${INTERNET_SOFTWARE_TITLE}"
        options=('firefox' "${SOFTWARE_FIREFOX}" OFF \
          'chromium' "${SOFTWARE_CHROMIUM}" OFF \
          'google-chrome' "(AUR) ${SOFTWARE_GOOGLE_CHROME}" OFF \
          'opera' "${SOFTWARE_OPERA}" OFF \
          'discord' "${SOFTWARE_DISCORD}" OFF \
          'slack-desktop' "(AUR) ${SOFTWARE_SLACK_DESKTOP}" OFF \
          'hexchat' "${SOFTWARE_HEXCHAT}" OFF \
          'transmission-gtk' "${SOFTWARE_TRANSMISSION_GTK}" OFF \
          'piavpn-bin' "(AUR) ${SOFTWARE_PIAVPN_BIN}" OFF \
          'w3m' "${SOFTWARE_W3M}" OFF \
          'lynx' "${SOFTWARE_LYNX}" OFF \
          'filezilla' "${SOFTWARE_FILEZILLA}" OFF)
          ;;
      11)
        TITLE="${FONTS_AND_LANG_SOFTWARE_TITLE}"
        options=('bdf-unifont' "${SOFTWARE_BDF_UNIFONT}" OFF \
          'noto-fonts-cjk' "${SOFTWARE_NOTO_FONTS_CJK}" OFF \
          'ibus-libpinyin' "${SOFTWARE_IBUS_LIBPINYIN}" OFF \
          'ibus-anthy' "${SOFTWARE_IBUS_ANTHY}" OFF \
          'ibus-hangul' "${SOFTWARE_IBUS_HANGUL}" OFF)
          ;;
      12)
        TITLE="${UTILITIES_SOFTWARE_TITLE}"
        options=('htop' "${SOFTWARE_HTOP}" OFF \
          'gtop' "${SOFTWARE_GTOP}" OFF \
          'bashtop' "${SOFTWARE_BASHTOP}" OFF \
          'mangohud' "(AUR) ${SOFTWARE_MANGOHUD}" OFF \
          'gparted' "${SOFTWARE_GPARTED}" OFF \
          'gnome-disk-utility' "${SOFTWARE_GNOME_DISK_UTILITY}" OFF \
          'baobab' "${SOFTWARE_BAOBAB}" OFF \
          'tmux' "${SOFTWARE_TMUX}" OFF \
          'ranger' "${SOFTWARE_RANGER}" OFF \
          'virtualbox' "${SOFTWARE_VIRTUALBOX}" OFF \
          'libvirt' "${SOFTWARE_LIBVIRT}" OFF \
          'vmware-workstation' "(AUR) ${SOFTWARE_VMWARE_WORKSTATION}" OFF \
          'insync' "(AUR) ${SOFTWARE_INSYNC}" OFF \
          'pcloud-drive' "(AUR) ${SOFTWARE_PCLOUD_DRIVE}" OFF \
          'timeshift' "(AUR) ${SOFTWARE_TIMESHIFT}" OFF \
          'luckybackup' "(AUR) ${SOFTWARE_LUCKYBACKUP}" OFF \
          'authy' "(AUR) ${SOFTWARE_AUTHY}" OFF \
          'clamav' "${SOFTWARE_CLAMAV}" OFF \
          'bleachbit' "${SOFTWARE_BLEACHBIT}" OFF)
    esac
    if (( category_num == 0 )); then
      if software[0]="$(dialog --no-cancel --ok-button "${OK}" --checklist \
          "\n${SELECT_SOFTWARE_MSG}" 0 0 0 "${options[@]}")"; then
        (( category_num++ ))
      fi
    elif software[category_num]="$(dialog --ok-button "${OK}" --cancel-button \
        "${BACK}" --checklist "\n${SELECT_SOFTWARE_MSG}" 0 0 0 \
        "${options[@]}")"; then
      (( category_num++ ))
    else
      (( category_num-- ))
    fi
  done

  # Add supplemental packages, etc., as appropriate
  if grep -q 'lutris' <<<"${software[@]}"; then
    BASE_PACKAGES+="${LUTRIS_PACKAGES} " # install with base
  fi
  if grep -q 'steam' <<<"${software[@]}"; then
    BASE_PACKAGES+='steam steam-native-runtime ' # install with base
  fi
  if grep -q 'drascula' <<<"${software[@]}"; then
    software[0]+=' drascula-audio'
  fi
  if grep -q 'ibus' <<<"${software[@]}"; then
    echo -e "export GTK_IM_MODULE=ibus\nexport QT_IM_MODULE=ibus\nexport \
XMODIFIERS=@im=ibus\nibus-daemon -drx" >>/usr/share/gdl/extra/skel/.xprofile
  fi
  if grep -q 'mangohud' <<<"${software[@]}"; then
    software[0]+=' lib32-mangohud'
  fi
  if grep -q 'virtualbox' <<<"${software[@]}"; then
    software[0]+=' virtualbox-host-modules-arch'
  fi
  if grep -q 'libvirt' <<<"${software[@]}"; then
    software[0]+=' qemu'
  fi
  if grep -q 'firefox' <<<"${software[@]}"; then
    case "${LOCALE}" in
      ach_*) software[0]+=' firefox-i18n-ach' ;; # Acholi
      af_*) software[0]+=' firefox-i18n-af' ;; # Afrikaans
      an_*) software[0]+=' firefox-i18n-an' ;; # Aragonese
      ar_*) software[0]+=' firefox-i18n-ar' ;; # Arabic
      ast_*) software[0]+=' firefox-i18n-ast' ;; # Asturianu
      az_*) software[0]+=' firefox-i18n-az' ;; # Azerbaijani
      be_*) software[0]+=' firefox-i18n-be' ;; # Belarusian
      bg_*) software[0]+=' firefox-i18n-bg' ;; # Bulgarian
      bn_*) software[0]+=' firefox-i18n-bn' ;; # Bengali
      br_*) software[0]+=' firefox-i18n-br' ;; # Breton
      bs_*) software[0]+=' firefox-i18n-bs' ;; # Bosnian
      ca_*val*) software[0]+=' firefox-i18n-ca-valencia' ;; # Catalan (Valencia)
      ca_*) software[0]+=' firefox-i18n-ca' ;; # Catalan
      cak_*) software[0]+=' firefox-i18n-cak' ;; # Maya Kaqchikel
      cs_*) software[0]+=' firefox-i18n-cs' ;; # Czech
      cy_*) software[0]+=' firefox-i18n-cy' ;; # Welsh
      da_*) software[0]+=' firefox-i18n-da' ;; # Danish
      de_*) software[0]+=' firefox-i18n-de' ;; # German
      dsb_*) software[0]+=' firefox-i18n-dsb' ;; # Sorbian (Lower)
      el_*) software[0]+=' firefox-i18n-el' ;; # Greek
      en_CA*) software[0]+=' firefox-i18n-en-gb' ;; # English (Canada)
      en_US*) software[0]+=' firefox-i18n-en-us' ;; # English (United States)
      en_*) software[0]+=' firefox-i18n-en-gb' ;; # English (Great Britain)
      eo_*) software[0]+=' firefox-i18n-eo' ;; # Esperanto
      es_AR*) software[0]+=' firefox-i18n-es-ar' ;; # Spanish (Argentina)
      es_CL*) software[0]+=' firefox-i18n-es-cl' ;; # Spanish (Chile)
      es_MX*) software[0]+=' firefox-i18n-es-mx' ;; # Spanish (Mexico)
      es_*) software[0]+=' firefox-i18n-es-es' ;; # Spanish (Spain)
      et_*) software[0]+=' firefox-i18n-et' ;; # Estonian
      eu_*) software[0]+=' firefox-i18n-eu' ;; # Basque
      fa_*) software[0]+=' firefox-i18n-fa' ;; # Persian
      ff_*) software[0]+=' firefox-i18n-ff' ;; # Fulah
      fi_*) software[0]+=' firefox-i18n-fi' ;; # Finnish
      fr_*) software[0]+=' firefox-i18n-fr' ;; # French
      fy_*) software[0]+=' firefox-i18n-fy-nl' ;; # Frisian
      ga_*) software[0]+=' firefox-i18n-ga-ie' ;; # Irish
      gd_*) software[0]+=' firefox-i18n-gd' ;; # Gaelic (Scottish)
      gl_*) software[0]+=' firefox-i18n-gl' ;; # Galician
      gn_*|gug_*) software[0]+=' firefox-i18n-gn' ;; # Guarani
      gu_*) software[0]+=' firefox-i18n-gu-in' ;; # Gujarati
      he_*) software[0]+=' firefox-i18n-he' ;; # Hebrew
      hi_*) software[0]+=' firefox-i18n-hi-in' ;; # Hindi
      hr_*) software[0]+=' firefox-i18n-hr' ;; # Croatian
      hsb_*) software[0]+=' firefox-i18n-hsb' ;; # Sorbian (Upper)
      hu_*) software[0]+=' firefox-i18n-hu' ;; # Hungarian
      hy_*) software[0]+=' firefox-i18n-hy-am' ;; # Armenian
      ia_*) software[0]+=' firefox-i18n-ia' ;; # Interlingua
      id_*) software[0]+=' firefox-i18n-id' ;; # Indonesian
      is_*) software[0]+=' firefox-i18n-is' ;; # Icelandic
      it_*) software[0]+=' firefox-i18n-it' ;; # Italian
      ja_*) software[0]+=' firefox-i18n-ja' ;; # Japanese
      ka_*) software[0]+=' firefox-i18n-ka' ;; # Georgian
      kab_*) software[0]+=' firefox-i18n-kab' ;; # Kabyle, Taqbaylit, etc.
      kk_*) software[0]+=' firefox-i18n-kk' ;; # Kazakh
      km_*) software[0]+=' firefox-i18n-km' ;; # Khmer
      kn_*) software[0]+=' firefox-i18n-kn' ;; # Kannada
      ko_*) software[0]+=' firefox-i18n-ko' ;; # Korean
      lij_*) software[0]+=' firefox-i18n-lij' ;; # Ligurian
      lt_*) software[0]+=' firefox-i18n-lt' ;; # Lithuanian
      lv_*) software[0]+=' firefox-i18n-lv' ;; # Latvian
      mk_*) software[0]+=' firefox-i18n-mk' ;; # Macedonian
      mr_*) software[0]+=' firefox-i18n-mr' ;; # Marathi
      ms_*) software[0]+=' firefox-i18n-ms' ;; # Malay
      my_*) software[0]+=' firefox-i18n-my' ;; # Burmese
      nb_*) software[0]+=' firefox-i18n-nb-no' ;; # Norwegian (Bokmål)
      ne_*) software[0]+=' firefox-i18n-ne-np' ;; # Nepali
      nl_*) software[0]+=' firefox-i18n-nl' ;; # Dutch
      nn_*) software[0]+=' firefox-i18n-nn-no' ;; # Norwegian (Nynorsk)
      oc_*) software[0]+=' firefox-i18n-oc' ;; # Occitan
      pa_*) software[0]+=' firefox-i18n-pa-in' ;; # Punjabi
      pl_*) software[0]+=' firefox-i18n-pl' ;; # Polish
      pt_BR*) software[0]+=' firefox-i18n-pt-br' ;; # Portuguese (Brazil)
      pt_*) software[0]+=' firefox-i18n-pt-pt' ;; # Portuguese (Portugal)
      rm_*) software[0]+=' firefox-i18n-rm' ;; # Romansh
      ro_*) software[0]+=' firefox-i18n-ro' ;; # Romanian
      ru_*) software[0]+=' firefox-i18n-ru' ;; # Russian
      si_*) software[0]+=' firefox-i18n-si' ;; # Sinhala
      sk_*) software[0]+=' firefox-i18n-sk' ;; # Slovak
      sl_*) software[0]+=' firefox-i18n-sl' ;; # Slovenian
      son_*) software[0]+=' firefox-i18n-son' ;; # Songhai
      sq_*) software[0]+=' firefox-i18n-sq' ;; # Albanien
      sr_*) software[0]+=' firefox-i18n-sr' ;; # Serbian
      sv_*) software[0]+=' firefox-i18n-sv-se' ;; # Swedish
      ta_*) software[0]+=' firefox-i18n-ta' ;; # Tamil
      te_*) software[0]+=' firefox-i18n-te' ;; # Telugu
      th_*) software[0]+=' firefox-i18n-th' ;; # Thai
      tl_*) software[0]+=' firefox-i18n-tl' ;; # Tagolog
      tr_*) software[0]+=' firefox-i18n-tr' ;; # Turkish
      trs_*) software[0]+=' firefox-i18n-trs' ;; # Chicahuaxtla Triqui
      uk_*) software[0]+=' firefox-i18n-uk' ;; # Ukranian
      ur_*) software[0]+=' firefox-i18n-ur' ;; # Urdu
      uz_*) software[0]+=' firefox-i18n-uz' ;; # Uzbek
      vi_*) software[0]+=' firefox-i18n-vi' ;; # Vietnamese
      xh_*) software[0]+=' firefox-i18n-xh' ;; # Xhosa
      *_CN*|zh_SG*) software[0]+=' firefox-i18n-zh-cn' ;; # Simplified Chinese
      zh_*|yue_*|*_TW*) software[0]+=' firefox-i18n-zh-tw' ;; # Trad. Chinese
    esac
  fi

  # Add selected and supplemental software to the AUR/optional package list
  AUR_AND_OPTIONAL_PACKAGES+="${software[*]} "
}

################################################################################
# Give the user a final chance to cancel installation, then clean up the list of
# base packages and install them via pacstrap. If pacstrap fails, upload log
# file text to termbin and present the resulting URL before exiting.
#
# Globals: INSTALL_CONFIRM, BASE_PACKAGES, PACSTRAP_ERROR_MSG, etc.
# Arguments: None
################################################################################
install_base() {
  TITLE="${INSTALLATION_TITLE}"
  local log_url

  # Confirm user wants to begin installing packages
  while ! yesno "${INSTALL_CONFIRM}" "${YES}" "${NO}" 'defaultno'; do
    if yesno "${EXIT_CONFIRM}" "${YES}" "${NO}" 'defaultno'; then
      log "User chose to exit installer: installation cancelled"
      return_to_shell_prompt
    fi
  done

  # Clean up package list
  BASE_PACKAGES="$(tr <<<"${BASE_PACKAGES}" " " "\n" | sort | uniq |
    tr "\n" " ")"
  log "Base package list: ${BASE_PACKAGES}"

  # Begin installation
  clear
  dragonsay "Installing base packages..."
  log "Installing base packages..."
  if pacstrap /mnt ${BASE_PACKAGES}; then
    log "Base installation complete"
  else
    log "ERROR: Installation failed"
    log_url="$(nc termbin.com 9999 <"${LOG_FILE}")"
    log "Log uploaded to termbin: ${log_url}"
    message "${PACSTRAP_ERROR_MSG} ${log_url}"
    return_to_shell_prompt
  fi
}

################################################################################
# Configure the freshly-installed GDL system.
#
# Globals: SYSTEM_AUTO_ENCRYPTED, BASE_PACKAGES, UEFI, ESP_MNT, DRIVE, BOOT,
#   SWAP_SIZE, HOSTNAME, PASSWORD, SSL_KEY, LOCALE, KEYMAP, TIME_ZONE,
#   BLUETOOTH_AVAILABLE, VM_TYPE
# Arguments: None
################################################################################
configure_system() {
  local pw fstab='/mnt/etc/fstab' grub='/mnt/etc/default/grub' \
    grub_theme='/boot/grub/themes/gdl'
  local -i int
  log "Configuring system..."

  # Initial fstab config
  genfstab -U /mnt >>"${fstab}"
  log "* Generated fstab"

  # GRUB config
  mkdir -p /mnt"${grub_theme}"
  cp -r /usr/share/gdl/extra/grub-theme/* /mnt"${grub_theme}"
  if ! mount | grep -q 'type btrfs' ||
      (mount | grep -q ' /boot ' &&
       mount | grep ' /boot ' | grep -vq 'type btrfs'); then
    sed -i 's/GRUB_DEFAULT=0/GRUB_DEFAULT=saved/' "${grub}"
    sed -i 's/#GRUB_SAVEDEFAULT/GRUB_SAVEDEFAULT/' "${grub}"
  fi
  sed -i 's/GRUB_TIMEOUT=5/GRUB_TIMEOUT=3/' "${grub}"
  sed -i "s:#GRUB_COLOR_N.*:GRUB_COLOR_NORMAL=\"red/black\":" "${grub}"
  sed -i "s:#GRUB_COLOR_H.*:GRUB_COLOR_HIGHLIGHT=\"yellow/black\":" "${grub}"
  sed -i "s:#GRUB_THEME.*:GRUB_THEME=\"${grub_theme}/theme.txt\":" "${grub}"
  if "${SYSTEM_AUTO_ENCRYPTED}"; then
    sed -i "s!quiet!cryptdevice=/dev/lvm/lvroot:root:allow-discards \
root=/dev/mapper/root transparent_hugepage=never!" "${grub}"
  else
    sed -i 's/quiet/transparent_hugepage=never/' "${grub}"
  fi
  if grep -q 'nvidia' <<<"${BASE_PACKAGES}"; then
    sed -i '/GRUB_CMDLINE_LINUX_DEFAULT=/ s/.$/ nvidia-drm.modeset=1"/;s/" /"/'\
      "${grub}"
  fi
  if "${UEFI}"; then
    arch-chroot /mnt grub-install --target=x86_64-efi \
      --efi-directory="${ESP_MNT}" --bootloader-id=GRUB
    cp /mnt"${ESP_MNT}"/EFI/boot/grubx64.efi \
      /mnt"${ESP_MNT}"/EFI/boot/bootx64.efi
  else
    arch-chroot /mnt grub-install /dev/"${DRIVE}"
  fi
  arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg
  log "* Configured grub"

  # NVIDIA GPU config
  if grep -q 'nvidia' <<<"${BASE_PACKAGES}"; then
    sed -i 's/^MODULES=(/&nvidia nvidia_modeset nvidia_uvm nvidia_drm /' \
      /mnt/etc/mkinitcpio.conf
    echo -e 'options nvidia_drm modeset=1\nblacklist nouveau' \
      >/mnt/etc/modprobe.d/nvidia.conf
    sed -i 's:^FILES=(:&/etc/modprobe.d/nvidia.conf :;s/ )/)/' \
      /mnt/etc/mkinitcpio.conf
    if [[ ! -d /mnt/etc/pacman.d/hooks ]]; then
      mkdir /mnt/etc/pacman.d/hooks
    fi
    # https://wiki.archlinux.org/index.php/NVIDIA#Pacman_hook
    echo -e "[Trigger]\nOperation=Install\nOperation=Upgrade\nOperation=Remove\
\nType=Package\nTarget=nvidia\nTarget=linux\n\n[Action]\nDescription=Update \
Nvidia module in initcpio\nDepends=mkinitcpio\nWhen=PostTransaction\nNeeds\
Targets\nExec=/bin/sh -c 'while read -r trg; do case \$trg in linux) exit 0; \
esac; done; /usr/bin/mkinitcpio -P'\n" >/mnt/etc/pacman.d/hooks/nvidia.hook
    log "* Enabled Nvidia DRM (Direct Rendering Manager)"
  fi

  # XFS config
  if mount | grep -q 'type xfs'; then
    sed -i 's/^MODULES=(/&xfs /;s/ )/)/' /mnt/etc/mkinitcpio.conf
    log "* Configured system for xfs"
  fi

  # NVMe config
  if grep -q 'nvme' <<<"${BOOT}"; then
    sed -i 's/^MODULES=(/&nvme /;s/ )/)/' /mnt/etc/mkinitcpio.conf
    log "* Configured system for nvme"
  fi

  # Additional fstab, crypttab, and mkinitcpio config
  if "${SYSTEM_AUTO_ENCRYPTED}"; then
    if "${UEFI}"; then
      echo "/dev/${BOOT} ${ESP_MNT} vfat rw,relatime,fmask=0022,dmask=0022,code\
page=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro 0 2" >"${fstab}"
    else
      echo "/dev/${BOOT} /boot ext4 defaults 0 2" >"${fstab}"
    fi
    echo "/dev/mapper/root / ${FS} defaults 0 1" >>"${fstab}"
    echo "/dev/mapper/tmp /tmp tmpfs defaults 0 0" >>"${fstab}"
    echo "tmp /dev/lvm/tmp /dev/urandom tmp,cipher=aes-xts-plain64,size=256" \
      >>/mnt/etc/crypttab
    if (( SWAP_SIZE > 0 )); then
      echo "/dev/mapper/swap none swap defaults 0 0" >>"${fstab}"
      echo "swap /dev/lvm/swap /dev/urandom \
swap,cipher=aes-xts-plain64,size=256" >>/mnt/etc/crypttab
    fi
    # shellcheck disable=SC1004
    sed -i "s/^HOOKS=.*/HOOKS=(base udev autodetect keyboard keymap console\
font modconf block encrypt lvm2 filesystems fsck)/" /mnt/etc/mkinitcpio.conf
    arch-chroot /mnt mkinitcpio -P
    log "* Configured system for encryption and created new initramfs"
  else
    # shellcheck disable=SC1004
    sed -i "s/^HOOKS=.*/HOOKS=(base udev autodetect keyboard keymap \
consolefont modconf block lvm2 filesystems fsck)/" /mnt/etc/mkinitcpio.conf
    arch-chroot /mnt mkinitcpio -P
    log "* Created new initramfs"
  fi

  # Locale config
  sed -i "s/#${LOCALE}/${LOCALE}/" /mnt/etc/locale.gen
  echo "LANG=${LOCALE}" >/mnt/etc/locale.conf
  arch-chroot /mnt locale-gen
  log "* Set system locale: ${LOCALE}"

  # Keyboard config
  echo "KEYMAP=${KEYMAP}" >/mnt/etc/vconsole.conf
  echo -e "Section \"InputClass\"\nIdentifier \"system-keyboard\"\nMatchIs\
Keyboard \"on\"\nOption \"XkbLayout\" \"${KEYMAP}\"\nEndSection" \
    >/mnt/etc/X11/xorg.conf.d/00-keyboard.conf
  arch-chroot /mnt localectl set-x11-keymap "${KEYMAP}"
  log "* Set system keymap: ${KEYMAP}"

  # Time zone and hardware clock config
  arch-chroot /mnt ln -sf /usr/share/zoneinfo/"${TIME_ZONE}" /etc/localtime
  arch-chroot /mnt hwclock --systohc # to generate /etc/adjtime
  log "* Set system time zone: ${TIME_ZONE}"

  # Firewall, network, and bluetooth config
  arch-chroot /mnt ufw enable
  enable_service ufw.service
  enable_service NetworkManager.service
  enable_service dhcpcd.service
  if "${BLUETOOTH_AVAILABLE}"; then
    enable_service bluetooth.service
  fi

  # VM config
  case "${VM_TYPE}" in
    qemu) enable_service qemu-guest-agent.service ;;
    oracle) enable_service vboxservice.service ;;
    vmware)
      cat /mnt/proc/version >/mnt/etc/arch-release
      enable_service vmtoolsd.service
      enable_service vmware-vmblock-fuse.service
      for int in {0..6}; do mkdir -p /mnt/etc/init.d/rc"${int}".d; done
      ;;
  esac

  # Desktop config
  arch-chroot /mnt fc-cache -f # build font information cache files
  cp /usr/share/gdl/extra/gdl.png /mnt/usr/share/pixmaps
  cp /usr/share/gdl/extra/gdl.png /mnt/usr/share/icons
  cp -r /usr/share/gdl/extra/Breeze_Amber /mnt/usr/share/icons
  cp -rT /usr/share/gdl/extra/wallpapers /mnt/usr/share/backgrounds/archlinux
  cp -rT /usr/share/gdl/extra/skel /mnt/etc/skel
  cp -rT /usr/share/gdl/extra/root /mnt/root
  cp /mnt/etc/skel/.bash_profile /mnt/root/
  cp /mnt/etc/skel/.vimrc /mnt/root/
  cp /mnt/etc/skel/.xinitrc /mnt/root/
  cp /usr/share/gdl/extra/gdl.png /mnt/root/.face
  log "* Configured desktop environment"

  # Display manager (login manager) config
  cp -rT /usr/share/gdl/extra/lightdm /mnt/etc/lightdm
  enable_service lightdm.service

  # Pacman config
  if [[ -f /mnt/var/lib/pacman/db.lck ]]; then
    rm /mnt/var/lib/pacman/db.lck &>/dev/null
  fi
  sed -i 's/#Color/Color\nILoveCandy/' /mnt/etc/pacman.conf
  sed -i 's/#VerbosePkgLists/VerbosePkgLists/' /mnt/etc/pacman.conf
  sed -i 's/#ParallelDownloads/ParallelDownloads/' /mnt/etc/pacman.conf
  sed -zi 's/#\[multilib]\n#Include/[multilib]\nInclude/' /mnt/etc/pacman.conf
  log "* Customized pacman.conf"

  # Hostname and root user config
  echo "${HOSTNAME}" >/mnt/etc/hostname
  echo -e "127.0.0.1 localhost\n::1 localhost\n127.0.1.1 \
${HOSTNAME}.localdomain ${HOSTNAME}" >>/mnt/etc/hosts
  log "* Set hostname: ${HOSTNAME}"
  pw="$(echo "${PASSWORD}" | openssl enc -aes-256-cbc -a -d -salt -pbkdf2 \
    -iter 1000 -pass pass:"${SSL_KEY}")"
  printf "%s\n%s" "${pw}" "${pw}" | arch-chroot /mnt passwd root
  unset pw
  log "* Set root user password"

  # CPU frequency scaling
  enable_service cpupower.service

  # Periodic (weekly) TRIM for any attached drives that support 'discard'
  enable_service fstrim.timer

  # Decrease swappiness
  echo "vm.swappiness=10" >/mnt/etc/sysctl.d/99-swappiness.conf

  # Ensure proper MIDI support for GStreamer-based media players
  mkdir -p /mnt/usr/share/sounds/sf2
  arch-chroot /mnt sh -c "ln -s /usr/share/soundfonts/FluidR3_GM.sf2 \
    /usr/share/sounds/sf2/"

  log "System configuration complete"
}

################################################################################
# Enable a given systemd service within the newly-installed system.
#
# Globals: None
# Arguments: Name of the desired systemd service.
################################################################################
enable_service() {
  if [[ -n "$1" ]] && arch-chroot /mnt systemctl enable "$1"; then
    log "* Enabled systemd service '$1'"
  else
    log "* ERROR: Failed to enable systemd service '$1'"
  fi
}

################################################################################
# Install AUR helper 'yay' and use it to update the new system and install all
# AUR/optional packages. If any packages fail, provide the option to try again.
#
# Globals: AUR_AND_OPTIONAL_PACKAGES, LOG_FILE, ERROR
# Arguments: None
################################################################################
install_additional_software() {
  local pw package failed_packages try='y'

  # Create a special temporary user for installing and using yay (AUR helper)
  dragonsay "Setting up AUR support..."
  log "Setting up AUR support..."
  pw="$(< /dev/urandom tr -dc "@#*%&_A-Z-a-z-0-9" | head -c16)"
  arch-chroot /mnt mkdir yaytemp
  arch-chroot /mnt chmod 777 yaytemp
  arch-chroot /mnt useradd -rNM -d /yaytemp -s /usr/bin/nologin yaybuilder
  arch-chroot /mnt sh -c "echo -e '${pw}\n${pw}\n' | passwd yaybuilder"
  arch-chroot /mnt sh -c "echo 'yaybuilder ALL=(ALL) NOPASSWD: ALL' |
    tee /etc/sudoers.d/yaybuilder"
  arch-chroot /mnt sh -c "echo 'root ALL=(yaybuilder) NOPASSWD: ALL' |
    tee -a /etc/sudoers.d/yaybuilder"

  # Install yay, update, then install additional packages using yay
  if arch-chroot /mnt sh -c "cd yaytemp &&
      sudo -u yaybuilder git clone https://aur.archlinux.org/yay-bin.git &&
      cd yay-bin && sudo -u yaybuilder makepkg -si --noconfirm"; then
    log "* AUR helper 'yay' installed"
  else
    log "* ERROR: Failed to install AUR helped 'yay'"
  fi
  arch-chroot /mnt sudo -u yaybuilder yay -Syu --noconfirm
  AUR_AND_OPTIONAL_PACKAGES="$(tr <<<"${AUR_AND_OPTIONAL_PACKAGES}" " " "\n" |
    sort | uniq | tr "\n" " ")"
  log "AUR and optional software package list: ${AUR_AND_OPTIONAL_PACKAGES}"
  dragonsay "Installing additional software..."
  log "Installing AUR/optional packages..."
  while [[ -n "${AUR_AND_OPTIONAL_PACKAGES}" ]] && grep -iq '^y' <<<"${try}"; do
    failed_packages=''
    for package in ${AUR_AND_OPTIONAL_PACKAGES}; do
      log "* Installing ${package}..."
      if ! arch-chroot /mnt sudo -u yaybuilder yay -S "${package}" --needed \
          --noconfirm; then
        log "* ERROR: Installation of ${package} failed"
        failed_packages+="${package} "
      fi
    done
    if [[ -n "${failed_packages}" ]]; then
      echo -e "${BOLD_RED}ERROR: ${WHITE}$(wc -w <<<"${failed_packages}") \
package(s) failed to install: ${CYAN}${failed_packages}${COLOR_RESET}"
      while true; do
        echo -en "${WHITE}Try again? (y/n) ${COLOR_RESET}" && read try
        if grep -Eiq '^n|^y' <<<"${try}"; then
          break
        fi
      done
    fi
    AUR_AND_OPTIONAL_PACKAGES="${failed_packages}"
  done
  if [[ -n "${failed_packages}" ]]; then
    log "$(wc -w <<<"${failed_packages}") failed package(s): ${failed_packages}"
  else
    log "All packages successfully installed"
  fi

  # Clean things up
  log "Cleaning up..."
  arch-chroot /mnt sudo -u yaybuilder yay -Yc --noconfirm
  arch-chroot /mnt userdel -f yaybuilder
  arch-chroot /mnt rm /etc/passwd- /etc/sudoers.d/yaybuilder
  arch-chroot /mnt rm -r yaytemp
}

################################################################################
# Add the previously-defined user to the newly-installed system.
#
# Globals: FULL_NAME, USERNAME, PASSWORD, SSL_KEY, BASE_PACKAGES
# Arguments: None
################################################################################
add_user() {
  local pw

  if [[ -z "${FULL_NAME}" ]]; then
    arch-chroot /mnt useradd -m -G audio,network,power,storage,optical -s \
      /bin/bash "${USERNAME}"
  else
    arch-chroot /mnt useradd -m -G audio,network,power,storage,optical -c \
      "${FULL_NAME}" -s /bin/bash "${USERNAME}"
  fi
  pw="$(echo "${PASSWORD}" | openssl enc -aes-256-cbc -a -d -salt -pbkdf2 \
    -iter 1000 -pass pass:"${SSL_KEY}")"
  printf "%s\n%s" "${pw}" "${pw}" | arch-chroot /mnt passwd "${USERNAME}"
  unset pw
  sed -i '/%wheel ALL=(ALL) ALL/s/^# //' /mnt/etc/sudoers
  arch-chroot /mnt usermod -a -G wheel "${USERNAME}"

  # If Lutris was installed, provide a shortcut for installing Battle.net
  if grep -q 'lutris' <<<"${BASE_PACKAGES}"; then
    mkdir /mnt/home/"${USERNAME}"/Desktop
    echo -e "[Desktop Entry]\nVersion=1.0\nType=Link\nName=Install Battle.net
Comment=Install the Blizzard Battle.net app via Lutris\nIcon=user-bookmarks
URL=lutris:blizzard-battlenet-standard" \
      >/mnt/home/"${USERNAME}"/Desktop/blizzard.desktop
    arch-chroot /mnt chown -R "${USERNAME}:${USERNAME}" \
      /home/"${USERNAME}"/Desktop
  fi

  log "User added: ${USERNAME}"
}

################################################################################
# Custom 'dialog' function. Unless extraneous text should be reduced, a
# backtitle is included which may also show remaining battery capacity. Output
# is directed to STDOUT ('dialog' defaults to STDERR otherwise).
#
# Globals: TITLE, BACKTITLE, DEFAULT_BACKTITLE, BATTERY, REDUCE_EXTRANEOUS_TEXT
# Arguments: The desired text plus additional 'dialog' options.
################################################################################
dialog() {
  if "${REDUCE_EXTRANEOUS_TEXT}"; then
    /usr/bin/dialog --stdout --colors --title " ${TITLE} " "$@"
  else
    BACKTITLE="${DEFAULT_BACKTITLE}"
    if [[ "${BATTERY}" != 'none' ]]; then
      BACKTITLE+=" | Battery: $(cat "${BATTERY}"/capacity)%"
    fi
    /usr/bin/dialog --stdout --colors --backtitle "${BACKTITLE}" --title \
      " ${TITLE} " "$@"
  fi
}

################################################################################
# Present a message in an 'ok' dialog box.
#
# Globals: OK
# Arguments: The desired message text.
################################################################################
message() {
  dialog --ok-button "${OK}" --msgbox "\n$1" 0 0
}

################################################################################
# Present a message in a 'yes/no' dialog box.
#
# Globals: None
# Arguments: The desired body text plus 'yes' and 'no' button texts.
################################################################################
yesno() {
  local body="$1" yes_button="$2" no_button="$3"

  if (( $# == 4 )); then
    dialog --defaultno --yes-label "${yes_button}" --no-label "${no_button}" \
      --yesno "\n${body}" 0 0
  else
    dialog --yes-label "${yes_button}" --no-label "${no_button}" \
      --yesno "\n${body}" 0 0
  fi
  return $?
}

################################################################################
# Present a dialog box with a "gauge" (loading bar) that gradually fills up as
# background processes are completed.
#
# Globals: None
# Arguments: The desired text to display above the loading bar.
################################################################################
load_bar() {
  {
    local -i progress=1

    # shellcheck disable=SC2009
    while [[ -n $! ]] && ps | grep -q $!; do
      sleep 0.1
      echo "${progress}"
      if (( progress < 100 )); then
        (( ++progress ))
      fi
    done
    echo 100
    sleep 0.7
  } | dialog --gauge "\n$1" 9 79 0
}

################################################################################
# Present a message as if spoken by an ASCII dragon via 'cowsay' (or simply
# 'echo' the message if extraneous text should be reduced).
#
# Globals: REDUCE_EXTRANEOUS_TEXT
# Arguments: A string of text to be presented.
################################################################################
dragonsay() {
  if "${REDUCE_EXTRANEOUS_TEXT}" ||
      grep -Eq 'bulgarian|greek|russian' <<<"${LANG_FILE}"; then
    echo -e "$1\n"
  else
    cowsay -f dragon "$1"
  fi
}

################################################################################
# Append a given string or command output stream to the log file.
#
# Globals: LOG_FILE
# Arguments: A string of text or piped command output.
################################################################################
log() {
  if [[ -n "$1" ]]; then # manual logging
    echo "[$(date '+%H:%M:%S')]: $1" >>"${LOG_FILE}"
  else # command output
    while read -r output; do
      echo "${output}" >>"${LOG_FILE}"
    done
  fi
}

################################################################################
# Facilitate the installation of Golden Drake Linux.
#
# Globals: ABOUT_GDL_TITLE, ABOUT_GDL_MSG, OK, INSTALL_COMPLETE_MSG,
#   INSTALL_COMPLETE_HELP, LOG_FILE
# Arguments: None
# Outputs: The log file is copied to the new system's '/root'.
################################################################################
main() {
  initialize
  set_installer_language
  set_keymap
  TITLE="${ABOUT_GDL_TITLE}"
  dialog --ok-button "${OK}" --msgbox "\n${ABOUT_GDL_MSG}" 23 80
  check_internet_connection
  set_locale
  set_time_zone
  prepare_drives
  set_hostname
  set_user
  prepare_base
  select_additional_software
  install_base
  configure_system
  install_additional_software
  add_user
  clear
  dragonsay "${INSTALL_COMPLETE_MSG}"
  echo -e "${INSTALL_COMPLETE_HELP}"
  log "GDL installation complete"
  cp "${LOG_FILE}" /mnt/root
}

main
