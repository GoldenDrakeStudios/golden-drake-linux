#!/bin/bash
#
# Installer script for Golden Drake Linux (GDL): Arch for gamers and game devs!
#
# Copyright (C) 2020-2022 Golden Drake Studios: goldendrakestudios.com
# Forked originally from the Anarchy installer: anarchyinstaller.gitlab.io
#
# shellcheck disable=SC2086

# shellcheck source=gdl.conf
source /etc/gdl.conf || exit 1
# shellcheck source=lang/english.conf
source "${LANG_FILE}" || exit 1

################################################################################
# Initialize installer. If this is the script's first (automatic) run, create
# the log file (by posting its first log message), start the network manager,
# and customize pacman.conf, then return the user to the command line so they
# can run other commands before (or instead of) launching the install process.
# Otherwise (i.e., if the log file already exists), prepare for installation by
# evaluating the hardware environment, setting a 'force_quit' trap, etc.
#
# Globals: LOG_FILE, REDUCE_EXTRANEOUS_TEXT, BATTERY, VM_TYPE, GPU_CHIPSET,
#   DEFAULT_GPU_DRIVER
# Arguments: None
################################################################################
initialize() {
  if [[ ! -f "${LOG_FILE}" ]]; then
    log "Initializing GDL installer v${GDL_VERSION}..."
    systemctl start NetworkManager.service
    sed -i 's/#Color/Color\nILoveCandy/' /etc/pacman.conf
    sed -i '/#ParallelDownloads/s/#//' /etc/pacman.conf
    sed -zi 's/#\[multilib]\n#Include/[multilib]\nInclude/' /etc/pacman.conf
    return_to_shell_prompt
  elif grep -q 'errors logged' "${LOG_FILE}"; then
    log "Relaunching installer..."
  fi
  trap force_quit SIGINT # call 'force_quit' when Ctrl+C is pressed
  set -o pipefail # ensure $? remembers failures from piped commands
  [[ -d /tmp/gdl ]] || mkdir /tmp/gdl
  if (( $(tput lines) < 25 )) || grep -q 'accessibility=' /proc/cmdline; then
    REDUCE_EXTRANEOUS_TEXT='true'
  fi
  if [[ -d /sys/class/power_supply ]]; then
    BATTERY="$(find /sys/class/power_supply -name 'BAT*' | head -n 1)"
  fi
  [[ -n "${BATTERY}" ]] && log "Battery detected: ${BATTERY}"
  if [[ "${VM_TYPE}" == 'none' ]]; then
    if lspci | grep 'VGA' | grep -q 'Intel'; then
      GPU_CHIPSET='Intel'
      DEFAULT_GPU_DRIVER='xf86-video-intel'
      BASE_PACKAGES+='intel-gpu-tools ' # useful even if another GPU is present
    fi
    if lspci | grep 'VGA' | grep -Eq 'ATI|AMD'; then
      GPU_CHIPSET='AMD/ATI'
      DEFAULT_GPU_DRIVER='xf86-video-ati'
      BASE_PACKAGES+='radeontop ' # useful even if another GPU is present
    fi
    if lspci | grep 'VGA' | grep -iq 'nvidia'; then
      GPU_CHIPSET='NVIDIA'
      DEFAULT_GPU_DRIVER='nvidia'
    fi
    log "Graphics chipset detected: ${GPU_CHIPSET}"
  else
    log "VM environment detected: ${VM_TYPE}"
  fi
}

################################################################################
# Return the user to the command line with a welcome message plus help text
# telling them how to (a) relaunch the installer, (b) read ArchWiki articles
# offline in the terminal, (c) reboot, or (d) shut down.
#
# Globals: SHELL_PROMPT_WELCOME, SHELL_PROMPT_HELP, ERRORS_LOGGED
# Arguments: None
################################################################################
return_to_shell_prompt() {
  dragonsay "${SHELL_PROMPT_WELCOME}" --check-errors
  echo -e "${SHELL_PROMPT_HELP}"
  exit "${ERRORS_LOGGED}"
}

################################################################################
# Handle a sudden exit caused by the user pressing Ctrl+C.
#
# Globals: TITLE, FORCE_QUIT_TITLE, FORCE_QUIT_MSG, ERRORS_LOGGED
# Arguments: None
################################################################################
force_quit() {
  log "User force quit the installer (errors logged: ${ERRORS_LOGGED})"
  TITLE="${FORCE_QUIT_TITLE}"
  message "${FORCE_QUIT_MSG}"
  return_to_shell_prompt
}

################################################################################
# Present the language menu (for the installer, not the soon-to-be-installed
# system: its language will be determined by 'set_locale'). If the associated
# language file differs from the previously-sourced language file, source it to
# update all language-specific globals and edit gdl.conf to ensure the same
# language file is sourced again if the installer is closed and relaunched.
#
# Globals: TITLE, SET_LANG_TITLE, SET_LANG_MSG, LANG_FILE, ERRORS_LOGGED
# Arguments: None
################################################################################
set_installer_language() {
  TITLE="${SET_LANG_TITLE}"
  local language prev_lang_file="${LANG_FILE}"

  until language="$(dialog --no-cancel --menu "\n${SET_LANG_MSG}" 20 60 10 \
      'English' 'English' \
      'Bulgarian' 'Български' \
      'Dutch' 'Nederlands' \
      'French' 'Français' \
      'German' 'Deutsch' \
      'Greek' 'Ελληνικά' \
      'Hungarian' 'Magyar' \
      'Indonesian' 'bahasa Indonesia' \
      'Italian' 'Italiano' \
      'Latvian' 'Latviešu' \
      'Lithuanian' 'Lietuvių' \
      'Polish' 'Polski' \
      'Portuguese' 'Português' \
      'Portuguese-Brazil' 'Português do Brasil' \
      'Romanian' 'Română' \
      'Russian' 'Русский' \
      'Spanish' 'Español' \
      'Swedish' 'Svenska')"; do
    continue
  done
  LANG_FILE="/usr/share/gdl/lang/${language@L}.conf"
  if [[ "${LANG_FILE}" != "${prev_lang_file}" ]]; then
    if source "${LANG_FILE}"; then
      sed -i "s:^LANG_FILE=.*:LANG_FILE='${LANG_FILE}':" /etc/gdl.conf
    else
      log_error "Language file '${LANG_FILE}' not found"
      log "Exiting installer (errors logged: ${ERRORS_LOGGED})"
      echo -e "${BOLD_RED}ERROR:${COLOR_RESET} No file found for '${language}'"
      exit "${ERRORS_LOGGED}"
    fi
  fi
  log "Installer language set: ${language}"
}

################################################################################
# Present the keymap menu.
#
# Globals: KEYMAP, SET_KEYMAP_TITLE, SET_KEYMAP_MSG, etc.
# Arguments: None
################################################################################
set_keymap() {
  TITLE="${SET_KEYMAP_TITLE}"
  local keymap_list
  keymap_list="$(find /usr/share/kbd/keymaps -type f | sed -n -e 's!^.*/!!p' |
    grep '.map.gz' | sed 's/.map.gz//g' | sed 's/$/ ->/g' | sort)"

  while true; do
    if KEYMAP="$(dialog --no-cancel --ok-button "${OK}" --menu \
        "\n${SET_KEYMAP_MSG}" 18 60 10 \
        'us' 'United States' \
        'uk' 'United Kingdom' \
        'sv' 'Swedish' \
        'slovene' 'Slovenian' \
        'ru' 'Russian' \
        'ro' 'Romanian' \
        'pt-latin9' 'Portugal' \
        'it' 'Italian' \
        'hu' 'Hungarian' \
        'fr' 'French' \
        'es' 'Spanish' \
        'el' 'Greek' \
        'de' 'German' \
        "${OTHER}" '->')"; then
      if [[ "${KEYMAP}" != "${OTHER}" ]] ||
          KEYMAP="$(dialog --ok-button "${OK}" --cancel-button "${BACK}" \
          --menu "\n${SET_KEYMAP_MSG}" 19 60 10 ${keymap_list})"; then
        break
      fi
    fi
  done
  localectl set-keymap "${KEYMAP}"
  loadkeys "${KEYMAP}"
  log "Keymap set: ${KEYMAP}"
}

################################################################################
# Check for an internet connection, connect to Wi-Fi if necessary, then update
# the system clock.
#
# Globals: WIFI_SSID, WIFI_PASSWORD
# Arguments: None
################################################################################
check_internet_connection() {
  until nc -zw 1 1.1.1.1 443; do
    log "Internet connection not yet established..."
    if ip address | grep -Eq 'wlp|wlo|wlan' && [[ -n "${WIFI_SSID}" ]] &&
        nmcli dev wifi connect "${WIFI_SSID}" password "${WIFI_PASSWORD}"; then
      log "* Using nmcli..."
    else
      log "* Using nmtui..."
      nmtui
    fi
  done
  log "Internet connection established"
}

################################################################################
# Present the locale menu.
#
# Globals: LOCALE, SET_LOCALE_TITLE, SET_LOCALE_MSG, etc.
# Arguments: None
################################################################################
set_locale() {
  TITLE="${SET_LOCALE_TITLE}"
  local locale_list
  locale_list="$(grep -E "^#?[a-z].*UTF-8" /etc/locale.gen | sed 's/#//' |
    awk '{print $1" ->"}')"

  while true; do
    if LOCALE="$(dialog --no-cancel --ok-button "${OK}" --menu \
        "\n${SET_LOCALE_MSG}" 18 60 10 \
        'bg_BG.UTF-8' 'Bulgarian (Bulgaria)' \
        'de_DE.UTF-8' 'German (Germany)' \
        'el_GR.UTF-8' 'Greek (Greece)' \
        'en_AU.UTF-8' 'English (Australia)' \
        'en_CA.UTF-8' 'English (Canada)' \
        'en_GB.UTF-8' 'English (UK)' \
        'en_US.UTF-8' 'English (US)' \
        'es_ES.UTF-8' 'Spanish (Spain)' \
        'es_MX.UTF-8' 'Spanish (Mexico)' \
        'fr_FR.UTF-8' 'French (France)' \
        'hu_HU.UTF-8' 'Hungarian (Hungary)' \
        'id_ID.UTF-8' 'Indonesian (Indonesia)' \
        'it_IT.UTF-8' 'Italian (Italy)' \
        'ja_JP.UTF-8' 'Japanese (Japan)' \
        'ko_KR.UTF-8' 'Korean (Korea)' \
        'lt_LT.UTF-8' 'Lithuanian (Lithuania)' \
        'lv_LV.UTF-8' 'Latvian (Latvia)' \
        'nl_NL.UTF-8' 'Dutch (Netherlands)' \
        'pl_PL.UTF-8' 'Polish (Poland)' \
        'pt_BR.UTF-8' 'Portuguese (Brazil)' \
        'pt_PT.UTF-8' 'Portuguese (Portugal)' \
        'ro_RO.UTF-8' 'Romanian (Romania)' \
        'ru_RU.UTF-8' 'Russian (Russia)' \
        'sv_SE.UTF-8' 'Swedish (Sweden)' \
        'zh_CN.UTF-8' 'Chinese (China)' \
        'zh_HK.UTF-8' 'Chinese (Hong Kong)' \
        'zh_SG.UTF-8' 'Chinese (Singapore)' \
        'zh_TW.UTF-8' 'Chinese (Taiwan)' \
        "${OTHER}" '->')"; then
      if [[ "${LOCALE}" != "${OTHER}" ]] ||
          LOCALE="$(dialog --ok-button "${OK}" --cancel-button "${BACK}" \
          --menu "\n${SET_LOCALE_MSG}" 19 60 10 ${locale_list})"; then
        break
      fi
    fi
  done
  log "Locale set: ${LOCALE}"
}

################################################################################
# Present the time zone menu.
#
# Globals: TIME_ZONE, SET_TIME_ZONE_TITLE, SET_TIME_ZONE_MSG, etc.
# Arguments: None
################################################################################
set_time_zone() {
  TITLE="${SET_TIME_ZONE_TITLE}"
  local zonelist sublist subzone subsubzone
  zonelist="$(find /usr/share/zoneinfo -maxdepth 1 | sed -n -e 's!^.*/!!p' |
    grep -Ev 'posix|posixrules|right|zoneinfo|.*tab|W-SU|WET|MST7MDT|CST6CDT' |
    sort | sed 's/$/ ->/g')"

  while true; do
    TIME_ZONE="$(dialog --no-cancel --ok-button "${OK}" --menu \
      "\n${SET_TIME_ZONE_MSG}" 18 60 10 ${zonelist})"
    if find /usr/share/zoneinfo -maxdepth 1 -type d | sed -n -e 's!^.*/!!p' |
        grep -q "${TIME_ZONE}"; then
      sublist="$(find /usr/share/zoneinfo/"${TIME_ZONE}" -maxdepth 1 |
        sed -n -e 's!^.*/!!p' | sort | sed 's/$/ ->/g' |
        grep -v "${TIME_ZONE}")"
      if subzone="$(dialog --ok-button "${OK}" --cancel-button "${BACK}" \
          --menu "\n${SET_TIME_SUBZONE_MSG}" 18 60 10 ${sublist})"; then
        if find /usr/share/zoneinfo/"${TIME_ZONE}" -maxdepth 1 -type d |
            sed -n -e 's!^.*/!!p' | grep -q "${subzone}"; then
          sublist="$(find /usr/share/zoneinfo/"${TIME_ZONE}/${subzone}" \
            -maxdepth 1 | sed -n -e 's!^.*/!!p' | sort | sed 's/$/ ->/g' |
            grep -v "${subzone}")"
          if subsubzone="$(dialog --ok-button "${OK}" --cancel-button "${BACK}"\
              --menu "\n${SET_TIME_SUBZONE_MSG}" 15 60 7 ${sublist})"; then
            TIME_ZONE="${TIME_ZONE}/${subzone}/${subsubzone}"
            break
          fi
        else
          TIME_ZONE="${TIME_ZONE}/${subzone}"
          break
        fi
      fi
    else
      break
    fi
  done
  log "Time zone set: ${TIME_ZONE}"
}

################################################################################
# Present partitioning options and facilitate preparing a drive (or drives) for
# Linux installation.
#
# Globals: DRIVE, FS, GPT, UEFI, ROOT, BOOT_OR_ESP, SWAP_SIZE, etc.
# Arguments: None
################################################################################
prepare_drives() {
  TITLE="${PREPARE_DRIVES_TITLE}"
  local partition_method partition_prefix drive_bytes drive_mib drive_gib \
    drive_menu_header='               Device    Size    Type'

  log "Initial partition layout:"
  log_lsblk

  until "${SYSTEM_MOUNTED}"; do
    unmount_and_close_everything --swapoff

    # Present partitioning options
    if ! partition_method="$(dialog --no-cancel --ok-button "${OK}" --menu \
        "\n${PART_METHOD_MSG}" 16 70 3 \
        "${PART_METHOD_AUTO}" '->' \
        "${PART_METHOD_AUTO_ENCRYPT}" '->' \
        "${PART_METHOD_MANUAL}" '->')"; then
      continue

    # If an auto-partitioning option is selected, prepare the drive menu
    elif [[ "${partition_method}" != "${PART_METHOD_MANUAL}" ]]; then
      if [[ "${partition_method}" == "${PART_METHOD_AUTO}" ]]; then
        log "Auto-partitioning..."
      elif [[ "${partition_method}" == "${PART_METHOD_AUTO_ENCRYPT}" ]]; then
        log "Auto-partitioning with encrypted LVM..."
      fi
      # shellcheck disable=SC2028
      if "${REDUCE_EXTRANEOUS_TEXT}"; then
        echo "dialog --stdout --colors --title \" ${TITLE} \" --ok-button \
\"${OK}\" --cancel-button \"${CANCEL}\" --menu \"\n${SELECT_DRIVE_MSG}\n\n\
${drive_menu_header}\" 16 60 5 \\" >/tmp/gdl/part.sh
      else
        echo "dialog --stdout --colors --backtitle \"${BACKTITLE}\" --title \" \
${TITLE} \" --ok-button \"${OK}\" --cancel-button \"${CANCEL}\" --menu \"\n\
${SELECT_DRIVE_MSG}\n\n${drive_menu_header}\" 16 60 5 \\" >/tmp/gdl/part.sh
      fi
      lsblk -nio NAME,SIZE,TYPE | grep -E "disk|raid[0-9]+$" |
        sed 's/[^[:alnum:]_., ]//g' | column -t | sort -k 1,1 | uniq |
        awk '{print "\""$1"\"""  ""\"| "$2" | "$3"     \""" \\"}' |
        column -t >>/tmp/gdl/part.sh

      # Present the drive and filesystem menus
      DRIVE="$(bash /tmp/gdl/part.sh)" || continue
      log "* Drive selection: ${DRIVE}"
      FS="$(get_filesystem)" || continue
      log "* Root filesystem selection: ${FS}"

      # Check the selected drive's properties
      if grep -Eq 'nvme|mmc|md' <<<"${DRIVE}"; then
        partition_prefix='p'
      else
        partition_prefix=''
      fi
      drive_bytes="$(lsblk -nibo NAME,SIZE | grep -w "${DRIVE}" |
        awk '{print $2}')"
      drive_mib=$(( drive_bytes / 1024 / 1024 ))
      # shellcheck disable=SC2034
      drive_gib=$(( drive_mib / 1024 )) # used in FORMAT_DRIVE_CONFIRM
      log "* Drive size: ${drive_mib} MiB"
      BOOT_OR_ESP_MNT='/boot'
      BOOT_OR_ESP_SIZE="${DEFAULT_BOOT_SIZE}"
      if efivar -l &>/dev/null && yesno "${UEFI_MSG}" "${YES}" "${NO}"; then
        GPT='true'
        UEFI='true'
        BOOT_OR_ESP_MNT='/efi'
        if (( $(cat /sys/class/block/"${DRIVE}"/queue/logical_block_size) <=
              512 )); then
          BOOT_OR_ESP_SIZE="${DEFAULT_ESP_SIZE}"
        else
          BOOT_OR_ESP_SIZE="${DEFAULT_LARGE_ESP_SIZE}"
        fi
        log "* UEFI/GPT setup activated (${BOOT_OR_ESP_SIZE} MiB ESP)"
      else
        if yesno "${GPT_MSG}" "${YES}" "${NO}" --defaultno; then
          GPT='true'
          log "* BIOS/GPT setup activated (${BOOT_OR_ESP_SIZE} MiB boot)"
        else
          log "* BIOS/MBR setup activated (${BOOT_OR_ESP_SIZE} MiB boot)"
        fi
      fi
      (( ++BOOT_OR_ESP_SIZE )) # add 1 MiB to avoid "259" in lsblk, etc.

      # Set swap size
      SWAP_SIZE=''
      if yesno "${CREATE_SWAP_MSG}" "${YES}" "${NO}" --defaultno; then
        while true; do
          SWAP_SIZE="$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
            --inputbox "\n${SET_SWAP_SIZE_MSG}" 11 55 '512M' | tr 'mg' 'MG' |
            tr -s 'MG' | tr -d 'a-zA-FH-LN-Z[:space:]')" || break
          if grep -q 'M$' <<<"${SWAP_SIZE}"; then
            SWAP_SIZE="$(sed 's/M//;s/\..*//' <<<"${SWAP_SIZE}")"
          elif grep -q 'G$' <<<"${SWAP_SIZE}"; then
            SWAP_SIZE="$(echo "${SWAP_SIZE/G} * 1024" | bc | sed 's/\..*//')"
          else
            log_error "Invalid swap size input: ${SWAP_SIZE}"
            message "${SWAP_INPUT_ERROR_MSG}"
            continue
          fi
          break
        done
      fi
      [[ -z "${SWAP_SIZE}" ]] && SWAP_SIZE='0'
      log "* Swap size: ${SWAP_SIZE} MiB"

      # Format the selected drive (or go back to the main partitioning menu)
      if yesno "$(eval echo \"${FORMAT_DRIVE_CONFIRM}\")" "${WRITE_CHANGES}" \
          "${CANCEL}" --defaultno; then
        (
          sgdisk --zap-all /dev/"${DRIVE}"
          wipefs -a /dev/"${DRIVE}"
        ) &>/dev/null &
        load_bar "${WIPEFS_LOAD_MSG}\n\n \Z1> \Z2wipefs -a /dev/${DRIVE}\Zn"
        log "* Device wiped: /dev/${DRIVE}"
      else
        continue
      fi
    fi

    # Go to the appropriate sub-function
    case "${partition_method}" in
      "${PART_METHOD_AUTO}")
        if ! auto_partition; then
          log_error "Auto-partitioning failed"
          message "${PART_ERROR_MSG}"
        fi
        ;;
      "${PART_METHOD_AUTO_ENCRYPT}")
        if ! auto_partition_with_encryption; then
          log_error "Auto-partitioning with encrypted LVM failed"
          message "${PART_ERROR_MSG}"
        fi
        ;;
      "${PART_METHOD_MANUAL}")
        log "Manually partitioning..."
        manually_partition
        ;;
    esac
  done
  log "Final partition layout:"
  log_lsblk
}

################################################################################
# Auto-partition the drive selected in 'prepare_drives'. Include a separate
# /efi or /boot partition for UEFI and BIOS systems respectively (plus a 1 MiB
# BIOS boot partition for BIOS/GPT systems) along with a swap partition if a
# non-zero swap size is set.
#
# Globals: DRIVE, FS, GPT, UEFI, ROOT, BOOT_OR_ESP_MNT, BOOT_OR_ESP_SIZE,
#   SYSTEM_MOUNTED, etc. (also uses 'partition_prefix' from 'prepare_drives')
# Arguments: None (the target drive should already be stored in DRIVE)
# Outputs: Number of errors detected.
################################################################################
auto_partition() {
  TITLE="${AUTO_PART_TITLE}"

  # Create partitions
  log "* Setting up partitions..."
  if "${GPT}"; then
    if "${UEFI}"; then # UEFI/GPT
      if (( SWAP_SIZE > 0 )); then
        echo -e "n\n\n\n${BOOT_OR_ESP_SIZE}M\nef00\nn\n3\n\n+${SWAP_SIZE}M\n\
8200\nn\n\n\n\n\nw\ny" | gdisk /dev/"${DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
        format_swap_partition "${DRIVE}${partition_prefix}3"
      else # no swap
        echo -e "n\n\n\n${BOOT_OR_ESP_SIZE}M\nef00\nn\n\n\n\n\nw\ny" |
          gdisk /dev/"${DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
      fi
      BOOT_OR_ESP="${DRIVE}${partition_prefix}1"
      ROOT="${DRIVE}${partition_prefix}2"
      log "  - EFI system partition (ESP) created: ${BOOT_OR_ESP}"
    else # BIOS/GPT
      if (( SWAP_SIZE > 0 )); then
        echo -e "o\ny\nn\n1\n\n+${BOOT_OR_ESP_SIZE}M\n\nn\n2\n\n+1M\nef02\nn\n4
\n+${SWAP_SIZE}M\n8200\nn\n3\n\n\n\nw\ny" | gdisk /dev/"${DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
        format_swap_partition "${DRIVE}${partition_prefix}4"
      else # no swap
        echo -e "o\ny\nn\n1\n\n+${BOOT_OR_ESP_SIZE}M\n\nn\n2\n\n+1M\nef02\nn\n3\
\n\n\n\nw\ny" | gdisk /dev/"${DRIVE}" &>/dev/null &
        load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
      fi
      BOOT_OR_ESP="${DRIVE}${partition_prefix}1"
      ROOT="${DRIVE}${partition_prefix}3"
      log "  - BIOS boot partition created: ${DRIVE}${partition_prefix}2"
    fi
  else # BIOS/MBR
    if (( SWAP_SIZE > 0 )); then
      echo -e "o\nn\np\n1\n\n+${BOOT_OR_ESP_SIZE}M\nn\np\n3\n\n+${SWAP_SIZE}M\n\
t\n\n82\nn\np\n2\n\n\nw" | fdisk /dev/"${DRIVE}" &>/dev/null &
      load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2fdisk \
/dev/${DRIVE}\Zn"
      format_swap_partition "${DRIVE}${partition_prefix}3"
    else # no swap
      echo -e "o\nn\np\n1\n\n+${BOOT_OR_ESP_SIZE}M\nn\np\n2\n\n\nw" |
        fdisk /dev/"${DRIVE}" &>/dev/null &
      load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2fdisk \
/dev/${DRIVE}\Zn"
    fi
    BOOT_OR_ESP="${DRIVE}${partition_prefix}1"
    ROOT="${DRIVE}${partition_prefix}2"
  fi
  "${UEFI}" || log "  - Boot partition created: ${BOOT_OR_ESP}"
  log "  - Root partition created: ${ROOT}"

  # Format partitions
  if "${UEFI}"; then
    (
      sgdisk --zap-all /dev/"${BOOT_OR_ESP}"
      wipefs -a /dev/"${BOOT_OR_ESP}"
      mkfs.vfat -F32 /dev/"${BOOT_OR_ESP}"
    ) &>/dev/null &
    load_bar "${EFI_LOAD_MSG}\n\n \Z1> \Z2mkfs.vfat -F32 /dev/${BOOT_OR_ESP}\Zn"
    log "  - ESP filesystem created: vfat (FAT32)"
  else # BIOS
    (
      sgdisk --zap-all /dev/"${BOOT_OR_ESP}"
      wipefs -a /dev/"${BOOT_OR_ESP}"
      # shellcheck disable=SC1001
      mkfs.ext4 -O \^64bit /dev/"${BOOT_OR_ESP}"
    ) &>/dev/null &
    load_bar "${BOOT_LOAD_MSG}\n\n \Z1> \Z2mkfs.ext4 /dev/${BOOT_OR_ESP}\Zn"
    log "  - Boot filesystem created: ext4"
  fi
  (
    sgdisk --zap-all /dev/"${ROOT}"
    wipefs -a /dev/"${ROOT}"
    mkfs."${FS}" /dev/"${ROOT}"
  ) &>/dev/null &
  load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${FS} \
/dev/${ROOT}\Zn"
  log "  - Root filesystem created: ${FS}"

  # Mount partitions
  if [[ "${FS}" == 'btrfs' ]]; then
    create_and_mount_btrfs_subvolume '@' "/dev/${ROOT}" || return 1
    create_and_mount_btrfs_subvolume '@home' "/dev/${ROOT}" || return 1
    create_and_mount_btrfs_subvolume '@var@log' "/dev/${ROOT}" || return 1
    create_and_mount_btrfs_subvolume '@var@cache' "/dev/${ROOT}" || return 1
    BTRFS_ROOT='true'
  elif mount /dev/"${ROOT}" /mnt &>/dev/null; then
    log "  - Mounted /dev/${ROOT} at /mnt"
  else
    log_error "Mounting /dev/${ROOT} at /mnt failed"
    return 1
  fi
  if mkdir /mnt"${BOOT_OR_ESP_MNT}" &&
      mount /dev/"${BOOT_OR_ESP}" /mnt"${BOOT_OR_ESP_MNT}" &>/dev/null; then
    log "  - Mounted /dev/${BOOT_OR_ESP} at /mnt${BOOT_OR_ESP_MNT}"
    SYSTEM_MOUNTED='true'
  else
    log_error "Mounting /dev/${BOOT_OR_ESP} at /mnt${BOOT_OR_ESP_MNT} failed"
    return 1
  fi
  log "Auto-partitioning complete"
}

################################################################################
# Auto-partition the drive selected in 'prepare_drives', set up LVM, and encrypt
# the root logical volume. Encryption of a /tmp logical volume (and an optional
# logical swap space) is handled later via 'crypttab' (see 'configure_system').
# A separate /efi or /boot partition (unencrypted) is created for UEFI and BIOS
# systems respectively (plus a 1 MiB BIOS boot partition for BIOS/GPT systems).
#
# Globals: DRIVE, FS, GPT, UEFI, ROOT, BOOT_OR_ESP_MNT, BOOT_OR_ESP_SIZE,
#   SYSTEM_AUTO_ENCRYPTED, etc. (plus 'partition_prefix' from 'prepare_drives')
# Arguments: None (the target drive should already be stored in DRIVE)
# Outputs: Number of errors detected.
################################################################################
auto_partition_with_encryption() {
  TITLE="${AUTO_PART_TITLE}"
  local input input_check

  # Set encryption password
  if yesno "$(eval echo \"${ENCRYPTION_CONFIRM}\")" "${YES}" "${NO}" \
      --defaultno; then
    while true; do
      if ! input="$(dialog --no-cancel --clear --insecure --passwordbox \
          "\n$(eval echo \"${ENCRYPTION_PASSWORD_MSG}\")" 12 55)" ||
          ! input_check="$(dialog --no-cancel --clear --insecure --passwordbox \
          "\n$(eval echo \"${ENCRYPTION_PASSWORD_CONFIRM}\")" 12 55)" ||
          [[ -z "${input}" ]]; then
        message "${PASSWORD_EMPTY_MSG}"
      elif [[ "${input}" != "${input_check}" ]]; then
        message "${PASSWORD_MISMATCH_MSG}"
      else
        break
      fi
    done
    log "* Encryption password set"
  else
    return 0 # back to 'prepare_drives'
  fi

  # Set up physical partitions
  if "${GPT}"; then
    if "${UEFI}"; then # UEFI/GPT
      echo -e "n\n\n\n${BOOT_OR_ESP_SIZE}M\nef00\nn\n\n\n\n\nw\ny" |
        gdisk /dev/"${DRIVE}" &>/dev/null &
      load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
      BOOT_OR_ESP="${DRIVE}${partition_prefix}1"
      ROOT="${DRIVE}${partition_prefix}2"
      log "* EFI system partition (ESP) created: ${BOOT_OR_ESP}"
    else # BIOS/GPT
      echo -e "o\ny\nn\n1\n\n+${BOOT_OR_ESP_SIZE}M\n\nn\n2\n\n+1M\nef02\nn\n3\n\
\n\n\nw\ny" | gdisk /dev/"${DRIVE}" &>/dev/null &
      load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2gdisk \
/dev/${DRIVE}\Zn"
      BOOT_OR_ESP="${DRIVE}${partition_prefix}1"
      ROOT="${DRIVE}${partition_prefix}3"
      log "* BIOS boot partition created: ${DRIVE}${partition_prefix}2"
    fi
  else # BIOS/MBR
    echo -e "o\nn\np\n1\n\n+${BOOT_OR_ESP_SIZE}M\nn\np\n2\n\n\nw" |
      fdisk /dev/"${DRIVE}" &>/dev/null &
    load_bar "$(eval echo \"${PART_LOAD_MSG}\")\n\n \Z1> \Z2fdisk \
/dev/${DRIVE}\Zn"
    BOOT_OR_ESP="${DRIVE}${partition_prefix}1"
    ROOT="${DRIVE}${partition_prefix}2"
  fi
  "${UEFI}" || log "* Boot partition created: ${BOOT_OR_ESP}"

  # Create physical volume and volume group 'lvm' on root partition
  (
    sgdisk --zap-all /dev/"${ROOT}"
    sgdisk --zap-all /dev/"${BOOT_OR_ESP}"
    wipefs -a /dev/"${ROOT}"
    wipefs -a /dev/"${BOOT_OR_ESP}"
  ) &>/dev/null &
  load_bar "${WIPEFS_LOAD_MSG}\n\n \Z1> \Z2wipefs -a /dev/${ROOT}\Zn"
  (
    lvm pvcreate /dev/"${ROOT}"
    lvm vgcreate lvm /dev/"${ROOT}"
  ) &>/dev/null &
  load_bar "${PVCREATE_LOAD_MSG}\n\n \Z1> \Z2lvm pvcreate /dev/${ROOT}\Zn"
  log "* Root partition and physical volume created: ${ROOT}"
  log "* Logical volume group created: lvm"

  # Set up logical volumes and encrypt the root volume
  if (( SWAP_SIZE > 0 )); then
    lvm lvcreate -L "${SWAP_SIZE}M" -n swap lvm &>/dev/null &
    load_bar "${SWAP_LOAD_MSG}\n\n \Z1> \Z2lvm lvcreate -L ${SWAP_SIZE}M -n \
swap lvm\Zn"
    log "* Logical swap space created"
  fi
  (
    lvm lvcreate -L 500M -n tmp lvm
    lvm lvcreate -l 100%FREE -n lvroot lvm
  ) &>/dev/null &
  load_bar "${LVCREATE_LOAD_MSG}\n\n \Z1> \Z2lvm lvcreate -l 100%FREE -n \
lvroot lvm\Zn"
  log "* Logical temp volume created: tmp"
  (
    printf "%s" "${input}" | cryptsetup luksFormat /dev/lvm/lvroot -
    printf "%s" "${input}" | cryptsetup open /dev/lvm/lvroot root -
  ) &>/dev/null &
  load_bar "${ENCRYPTION_LOAD_MSG}\n\n \Z1> \Z2cryptsetup luksFormat \
/dev/lvm/lvroot\Zn"
  unset input input_check
  log "* Logical root volume created and encrypted: lvroot"

  # Apply file systems to ESP/boot and root
  if "${UEFI}"; then
    mkfs.vfat -F32 /dev/"${BOOT_OR_ESP}" &>/dev/null &
    load_bar "${EFI_LOAD_MSG}\n\n \Z1> \Z2mkfs.vfat -F32 /dev/${BOOT_OR_ESP}\Zn"
    log "* ESP filesystem created: vfat (FAT32)"
  else # BIOS
    # shellcheck disable=SC1001
    mkfs.ext4 -O \^64bit /dev/"${BOOT_OR_ESP}" &>/dev/null &
    load_bar "${BOOT_LOAD_MSG}\n\n \Z1> \Z2mkfs.ext4 /dev/${BOOT_OR_ESP}\Zn"
    log "* Boot filesystem created: ext4"
  fi
  (
    wipefs -a /dev/mapper/root
    mkfs."${FS}" /dev/mapper/root
  ) &>/dev/null &
  load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${FS} \
/dev/mapper/root\Zn"
  log "* Root filesystem created: ${FS}"

  # Mount partitions/volumes
  if [[ "${FS}" == 'btrfs' ]]; then
    create_and_mount_btrfs_subvolume '@' '/dev/mapper/root' || return 1
    create_and_mount_btrfs_subvolume '@home' '/dev/mapper/root' || return 1
    create_and_mount_btrfs_subvolume '@var@log' '/dev/mapper/root' || return 1
    create_and_mount_btrfs_subvolume '@var@cache' '/dev/mapper/root' || return 1
    BTRFS_ROOT='true'
  elif mount /dev/mapper/root /mnt &>/dev/null; then
    log "* Mounted /dev/mapper/root at /mnt"
  else
    log_error "Mounting /dev/mapper/root at /mnt failed"
    return 1
  fi
  if mkdir /mnt"${BOOT_OR_ESP_MNT}" &&
      mount /dev/"${BOOT_OR_ESP}" /mnt"${BOOT_OR_ESP_MNT}" &>/dev/null; then
    log "* Mounted /dev/${BOOT_OR_ESP} at /mnt${BOOT_OR_ESP_MNT}"
    SYSTEM_MOUNTED='true'
    SYSTEM_AUTO_ENCRYPTED='true'
  else
    log_error "Mounting /dev/${BOOT_OR_ESP} at /mnt${BOOT_OR_ESP_MNT} failed"
    return 1
  fi
  log "Auto-partitioning with encrypted LVM complete"
}

################################################################################
# Present options for manual partitioning of available drives.
#
# Globals: DRIVE, FS, GPT, UEFI, ROOT, BOOT_OR_ESP_MNT, SYSTEM_MOUNTED, etc.
# Arguments: None
# Outputs: Number of errors detected.
################################################################################
manually_partition() {
  local -i counter device_count
  local device dev_list dev_size dev_type dev_fs dev_mnt dev_used dev_parent \
    dev_menu_header='       Device    Size    Used    FS    Mount    Type' \
    part part_size part_type part_fs part_mount part_final empty_value='----' \
    lvm_pv

  while true; do
    # Prepare the manual partitioning menu via temp files part.sh/part.list
    TITLE="${MANUAL_PART_TITLE}"
    dev_list="$(lsblk -no NAME,SIZE,TYPE,FSTYPE | grep -Ev "$(lsblk |
      grep ' /run' | grep -o sd. | tr '\n' '|')loop[0-9]+|sr[0-9]+|fd[0-9]+" |
      sed 's/[^[:alnum:]_., -]//g' | column -t | sort -k 1,1 | uniq)"
    device_count="$(wc -l <<<"${dev_list}")"
    if "${REDUCE_EXTRANEOUS_TEXT}"; then
      # shellcheck disable=SC2028
      echo "dialog --stdout --colors --title \" ${TITLE} \" --ok-button \
\"${EDIT}\" --cancel-button \"${CANCEL}\" --menu \"\n${MANUAL_PART_MSG}\n
${dev_menu_header}\" 20 68 8 \\" >/tmp/gdl/part.sh
    else
      # shellcheck disable=SC2028
      echo "dialog --stdout --colors --backtitle \"${BACKTITLE}\" --title \
\" ${TITLE} \" --ok-button \"${EDIT}\" --cancel-button \"${CANCEL}\" --menu \
\"\n${MANUAL_PART_MSG}\n\n${dev_menu_header}\" 21 68 9 \\" >/tmp/gdl/part.sh
    fi
    [[ -f /tmp/gdl/part.list ]] && rm /tmp/gdl/part.list
    counter=1
    until (( counter > device_count )); do
      device="$(awk <<<"${dev_list}" '{print $1}' | awk "NR==${counter}")"
      dev_size="$(grep -w "${device}" <<<"${dev_list}" | awk '{print $2}')"
      dev_type="$(grep -w "${device}" <<<"${dev_list}" | awk '{print $3}')"
      dev_fs="$(grep -w "${device}" <<<"${dev_list}" | awk '{print $4}')"
      dev_mnt="$(df | grep -w "${device}" | awk '{print $6}' |
        sed 's/mnt\/\?//')"
      if grep -q '/' <<<"${dev_mnt}"; then
        dev_used="$(df -T | grep -w "${device}" | awk '{print $6}')"
      else
        dev_used=$(swapon -s | grep -w "${device}" | awk '{print $4}')
        if [[ -n "${dev_used}" ]]; then
          dev_used="${dev_used}%"
        fi
      fi
      [[ -z "${dev_fs}" || "${dev_fs}" == "linux_raid_member" ]] &&
        dev_fs="${empty_value}"
      [[ -z "${dev_used}" ]] && dev_used="${empty_value}"
      [[ -z "${dev_mnt}" ]] && dev_mnt="${empty_value}"
      dev_parent="$(lsblk -dnro PKNAME /dev/"${device/-//}")"
      if [[ -z "${dev_parent}" ]]; then
        dev_type="$(grep -w "${device}" <<<"${dev_list}" | awk '{print $3}')"
      else
        dev_type="$(fdisk -lo Device,Type /dev/"${dev_parent}" |
          grep -w "${device}" | cut -d ' ' -f 2- |
          sed -e 's/^[[:space:]]*//;s/[[:space:]]*$//;s/ /_/g')"
      fi
      echo "\"${device}\" \"${dev_size} ${dev_used} ${dev_fs} ${dev_mnt} \
${dev_type}\" \\" >>/tmp/gdl/part.list
      (( ++counter ))
    done
    column </tmp/gdl/part.list -t >>/tmp/gdl/part.sh
    echo -e "\"${DONE}\" \"${WRITE_CHANGES}\"" >>/tmp/gdl/part.sh

    # Present the manual partitioning menu and get user input
    if ! part="$(bash /tmp/gdl/part.sh | sed 's/^\s\+//g;s/\s\+$//g')" ||
        [[ -z "${part}" ]]; then
      SYSTEM_MOUNTED='false'
      return 0 # back to 'prepare_drives'
    fi
    log "* Menu selection: '${part}'"

    # If user selected 'done', attempt to finish the partitioning process
    if [[ "${part}" == "${DONE}" ]]; then
      if ! "${SYSTEM_MOUNTED}"; then
        log_error "Root partition not found"
        message "${ROOT_UNMOUNTED_ERROR_MSG}"
        continue
      elif "${GPT}" && ! "${UEFI}" && ! fdisk -l | grep -q 'BIOS boot'; then
        log_error "BIOS boot partition not found"
        message "${GPT_BIOS_ERROR_MSG}"
        continue
      fi
      part_final="$( (df -h | grep '/mnt' | awk '{print $1,$2,$6 "\\n"}' |
        sed 's/mnt\/\?//'; swapon | awk 'NR==2 {print $1,$3,"SWAP"}') |
        column -t)"
      yesno "${WRITE_CONFIRM}\n\n${PARTITION}  ${SIZE}  ${MOUNT_POINT}\n\n\
${part_final}" "${OK}" "${CANCEL}" --defaultno || continue

      # Add home/var subvolumes for btrfs systems (if mount points are free)
      if mount | grep -q ' /mnt type btrfs'; then
        mount | grep -q ' /mnt/home ' ||
          create_and_mount_btrfs_subvolume '@home' "/dev/${ROOT}"
        if ! mount | grep -q ' /mnt/var '; then
          mount | grep -q ' /mnt/var/log ' ||
            create_and_mount_btrfs_subvolume '@var@log' "/dev/${ROOT}"
          mount | grep -q ' /mnt/var/cache ' ||
            create_and_mount_btrfs_subvolume '@var@cache' "/dev/${ROOT}"
        fi
        BTRFS_ROOT='true'
      fi

      log "Manual partitioning complete"
      return 0 # all done: return to 'prepare_drives'
    fi

    # If not 'done', prepare and present a disk/partition editing menu
    part_size="$(grep -w "${part}" <<<"${dev_list}" | awk '{print $2}')"
    part_type="$(grep -w "${part}" <<<"${dev_list}" | awk '{print $3}')"
    part_fs="$(grep -w "${part}" <<<"${dev_list}" | awk '{print $4}')"
    part_mount="$(df | grep -w "${part}" | awk '{print $6}' |
      sed 's/mnt\/\?//')"
    [[ "${part_type}" == 'lvm' ]] && part="${part/-//}"
    log "  - Device info: ${part_type} ${part_fs} ${part_size} ${part_mount}"
    [[ "${part_fs}" == 'linux_raid_member' ]] && continue # do nothing

    # If user selected an entire drive, facilitate partitioning
    if [[ "${part_type}" == "disk" ]] ||
        (grep -Eq 'raid[0-9]+' <<<"${part_type}" && [[ -z "${part_fs}" ]]); then
      if mount | grep -q "${part}.*on /mnt"; then
        if yesno "$(eval echo \"${UNMOUNT_DRIVE_CONFIRM}\")" "${EDIT}" \
            "${CANCEL}" --defaultno; then
          unmount_and_close_everything --swapoff
          modify_partition_table /dev/"${part}"
        fi
      elif yesno "$(eval echo \"${EDIT_DRIVE_CONFIRM}\")" "${EDIT}" \
          "${CANCEL}"; then
        modify_partition_table /dev/"${part}"
      fi

    # If user selected a partition or md device, facilitate mounting/formatting
    else
      TITLE="${EDIT_PART_TITLE}"
      # The root '/' mount point must be established before others
      if [[ -z "${ROOT}" ]]; then
        # shellcheck disable=SC2015
        yesno "$(eval echo \"${ROOT_MNT_CONFIRM}\")" "${YES}" "${NO}" \
          --defaultno && FS="$(get_filesystem)" &&
          yesno "$(eval echo \"${ROOT_FORMAT_CONFIRM}\")" "${WRITE_CHANGES}" \
          "${CANCEL}" --defaultno || continue
        (
          sgdisk --zap-all /dev/"${part}"
          wipefs -a /dev/"${part}"
          mkfs."${FS}" /dev/"${part}"
        ) &>/dev/null &
        load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${FS} \
/dev/${part}\Zn"
        log "  - Root filesystem created for /dev/${part}: ${FS}"
        if [[ "${FS}" == 'btrfs' ]]; then
          if ! create_and_mount_btrfs_subvolume '@' "/dev/${part}"; then
            message "${ROOT_MOUNT_ERROR_MSG}"
            return 1 # back to 'prepare_drives'
          fi
        elif mount /dev/"${part}" /mnt &>/dev/null; then
          log "  - Mounted /dev/${part} at /mnt"
        else
          log_error "Mounting /dev/${part} at /mnt failed"
          message "${ROOT_MOUNT_ERROR_MSG}"
          return 1 # back to 'prepare_drives'
        fi
        SYSTEM_MOUNTED='true'
        ROOT="${part}"
        if [[ "${part_type}" == "lvm" ]]; then
          lvm_pv="$(lvdisplay -m | grep -A 20 /dev/"${part}" |
            grep 'Physical volume' | sed 's/^\s\+//g;s/\s\+/ /g' |
            cut -d ' ' -f 3)"
          DRIVE="$(lsblk -dnro PKNAME "${lvm_pv}")"
        else
          DRIVE="$(lsblk -dnro PKNAME /dev/"${part}")"
        fi
        log "  - Root drive: ${DRIVE}"
        if parted /dev/"${DRIVE}" print | grep -q 'Table: gpt'; then
          GPT='true'
        else
          GPT='false'
        fi
        log "  - GPT: ${GPT}"
      # If the partition's already mounted, provide option to unmount
      elif [[ -n "${part_mount}" ]]; then
        if yesno "$(eval echo \"${ALREADY_MOUNTED_MSG}\")" "${EDIT}" "${BACK}" \
            --defaultno; then
          if [[ "${part}" == "${ROOT}" ]]; then
            if yesno "$(eval echo \"${UNMOUNT_ROOT_CONFIRM}\")" "${YES}" \
                "${NO}" --defaultno; then
              unmount_and_close_everything
            fi
          elif yesno "$(eval echo \"${UNMOUNT_PART_CONFIRM}\")" "${YES}" \
              "${NO}" --defaultno; then
            if "${UEFI}" && [[ "${part_mount}" =~ efi|boot ]] &&
                mount | grep -q " /mnt${part_mount} type vfat "; then
              UEFI='false'
              BOOT_OR_ESP_MNT=''
              log "  - Unmounting ESP..."
            fi
            umount /mnt"${part_mount}" &>/dev/null &
            load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2umount /mnt${part_mount}\Zn"
            rm -r /mnt"${part_mount:?}"
            log "  - Unmounted /dev/${part} from /mnt${part_mount}"
          fi
        fi
      # If it's already in use as swap, provide option to 'swapoff' and wipe
      elif lsblk | grep -q "${part} .*\[SWAP\]$"; then
        if yesno "$(eval echo \"${SWAPOFF_CONFIRM}\")" "${YES}" "${NO}" \
            --defaultno; then
          (
            swapoff /dev/"${part}"
            wipefs -a /dev/"${part}"
            sleep 0.6
          ) &>/dev/null &
          load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2swapoff /dev/${part}\Zn"
          log "  - Swap partition /dev/${part} deactivated and wiped"
        fi
      # If it's a swap partition not in use, reformat and 'swapon'
      elif (( $(fdisk -l | grep -w "${part}" | sed 's/\*//' |
              awk '{print $6}') == 82 )) &>/dev/null ||
          (fdisk -l /dev/"$(lsblk -dnro PKNAME /dev/"${part}")" |
           grep -q 'gpt' && [[ "$(fdisk -l -o Device,Size,Type-UUID |
           grep -w "${part}" | awk '{print $3}')" == \
           "0657FD6D-A4AB-43C4-84E5-0933C84B4F4F" ]]) &>/dev/null; then
        format_swap_partition "${part}"
      # Otherwise, present mount point menu (inc. option to create swap)
      elif yesno "$(eval echo \"${MNT_CONFIRM}\")" "${EDIT}" "${BACK}"; then
        mnt="$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
          --menu "\n$(eval echo \"${SELECT_MNT_MSG}\")" 15 60 6 \
          '/home' '->' \
          '/boot' '->' \
          '/efi' '->' \
          '/opt' '->' \
          '/usr' '->' \
          '/var' '->' \
          '/tmp' '->' \
          '[SWAP]' '->' \
          "${CUSTOM}" '->')" || continue
        if [[ "${mnt}" == '[SWAP]' ]]; then
          format_swap_partition "${part}"
          continue
        elif [[ "${mnt}" == "${CUSTOM}" ]]; then
          while true; do
            mnt="$(dialog --ok-button "${OK}" --cancel-button "${CANCEL}" \
              --inputbox "\n${CUSTOM_MNT_MSG}" 10 50 '/' | tr -d '[:space:]' |
              tr -s '/')" || continue 2
            if grep -q "[\[\$\!\'\"\`\\|%&#@()+=<>~;:?.,^{}]\|]" \
                <<<"${mnt}"; then
              message "${CUSTOM_MNT_CHAR_ERROR_MSG}"
            elif [[ "${mnt}" == '/' ]]; then
              message "${CUSTOM_MNT_ROOT_ERROR_MSG}"
            elif [[ -n "${mnt}" ]]; then
              [[ "${mnt}" =~ ^/ ]] || mnt="/${mnt}"
              break
            fi
          done
        fi
        log "  - Mount point selection: ${mnt}"
        # Provide formatting options
        if yesno "${PART_FORMAT_MSG}" "${YES}" "${NO}" --defaultno; then
          if [[ "${mnt}" == '/efi' || "${mnt}" == '/boot/efi' ]] ||
              fdisk -l | grep "${part}" | grep -q 'EFI'; then
            FS="$(dialog --menu "\n${EFI_VFAT_MSG}" 12 65 1 'vfat' \
              "${FS_VFAT_MSG}")" || continue
          else
            FS="$(get_filesystem)" || continue
          fi
          yesno "$(eval echo \"${PART_FORMAT_CONFIRM}\")" "${WRITE_CHANGES}" \
            "${CANCEL}" --defaultno || continue
          (
            sgdisk --zap-all /dev/"${part}"
            wipefs -a /dev/"${part}"
            case "${FS}" in
              vfat) mkfs.vfat -F32 /dev/"${part}" ;;
              *) mkfs."${FS}" /dev/"${part}" ;;
            esac
          ) &>/dev/null &
          load_bar "$(eval echo \"${MKFS_LOAD_MSG}\")\n\n \Z1> \Z2mkfs.${FS} \
/dev/${part}\Zn"
          log "  - Filesystem created for ${mnt}: ${FS}"
        fi
        # Attempt to mount the partition at the given mount point
        if blkid | grep "${part}" | grep -q 'TYPE="btrfs"'; then
          create_and_mount_btrfs_subvolume "${mnt////@}" "/dev/${part}" ||
            message "${MOUNT_ERROR_MSG}"
        elif mkdir -p /mnt"${mnt}" &&
            mount /dev/"${part}" /mnt"${mnt}" &>/dev/null; then
          if [[ "${mnt}" =~ efi|boot ]] && efivar -l &>/dev/null &&
              mount | grep -q " /mnt${mnt} type vfat "; then
            UEFI='true'
            BOOT_OR_ESP_MNT="${mnt}"
            log "  - Mounting ESP..."
          fi
          log "  - Mounted /dev/${part} at /mnt${mnt}"
        else
          log_error "Mounting /dev/${part} at /mnt${mnt} failed"
          message "${MOUNT_ERROR_MSG}"
        fi
      fi
    fi
  done
}

################################################################################
# Present the filesystem menu and return its output.
#
# Globals: SELECT_FS_MSG, FS_EXT4_MSG, FS_BTRFS_MSG, FS_XFS_MSG
# Arguments: None
# Outputs: The selected filesystem (or nothing if the user hits Esc).
################################################################################
get_filesystem() {
  dialog --no-cancel --menu "\n${SELECT_FS_MSG}" 12 60 3 \
    'ext4' "${FS_EXT4_MSG}" \
    'btrfs' "${FS_BTRFS_MSG}" \
    'xfs' "${FS_XFS_MSG}"
}

################################################################################
# Let the user select a disk utility to modify a given disk's partition table.
#
# Globals: SELECT_DISK_UTIL_MSG, CFDISK_MSG, FDISK_MSG, GDISK_MSG
# Arguments: Full path of the disk to be modified.
# Outputs: Number of errors detected.
################################################################################
modify_partition_table() {
  local disk_util

  if [[ -z "$1" ]]; then
    log_error "No argument passed to 'modify_partition_table'"
    return 1
  elif disk_util="$(dialog --menu "\n${SELECT_DISK_UTIL_MSG}" 12 60 3 \
      'cfdisk' "${CFDISK_MSG}" \
      'fdisk' "${FDISK_MSG}" \
      'gdisk' "${GDISK_MSG}")"; then
    clear
    "${disk_util}" "$1"
    log "  - Disk $1 edited via ${disk_util}"
    clear
  fi
}

################################################################################
# Format a given partition to serve as a swap partition.
#
# Globals: SWAP_LOAD_MSG
# Arguments: A string indicating the target partition.
# Outputs: Number of errors detected.
################################################################################
format_swap_partition() {
  local partition="$1"

  if [[ -z "${partition}" ]]; then
    log_error "No argument passed to 'format_swap_partition'"
    return 1
  elif ! [[ "${partition}" =~ ^/dev/ ]]; then
    partition="$(echo "/dev/${partition}" | tr -s '/')"
  fi
  (
    wipefs -a "${partition}"
    mkswap "${partition}"
    swapon "${partition}"
    sleep 0.6
  ) &>/dev/null &
  load_bar "${SWAP_LOAD_MSG}\n\n \Z1> \Z2mkswap ${partition}\Zn"
  log "  - Swap partition formatted and activated: ${partition}"
}

################################################################################
# Attempt to create a new btrfs subvolume of a given name (which must follow the
# '@' = '/' schema) for a given btrfs device, then mount it based on its name
# (replacing '@' with '/').
#
# Globals: BTRFS_MOUNT_OPTIONS
# Arguments: New subvolume name (starting with '@') and full btrfs device path.
################################################################################
create_and_mount_btrfs_subvolume() {
  local subvolume btrfs_device mount_point
  local -i errors=0

  # Check and process arguments
  log "  - Creating Btrfs subvolume '$1' on $2..."
  if [[ -n "$1" ]]; then
    if [[ "$1" =~ ^@ ]]; then
      subvolume="$1"
      mount_point="/mnt${subvolume//@//}" # replace all '@' with '/'
      if mount | grep -q " ${mount_point} "; then
        log_error "Mount point '${mount_point}' already occupied"
        (( ++errors ))
      elif [[ -n "$2" ]]; then
        if [[ "$2" =~ ^/dev/ ]]; then
          btrfs_device="$2"
        else
          log_error "Device path '$2' seems to be invalid"
          (( ++errors ))
        fi
      else
        log_error "No device path provided for creating a Btrfs subvolume"
        (( ++errors ))
      fi
    else
      log_error "Btrfs subvolume name '$1' should start with '@'"
      (( ++errors ))
    fi
  else
    log_error "No arguments provided for creating a Btrfs subvolume"
    (( ++errors ))
  fi

  # If both arguments seem valid, attempt to create and mount a new subvolume
  if (( errors == 0 )); then
    if mkdir /btrfs-temp &&
        mount "${btrfs_device}" /btrfs-temp &>/dev/null; then
      if mount | grep '/btrfs-temp' | grep -q 'type btrfs'; then
        if btrfs subvolume create "/btrfs-temp/${subvolume}" &>/dev/null; then
          if mkdir -p "${mount_point}" &&
              mount -o "${BTRFS_MOUNT_OPTIONS},subvol=${subvolume}" \
              "${btrfs_device}" "${mount_point}" &>/dev/null; then
            log "  - Mounted '${subvolume}' at ${mount_point}"
          else
            log_error "Mounting '${subvolume}' at ${mount_point} failed"
            (( ++errors ))
          fi
        else
          log_error "Unable to create Btrfs subvolume '${subvolume}'"
          (( ++errors ))
        fi
      else
        log_error "No Btrfs partition found on '${btrfs_device}'"
        (( ++errors ))
      fi
    else
      log_error "Failed to mount '${btrfs_device}'"
      (( ++errors ))
    fi
    umount /btrfs-temp &>/dev/null
    rm -r /btrfs-temp &>/dev/null
  fi

  return $errors
}

################################################################################
# Unmount everything under /mnt, close all encrypted logical devices, and
# (optionally) turn off swap.
#
# Globals: SYSTEM_MOUNTED, SYSTEM_AUTO_ENCRYPTED, GPT, UEFI, BTRFS_ROOT, DRIVE,
#   ROOT, BOOT_OR_ESP, BOOT_OR_ESP_MNT
# Arguments: An optional '--swapoff' string if swap should be deactivated.
################################################################################
unmount_and_close_everything() {
  local -i attempts=0 max_attempts=3

  SYSTEM_MOUNTED='false'
  SYSTEM_AUTO_ENCRYPTED='false'
  GPT='false'
  UEFI='false'
  BTRFS_ROOT='false'
  DRIVE=''
  ROOT=''
  BOOT_OR_ESP=''
  BOOT_OR_ESP_MNT=''

  log "* Checking for devices to unmount/deactivate/close..."
  while [[ "$1" == '--swapoff' && -n $(swapon --show) ]] &&
        (( attempts < max_attempts )); do
    log "  - Deactivating swap..."
    swapoff -a &>/dev/null &
    load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2swapoff -a\Zn"
    (( ++attempts ))
  done
  attempts=0
  while lsblk | grep -q '/mnt' && (( attempts < max_attempts )); do
    log "  - Unmounting everything under /mnt..."
    umount -R /mnt &>/dev/null &
    load_bar "${WAIT_LOAD_MSG}\n\n \Z1> \Z2umount -R /mnt\Zn"
    (( ++attempts ))
  done
  attempts=0
  while [[ $(dmsetup ls) != 'No devices found' ]] &&
        (( attempts < max_attempts )); do
    for device in $(dmsetup ls | awk '{print $1}'); do
      close_encrypted_device "${device}"
      close_encrypted_device "lvm-${device}"
      close_encrypted_device "lvm-lv${device}"
    done
    (( ++attempts ))
  done
}

################################################################################
# Close a given encrypted logical volume/device.
#
# Globals: None
# Arguments: The name of the device to be closed.
################################################################################
close_encrypted_device() {
  [[ -n "$1" ]] && lsblk | grep -q "$1" && cryptsetup close "$1" &>/dev/null &&
    log "  - Encrypted device '$1' successfully closed"
}

################################################################################
# Prompt user for a hostname until a valid hostname is provided.
#
# Globals: HOSTNAME, SET_HOSTNAME_MSG, HOSTNAME_ERROR_MSG, etc.
# Arguments: None
################################################################################
set_hostname() {
  TITLE="${SET_HOSTNAME_TITLE}"
  while true; do
    if HOSTNAME="$(dialog --ok-button "${OK}" --no-cancel --inputbox \
        "\n${SET_HOSTNAME_MSG}" 12 55 "${HOSTNAME}" | tr -d '[:space:]')" &&
        [[ -n "${HOSTNAME}" ]]; then
      if grep -q "^[0-9]\|[\[\$\!\'\"\`\\|%&#@()+=<>~;:/?.,^{}]\|]" \
          <<<"${HOSTNAME}"; then
        message "${HOSTNAME_ERROR_MSG}"
      else
        break
      fi
    fi
  done
  log "Hostname set: ${HOSTNAME}"
}

################################################################################
# Prompt user for a username and full name and ensure all input is valid, then
# call 'set_password' to handle password input. (For now, GDL does not support
# creating more than one user during installation.)
#
# Globals: USERNAME, FULL_NAME, SET_USERNAME_MSG, SET_FULL_NAME_MSG, etc.
# Arguments: None
################################################################################
set_user() {
  TITLE="${ADD_USER_TITLE}"
  while true; do
    if ! USERNAME="$(dialog --no-cancel --ok-button "${OK}" --inputbox \
        "\n${SET_USERNAME_MSG}" 12 55 | tr -d '[:space:]')" ||
        [[ -z "${USERNAME}" ]]; then
      message "${USERNAME_EMPTY_ERROR_MSG}"
    elif grep -q "^[0-9]\|[A-Z]\|[]:/?#@\!\$&'()*+,;=%[]" <<<"${USERNAME}"; then
      message "${USERNAME_CHAR_ERROR_MSG}"
    else
      log "Username set: ${USERNAME}"
      while true; do
        if FULL_NAME="$(dialog --no-cancel --ok-button "${OK}" --inputbox \
            "\n${SET_FULL_NAME_MSG}" 12 55)"; then
          if grep -Eq ',|:' <<<"${FULL_NAME}"; then
            message "${FULL_NAME_ERROR_MSG}"
          else
            set_password
            break
          fi
        fi
      done
      break
    fi
  done
}

################################################################################
# Prompt user for a password ('root' will use the same password).
#
# Globals: PASSWORD, SSL_KEY, USER_PASSWORD_MSG, PASSWORD_MISMATCH_MSG, etc.
# Arguments: None
################################################################################
set_password() {
  TITLE="${SET_PASSWORD_TITLE}"
  local input input_check

  while true; do
    if ! input="$(dialog --no-cancel --clear --insecure --passwordbox \
        "\n$(eval echo \"${USER_PASSWORD_MSG}\")" 12 60)" ||
        ! input_check="$(dialog --no-cancel --clear --insecure --passwordbox \
        "\n$(eval echo \"${USER_PASSWORD_CONFIRM}\")" 12 60)" ||
        [[ -z "${input}" ]]; then
      message "${PASSWORD_EMPTY_MSG}"
    elif [[ "${input}" != "${input_check}" ]]; then
      message "${PASSWORD_MISMATCH_MSG}"
    else
      break
    fi
  done
  PASSWORD="$(echo "${input}" | openssl enc -aes-256-cbc -a -salt -pbkdf2 \
    -iter 1000 -pass pass:"${SSL_KEY}")"
  unset input input_check
  log "Password set for user: ${USERNAME}"
}

################################################################################
# Provide desktop environment (DE) options and add to the list of base (and AUR)
# packages according to chosen DE, detected hardware, etc.
#
# Globals: BASE_PACKAGES, AUR_AND_OPTIONAL_PACKAGES, GPU_CHIPSET, DESKTOP_ENV,
#   DISPLAY_MANAGER, TOUCHPAD_MSG, OS_PROBER_MSG, UEFI, BTRFS_ROOT, LOCALE, etc.
# Arguments: None
################################################################################
prepare_base() {
  TITLE="${INSTALLATION_TITLE}"
  local gpu_driver
  log "Preparing base packages..."

  # Set desktop environment
  until DESKTOP_ENV="$(dialog --stdout --no-cancel --ok-button "${OK}" --menu \
      "\n${DESKTOP_ENV_MSG}" 13 60 4 \
      'KDE Plasma' '->' \
      'GNOME' '->' \
      'Cinnamon' '->' \
      'Xfce' '->')"; do
    continue
  done
  DESKTOP_ENV="$(echo "${DESKTOP_ENV@L}" | tr ' ' '-')"
  BASE_PACKAGES+="${DESKTOP_ENV_BASE_PACKAGES[$DESKTOP_ENV]}"
  AUR_AND_OPTIONAL_PACKAGES+="${DESKTOP_ENV_AUR_PACKAGES[$DESKTOP_ENV]}"
  log "* Desktop environment: ${DESKTOP_ENV}"

  # Set display manager (login manager)
  case "${DESKTOP_ENV}" in
    kde-plasma) # offer SDDM or LightDM for KDE Plasma
      until DISPLAY_MANAGER="$(dialog --stdout --no-cancel --ok-button "${OK}" \
          --menu "\n${DISPLAY_MANAGER_MSG} \Z2sddm\Zn" 13 60 2 \
          'sddm' '->' \
          'lightdm' '->')"; do
        continue
      done
      ;;
    gnome) DISPLAY_MANAGER='gdm' ;; # default to GDM for GNOME
    *) DISPLAY_MANAGER='lightdm' ;; # default to LightDM for Cinnamon/Xfce
  esac
  BASE_PACKAGES+="${DISPLAY_MANAGER} "
  if [[ "${DISPLAY_MANAGER}" == 'lightdm' ]]; then
    BASE_PACKAGES+='lightdm-gtk-greeter-settings '
    AUR_AND_OPTIONAL_PACKAGES+='lightdm-guest-account '
  fi
  log "* Display manager: ${DISPLAY_MANAGER}"

  # Add packages based on hardware, boot/root setup, and user input
  if grep -q 'AuthenticAMD' /proc/cpuinfo; then
    BASE_PACKAGES+='amd-ucode '
    log "* Added AMD microcode"
  elif grep -q 'GenuineIntel' /proc/cpuinfo; then
    BASE_PACKAGES+='intel-ucode '
    log "* Added Intel microcode"
  fi
  if yesno "${TOUCHPAD_MSG}" "${YES}" "${NO}" --defaultno; then
    BASE_PACKAGES+='xf86-input-libinput '
    log "* Added touchpad support"
  fi
  if yesno "${OS_PROBER_MSG}" "${YES}" "${NO}" --defaultno; then
    BASE_PACKAGES+='os-prober '
    log "* Added OS prober"
  fi
  if "${UEFI}"; then
    BASE_PACKAGES+='efibootmgr '
    log "* Added EFI boot manager"
  fi
  if "${BTRFS_ROOT}"; then
    BASE_PACKAGES+='grub-btrfs '
    log "* Added GRUB Btrfs snapshot support"
  fi

  # Add locale-specific packages
  if [[ "${LOCALE}" =~ zh_|yue_|_CN|_HK|_SG|_TW|ja_|ko_ ]]; then
    BASE_PACKAGES+='noto-fonts-cjk '
  fi
  if grep -q 'libreoffice' <<<"${BASE_PACKAGES}"; then
    case "${LOCALE}" in
      af_*) BASE_PACKAGES+='libreoffice-fresh-af ' ;; # Afrikaans
      am_*) BASE_PACKAGES+='libreoffice-fresh-am ' ;; # Amharic
      ar_*) BASE_PACKAGES+='libreoffice-fresh-ar ' ;; # Arabic
      as_*) BASE_PACKAGES+='libreoffice-fresh-as ' ;; # Assamese
      ast_*) BASE_PACKAGES+='libreoffice-fresh-ast ' ;; # Asturianu
      be_*) BASE_PACKAGES+='libreoffice-fresh-be ' ;; # Belarusian
      bg_*) BASE_PACKAGES+='libreoffice-fresh-bg ' ;; # Bulgarian
      bn_IN*) BASE_PACKAGES+='libreoffice-fresh-bn-in ' ;; # Bengali (India)
      bn_*) BASE_PACKAGES+='libreoffice-fresh-bn ' ;; # Bengali
      bo_*) BASE_PACKAGES+='libreoffice-fresh-bo ' ;; # Tibetan
      br_*) BASE_PACKAGES+='libreoffice-fresh-br ' ;; # Breton
      brx_*) BASE_PACKAGES+='libreoffice-fresh-brx ' ;; # Bodo
      bs_*) BASE_PACKAGES+='libreoffice-fresh-bs ' ;; # Bosnian
      ca_*val*) BASE_PACKAGES+='libreoffice-fresh-ca-valencia ' ;; # Cat. (Val.)
      ca_*) BASE_PACKAGES+='libreoffice-fresh-ca ' ;; # Catalan
      ckb_*) BASE_PACKAGES+='libreoffice-fresh-ckb ' ;; # Central Kurdish/Sorani
      cs_*) BASE_PACKAGES+='libreoffice-fresh-cs ' ;; # Czech
      cy_*) BASE_PACKAGES+='libreoffice-fresh-cy ' ;; # Welsh
      da_*) BASE_PACKAGES+='libreoffice-fresh-da ' ;; # Danish
      de_*) BASE_PACKAGES+='libreoffice-fresh-de ' ;; # German
      dgo_*) BASE_PACKAGES+='libreoffice-fresh-dgo ' ;; # Dogri
      dsb_*) BASE_PACKAGES+='libreoffice-fresh-dsb ' ;; # Sorbian (Lower)
      dz_*) BASE_PACKAGES+='libreoffice-fresh-dz ' ;; # Dzongkha
      el_*) BASE_PACKAGES+='libreoffice-fresh-el ' ;; # Greek
      en_ZA*) BASE_PACKAGES+='libreoffice-fresh-en-za ' ;; # English (S. Africa)
      en_[^U]*) BASE_PACKAGES+='libreoffice-fresh-en-gb ' ;; # English (GB)
      eo_*) BASE_PACKAGES+='libreoffice-fresh-eo ' ;; # Esperanto
      es_*) BASE_PACKAGES+='libreoffice-fresh-es ' ;; # Spanish
      et_*) BASE_PACKAGES+='libreoffice-fresh-et ' ;; # Estonian
      eu_*) BASE_PACKAGES+='libreoffice-fresh-eu ' ;; # Basque
      fa_*) BASE_PACKAGES+='libreoffice-fresh-fa ' ;; # Persian
      fi_*) BASE_PACKAGES+='libreoffice-fresh-fi ' ;; # Finnish
      fr_*) BASE_PACKAGES+='libreoffice-fresh-fr ' ;; # French
      fur_*) BASE_PACKAGES+='libreoffice-fresh-fur ' ;; # Friulian/Friulan
      fy_*) BASE_PACKAGES+='libreoffice-fresh-fy ' ;; # Frisian/Frysk/Fries
      ga_*) BASE_PACKAGES+='libreoffice-fresh-ga ' ;; # Irish
      gd_*) BASE_PACKAGES+='libreoffice-fresh-gd ' ;; # Gaelic (Scottish)
      gl_*) BASE_PACKAGES+='libreoffice-fresh-gl ' ;; # Galician
      gn_*|gug_*) BASE_PACKAGES+='libreoffice-fresh-gug ' ;; # Guarani
      gu_*) BASE_PACKAGES+='libreoffice-fresh-gu ' ;; # Gujarati
      he_*) BASE_PACKAGES+='libreoffice-fresh-he ' ;; # Hebrew
      hi_*) BASE_PACKAGES+='libreoffice-fresh-hi ' ;; # Hindi
      hr_*) BASE_PACKAGES+='libreoffice-fresh-hr ' ;; # Croatian
      hsb_*) BASE_PACKAGES+='libreoffice-fresh-hsb ' ;; # Sorbian (Upper)
      hu_*) BASE_PACKAGES+='libreoffice-fresh-hu ' ;; # Hungarian
      id_*) BASE_PACKAGES+='libreoffice-fresh-id ' ;; # Indonesian
      is_*) BASE_PACKAGES+='libreoffice-fresh-is ' ;; # Icelandic
      it_*) BASE_PACKAGES+='libreoffice-fresh-it ' ;; # Italian
      ja_*) BASE_PACKAGES+='libreoffice-fresh-ja ' ;; # Japanese
      ka_*) BASE_PACKAGES+='libreoffice-fresh-ka ' ;; # Georgian
      kab_*) BASE_PACKAGES+='libreoffice-fresh-kab ' ;; # Kabyle, etc.
      kk_*) BASE_PACKAGES+='libreoffice-fresh-kk ' ;; # Kazakh
      km_*) BASE_PACKAGES+='libreoffice-fresh-km ' ;; # Khmer
      kmr_*) BASE_PACKAGES+='libreoffice-fresh-kmr-latn ' ;; # Kurdish
      kn_*) BASE_PACKAGES+='libreoffice-fresh-kn ' ;; # Kannada
      ko_*) BASE_PACKAGES+='libreoffice-fresh-ko ' ;; # Korean
      kok_*) BASE_PACKAGES+='libreoffice-fresh-kok ' ;; # Konkani
      ks_*) BASE_PACKAGES+='libreoffice-fresh-ks ' ;; # Kashmiri
      lb_*) BASE_PACKAGES+='libreoffice-fresh-lb ' ;; # Luxembourgish
      lo_*) BASE_PACKAGES+='libreoffice-fresh-lo ' ;; # Lao
      lt_*) BASE_PACKAGES+='libreoffice-fresh-lt ' ;; # Lithuanian
      lv_*) BASE_PACKAGES+='libreoffice-fresh-lv ' ;; # Latvian
      mai_*) BASE_PACKAGES+='libreoffice-fresh-mai ' ;; # Maithili
      mk_*) BASE_PACKAGES+='libreoffice-fresh-mk ' ;; # Macedonian
      ml_*) BASE_PACKAGES+='libreoffice-fresh-ml ' ;; # Malayalam
      mn_*) BASE_PACKAGES+='libreoffice-fresh-mn ' ;; # Mongolian
      mni_*) BASE_PACKAGES+='libreoffice-fresh-mni ' ;; # Manipuri
      mr_*) BASE_PACKAGES+='libreoffice-fresh-mr ' ;; # Marathi
      my_*) BASE_PACKAGES+='libreoffice-fresh-my ' ;; # Burmese
      nb_*) BASE_PACKAGES+='libreoffice-fresh-nb ' ;; # Norwegian (Bokmål)
      ne_*) BASE_PACKAGES+='libreoffice-fresh-ne ' ;; # Nepali
      nl_*) BASE_PACKAGES+='libreoffice-fresh-nl ' ;; # Dutch
      nn_*) BASE_PACKAGES+='libreoffice-fresh-nn ' ;; # Norwegian (Nynorsk)
      nr_*) BASE_PACKAGES+='libreoffice-fresh-nr ' ;; # Ndebele
      nso_*) BASE_PACKAGES+='libreoffice-fresh-nso ' ;; # Sotho (Northern)
      oc_*) BASE_PACKAGES+='libreoffice-fresh-oc ' ;; # Occitan
      om_*) BASE_PACKAGES+='libreoffice-fresh-om ' ;; # Oromo
      or_*) BASE_PACKAGES+='libreoffice-fresh-or ' ;; # Oriya
      pa_*) BASE_PACKAGES+='libreoffice-fresh-pa-in ' ;; # Punjabi
      pl_*) BASE_PACKAGES+='libreoffice-fresh-pl ' ;; # Polish
      pt_BR*) BASE_PACKAGES+='libreoffice-fresh-pt-br ' ;; # Portuguese (Brazil)
      pt_*) BASE_PACKAGES+='libreoffice-fresh-pt ' ;; # Portuguese
      ro_*) BASE_PACKAGES+='libreoffice-fresh-ro ' ;; # Romanian
      ru_*) BASE_PACKAGES+='libreoffice-fresh-ru ' ;; # Russian
      rw_*) BASE_PACKAGES+='libreoffice-fresh-rw ' ;; # Kinyarwanda
      sa_*) BASE_PACKAGES+='libreoffice-fresh-sa-in ' ;; # Sanskrit
      sat_*) BASE_PACKAGES+='libreoffice-fresh-sat ' ;; # Santali
      sd_*) BASE_PACKAGES+='libreoffice-fresh-sd ' ;; # Sindhi
      si_*) BASE_PACKAGES+='libreoffice-fresh-si ' ;; # Sinhala
      sid_*) BASE_PACKAGES+='libreoffice-fresh-sid ' ;; # Sidama
      sk_*) BASE_PACKAGES+='libreoffice-fresh-sk ' ;; # Slovak
      sl_*) BASE_PACKAGES+='libreoffice-fresh-sl ' ;; # Slovenian
      sq_*) BASE_PACKAGES+='libreoffice-fresh-sq ' ;; # Albanien
      sr_*lat*) BASE_PACKAGES+='libreoffice-fresh-sr-latn ' ;; # Serbian (Latin)
      sr_*) BASE_PACKAGES+='libreoffice-fresh-sr ' ;; # Serbian
      ss_*) BASE_PACKAGES+='libreoffice-fresh-ss ' ;; # Swati
      st_*) BASE_PACKAGES+='libreoffice-fresh-st ' ;; # Sotho (Southern)
      sv_*) BASE_PACKAGES+='libreoffice-fresh-sv ' ;; # Swedish
      sw_*) BASE_PACKAGES+='libreoffice-fresh-sw-tz ' ;; # Swahili
      szl_*) BASE_PACKAGES+='libreoffice-fresh-szl ' ;; # Silesian
      ta_*) BASE_PACKAGES+='libreoffice-fresh-ta ' ;; # Tamil
      te_*) BASE_PACKAGES+='libreoffice-fresh-te ' ;; # Telugu
      tg_*) BASE_PACKAGES+='libreoffice-fresh-tg ' ;; # Tajik
      th_*) BASE_PACKAGES+='libreoffice-fresh-th ' ;; # Thai
      tn_*) BASE_PACKAGES+='libreoffice-fresh-tn ' ;; # Tswana
      tr_*) BASE_PACKAGES+='libreoffice-fresh-tr ' ;; # Turkish
      ts_*) BASE_PACKAGES+='libreoffice-fresh-ts ' ;; # Tsonga
      tt_*) BASE_PACKAGES+='libreoffice-fresh-tt ' ;; # Tatar
      ug_*) BASE_PACKAGES+='libreoffice-fresh-ug ' ;; # Uighur
      uk_*) BASE_PACKAGES+='libreoffice-fresh-uk ' ;; # Ukranian
      uz_*) BASE_PACKAGES+='libreoffice-fresh-uz ' ;; # Uzbek
      ve_*) BASE_PACKAGES+='libreoffice-fresh-ve ' ;; # Venda
      vec_*) BASE_PACKAGES+='libreoffice-fresh-vec ' ;; # Venetian
      vi_*) BASE_PACKAGES+='libreoffice-fresh-vi ' ;; # Vietnamese
      xh_*) BASE_PACKAGES+='libreoffice-fresh-xh ' ;; # Xhosa
      zh_CN*|zh_SG*) BASE_PACKAGES+='libreoffice-fresh-zh-cn ' ;; # S. Chinese
      zh_*|yue_*|*_TW*) BASE_PACKAGES+='libreoffice-fresh-zh-tw ' ;; # T. Ch.
      zu_*) BASE_PACKAGES+='libreoffice-fresh-zu ' ;; # Zulu
    esac
  fi

  # Add graphics/VM packages
  if [[ "${VM_TYPE}" != 'none' ]]; then
    case "${VM_TYPE}" in
      qemu)
        BASE_PACKAGES+='spice-vdagent qemu-guest-agent '
        log "* Added QEMU guest utils"
        ;;
      oracle)
        BASE_PACKAGES+='virtualbox-guest-utils '
        log "* Added VirtualBox guest utils"
        ;;
      vmware)
        BASE_PACKAGES+='xf86-video-vmware xf86-input-vmmouse open-vm-tools
          net-tools gtkmm '
        log "* Added VMware guest utils"
        ;;
      *)
        BASE_PACKAGES+='xf86-video-fbdev '
        log "* Added generic VM guest utils"
        ;;
    esac
  else # not a VM
    if [[ "${GPU_CHIPSET}" == 'NVIDIA' ]]; then
      until gpu_driver="$(dialog --ok-button "${OK}" --no-cancel --menu \
          "\n$(eval echo \"${GPU_DRIVER_MSG}\")" 18 60 7 \
          "${DEFAULT}" "${GPU_DEFAULT_MSG}" \
          'nvidia' "${GPU_NVIDIA_MSG}" \
          'xf86-video-nouveau' "${GPU_NOUVEAU_MSG}" \
          'xf86-video-intel' "${GPU_INTEL_MSG}" \
          'xf86-video-vesa' "${GPU_VESA_MSG}" \
          'xf86-video-ati' "${GPU_ATI_MSG}" \
          'xf86-video-amdgpu' "${GPU_AMDGPU_MSG}")"; do
        continue
      done
    else
      until gpu_driver="$(dialog --ok-button "${OK}" --no-cancel --menu \
          "\n$(eval echo \"${GPU_DRIVER_MSG}\")" 17 60 6 \
          "${DEFAULT}" "${GPU_DEFAULT_MSG}" \
          'xf86-video-ati' "${GPU_ATI_MSG}" \
          'xf86-video-amdgpu' "${GPU_AMDGPU_MSG}" \
          'xf86-video-intel' "${GPU_INTEL_MSG}" \
          'xf86-video-vesa' "${GPU_VESA_MSG}" \
          'nvidia' "${GPU_NVIDIA_MSG}" \
          'xf86-video-nouveau' "${GPU_NOUVEAU_MSG}")"; do
        continue
      done
    fi
    [[ "${gpu_driver}" == "${DEFAULT}" ]] && gpu_driver="${DEFAULT_GPU_DRIVER}"
    BASE_PACKAGES+="${gpu_driver} "
    case "${gpu_driver}" in
      nvidia) BASE_PACKAGES+="${NVIDIA_GPU_PACKAGES}" ;;
      *-ati|*-amdgpu) BASE_PACKAGES+="${AMD_GPU_PACKAGES}" ;;
      xf86-video-intel) BASE_PACKAGES+="${INTEL_GPU_PACKAGES}" ;;
    esac
    log "* Added graphics driver: ${gpu_driver}"
  fi
}

################################################################################
# Present categorized software selection menus and add selected packages (plus
# supplemental packages, as appropriate) to the list of AUR/optional packages.
#
# Globals: AUR_AND_OPTIONAL_PACKAGES, BASE_PACKAGES, WINE_PACKAGES, etc.
# Arguments: None
################################################################################
select_additional_software() {
  local -a software options
  local -i category_num=0 num_categories=13

  while (( category_num < num_categories )); do
    case $category_num in
      0)
        TITLE="${MISC_GAMES_SOFTWARE_TITLE}"
        options=(
          'lutris' "${SOFTWARE_LUTRIS}" OFF
          'steam' "${SOFTWARE_STEAM}" OFF
          'bottles' "(AUR) ${SOFTWARE_BOTTLES}" OFF
          'itch-setup-bin' "(AUR) ${SOFTWARE_ITCH_SETUP_BIN}" OFF
          'heroic-games-launcher-bin'
            "(AUR) ${SOFTWARE_HEROIC_GAMES_LAUNCHER_BIN}" OFF
          'libretro' "${SOFTWARE_LIBRETRO}" OFF
          'dosbox' "${SOFTWARE_DOSBOX}" OFF
          'scummvm' "${SOFTWARE_SCUMMVM}" OFF
          'playonlinux' "${SOFTWARE_PLAYONLINUX}" OFF
          'innoextract' "${SOFTWARE_INNOEXTRACT}" OFF
        )
        ;;
      1)
        TITLE="${ACTION_GAMES_SOFTWARE_TITLE}"
        options=(
          'supertux' "${SOFTWARE_SUPERTUX}" OFF
          'frogatto' "${SOFTWARE_FROGATTO}" OFF
          'alex4' "${SOFTWARE_ALEX4}" OFF
          'sdlpop' "(AUR) ${SOFTWARE_SDLPOP}" OFF
          'asciiportal' "${SOFTWARE_ASCIIPORTAL}" OFF
          'mari0' "${SOFTWARE_MARI0}" OFF
          'xonotic' "${SOFTWARE_XONOTIC}" OFF
          'warsow' "${SOFTWARE_WARSOW}" OFF
          'sauerbraten' "${SOFTWARE_SAUERBRATEN}" OFF
          'assaultcube-reloaded' "(AUR) ${SOFTWARE_ASSAULTCUBE_RELOADED}" OFF
          'openarena' "(AUR) ${SOFTWARE_OPENARENA}" OFF
          'astromenace' "${SOFTWARE_ASTROMENACE}" OFF
          'chromium-bsu' "${SOFTWARE_CHROMIUM_BSU}" OFF
          'starfighter' "(AUR) ${SOFTWARE_STARFIGHTER}" OFF
          'teeworlds' "${SOFTWARE_TEEWORLDS}" OFF
          'bzflag' "(AUR) ${SOFTWARE_BZFLAG}" OFF
        )
        ;;
      2)
        TITLE="${ADVENTURE_GAMES_SOFTWARE_TITLE}"
        options=(
          'bass' "${SOFTWARE_BASS}" OFF
          'fotaq' "(AUR) ${SOFTWARE_FOTAQ}" OFF
          'lure' "(AUR) ${SOFTWARE_LURE}" OFF
          'drascula' "(AUR) ${SOFTWARE_DRASCULA}" OFF
          'zsdx' "(AUR) ${SOFTWARE_ZSDX}" OFF
          'zork1' "(AUR) ${SOFTWARE_ZORK1}" OFF
          'zork2' "(AUR) ${SOFTWARE_ZORK2}" OFF
          'zork3' "(AUR) ${SOFTWARE_ZORK3}" OFF
          'open-adventure' "(AUR) ${SOFTWARE_OPEN_ADVENTURE}" OFF
        )
        ;;
      3)
        TITLE="${ROLEPLAYING_GAMES_SOFTWARE_TITLE}"
        options=(
          'openmw' "${SOFTWARE_OPENMW}" OFF
          'openmw-tes3mp' "(AUR) ${SOFTWARE_OPENMW_TES3MP}" OFF
          'daggerfall-unity-aur-bin'
            "(AUR) ${SOFTWARE_DAGGERFALL_UNITY_AUR_BIN}" OFF
          'rogue' "${SOFTWARE_ROGUE}" OFF
          'angband' "${SOFTWARE_ANGBAND}" OFF
          'umoria' "(AUR) ${SOFTWARE_UMORIA}" OFF
          'nethack' "${SOFTWARE_NETHACK}" OFF
          'tome4' "(AUR) ${SOFTWARE_TOME4}" OFF
          'stone-soup' "${SOFTWARE_STONE_SOUP}" OFF
          'cataclysm-dda-tiles' "${SOFTWARE_CATACLYSM_DDA_TILES}" OFF
          'doomrl' "(AUR) ${SOFTWARE_DOOMRL}" OFF
          'freedroidrpg' "${SOFTWARE_FREEDROIDRPG}" OFF
          'flare-game' "(AUR) ${SOFTWARE_FLARE_GAME}" OFF
          'naev' "${SOFTWARE_NAEV}" OFF
          'planeshift' "(AUR) ${SOFTWARE_PLANESHIFT}" OFF
          'runescape-launcher' "(AUR) ${SOFTWARE_RUNESCAPE_LAUNCHER}" OFF
          'runelite' "(AUR) ${SOFTWARE_RUNELITE}" OFF
          'manaplus' "${SOFTWARE_MANAPLUS}" OFF
        )
        ;;
      4)
        TITLE="${STRATEGY_GAMES_SOFTWARE_TITLE}"
        options=(
          '0ad' "${SOFTWARE_0AD}" OFF
          'widelands' "${SOFTWARE_WIDELANDS}" OFF
          'megaglest' "${SOFTWARE_MEGAGLEST}" OFF
          'warzone2100' "${SOFTWARE_WARZONE2100}" OFF
          'boswars' "(AUR) ${SOFTWARE_BOSWARS}" OFF
          'curseofwar' "${SOFTWARE_CURSEOFWAR}" OFF
          'wesnoth' "${SOFTWARE_WESNOTH}" OFF
          'pingus' "${SOFTWARE_PINGUS}" OFF
          'hedgewars' "${SOFTWARE_HEDGEWARS}" OFF
          'warmux' "(AUR) ${SOFTWARE_WARMUX}" OFF
          'freeciv' "${SOFTWARE_FREECIV}" OFF
          'singularity' "${SOFTWARE_SINGULARITY}" OFF
        )
        ;;
      5)
        TITLE="${RACING_GAMES_SOFTWARE_TITLE}"
        options=(
          'supertuxkart' "${SOFTWARE_SUPERTUXKART}" OFF
          'extremetuxracer' "${SOFTWARE_EXTREMETUXRACER}" OFF
          'armagetronad' "${SOFTWARE_ARMAGETRONAD}" OFF
          'gltron' "(AUR) ${SOFTWARE_GLTRON}" OFF
          'torcs' "(AUR) ${SOFTWARE_TORCS}" OFF
        )
        ;;
      6)
        TITLE="${SIM_GAMES_SOFTWARE_TITLE}"
        options=(
          'dwarffortress' "${SOFTWARE_DWARFFORTRESS}" OFF
          'lincity-ng' "${SOFTWARE_LINCITY_NG}" OFF
          'simutrans' "${SOFTWARE_SIMUTRANS}" OFF
          'flightgear' "(AUR) ${SOFTWARE_FLIGHTGEAR}" OFF
          'minetest' "${SOFTWARE_MINETEST}" OFF
          'minecraft-launcher' "(AUR) ${SOFTWARE_MINECRAFT_LAUNCHER}" OFF
        )
        ;;
      7)
        TITLE="${DEV_SOFTWARE_TITLE}"
        options=(
          'godot' "${SOFTWARE_GODOT}" OFF
          'unityhub' "(AUR) ${SOFTWARE_UNITYHUB}" OFF
          'unreal-engine' "(AUR) ${SOFTWARE_UNREAL_ENGINE}" OFF
          'spring' "${SOFTWARE_SPRING}" OFF
          'love' "${SOFTWARE_LOVE}" OFF
          'solarus' "(AUR) ${SOFTWARE_SOLARUS}" OFF
          'tiled' "${SOFTWARE_TILED}" OFF
          'allegro' "${SOFTWARE_ALLEGRO}" OFF
          'python-pygame' "${SOFTWARE_PYTHON_PYGAME}" OFF
          'panda3d' "(AUR) ${SOFTWARE_PANDA3D}" OFF
          'pygtk' "(AUR) ${SOFTWARE_PYGTK}" OFF
          'scratch' "${SOFTWARE_SCRATCH}" OFF
          'android-studio' "(AUR) ${SOFTWARE_ANDROID_STUDIO}" OFF
          'atom' "${SOFTWARE_ATOM}" OFF
          'code' "${SOFTWARE_CODE}" OFF
          'geany' "${SOFTWARE_GEANY}" OFF
          'emacs' "${SOFTWARE_EMACS}" OFF
        )
        ;;
      8)
        TITLE="${GRAPHICS_SOFTWARE_TITLE}"
        options=(
          'gimp' "${SOFTWARE_GIMP}" OFF
          'inkscape' "${SOFTWARE_INKSCAPE}" OFF
          'blender' "${SOFTWARE_BLENDER}" OFF
          'goxel' "(AUR) ${SOFTWARE_GOXEL}" OFF
          'magicavoxel' "(AUR) ${SOFTWARE_MAGICAVOXEL}" OFF
          'libresprite' "(AUR) ${SOFTWARE_LIBRESPRITE}" OFF
          'aseprite' "(AUR) ${SOFTWARE_ASEPRITE}" OFF
          'mtpaint' "${SOFTWARE_MTPAINT}" OFF
          'mypaint' "${SOFTWARE_MYPAINT}" OFF
          'krita' "${SOFTWARE_KRITA}" OFF
        )
        ;;
      9)
        TITLE="${MULTIMEDIA_SOFTWARE_TITLE}"
        options=(
          'obs-studio' "${SOFTWARE_OBS_STUDIO}" OFF
          'kdenlive' "${SOFTWARE_KDENLIVE}" OFF
          'openshot' "${SOFTWARE_OPENSHOT}" OFF
          'simplescreenrecorder' "${SOFTWARE_SIMPLESCREENRECORDER}" OFF
          'minitube' "${SOFTWARE_MINITUBE}" OFF
          'youtube-dl' "${SOFTWARE_YOUTUBE_DL}" OFF
          'audacity' "${SOFTWARE_AUDACITY}" OFF
          'lmms' "${SOFTWARE_LMMS}" OFF
          'pulseaudio-equalizer' "${SOFTWARE_PULSEAUDIO_EQUALIZER}" OFF
          'spotify' "(AUR) ${SOFTWARE_SPOTIFY}" OFF
        )
        ;;
      10)
        TITLE="${INTERNET_SOFTWARE_TITLE}"
        options=(
          'firefox' "${SOFTWARE_FIREFOX}" OFF
          'chromium' "${SOFTWARE_CHROMIUM}" OFF
          'google-chrome' "(AUR) ${SOFTWARE_GOOGLE_CHROME}" OFF
          'opera' "${SOFTWARE_OPERA}" OFF
          'discord' "${SOFTWARE_DISCORD}" OFF
          'slack-desktop' "(AUR) ${SOFTWARE_SLACK_DESKTOP}" OFF
          'hexchat' "${SOFTWARE_HEXCHAT}" OFF
          'filezilla' "${SOFTWARE_FILEZILLA}" OFF
          'w3m' "${SOFTWARE_W3M}" OFF
          'lynx' "${SOFTWARE_LYNX}" OFF
        )
        ;;
      11)
        TITLE="${FONTS_AND_LANG_SOFTWARE_TITLE}"
        options=(
          'nerd-fonts-complete'
            "(AUR) ${SOFTWARE_NERD_FONTS_COMPLETE}" OFF
          'noto-fonts' "${SOFTWARE_NOTO_FONTS}" OFF
          'noto-fonts-extra' "${SOFTWARE_NOTO_FONTS_EXTRA}" OFF
          'noto-fonts-cjk' "${SOFTWARE_NOTO_FONTS_CJK}" OFF
          'ibus-libpinyin' "${SOFTWARE_IBUS_LIBPINYIN}" OFF
          'ibus-chewing' "${SOFTWARE_IBUS_CHEWING}" OFF
          'ibus-kkc' "${SOFTWARE_IBUS_KKC}" OFF
          'ibus-hangul' "${SOFTWARE_IBUS_HANGUL}" OFF
        )
        ;;
      12)
        TITLE="${UTILITIES_SOFTWARE_TITLE}"
        options=(
          'timeshift' "(AUR) ${SOFTWARE_TIMESHIFT}" OFF
          'htop' "${SOFTWARE_HTOP}" OFF
          'gtop' "${SOFTWARE_GTOP}" OFF
          'bashtop' "${SOFTWARE_BASHTOP}" OFF
          'mangohud' "(AUR) ${SOFTWARE_MANGOHUD}" OFF
          'gparted' "${SOFTWARE_GPARTED}" OFF
          'gnome-disk-utility' "${SOFTWARE_GNOME_DISK_UTILITY}" OFF
          'baobab' "${SOFTWARE_BAOBAB}" OFF
          'tmux' "${SOFTWARE_TMUX}" OFF
          'ranger' "${SOFTWARE_RANGER}" OFF
          'virtualbox' "${SOFTWARE_VIRTUALBOX}" OFF
          'libvirt' "${SOFTWARE_LIBVIRT}" OFF
          'vmware-workstation' "(AUR) ${SOFTWARE_VMWARE_WORKSTATION}" OFF
          'insync' "(AUR) ${SOFTWARE_INSYNC}" OFF
          'pcloud-drive' "(AUR) ${SOFTWARE_PCLOUD_DRIVE}" OFF
          'authy' "(AUR) ${SOFTWARE_AUTHY}" OFF
          'clamav' "${SOFTWARE_CLAMAV}" OFF
          'bleachbit' "${SOFTWARE_BLEACHBIT}" OFF
        )
        ;;
    esac
    if (( category_num == 0 )); then
      if software[0]="$(dialog --no-cancel --ok-button "${OK}" --checklist \
          "\n${SELECT_SOFTWARE_MSG}" 0 0 0 "${options[@]}")"; then
        (( category_num++ ))
      fi
    elif software[category_num]="$(dialog --ok-button "${OK}" --cancel-button \
        "${BACK}" --checklist "\n${SELECT_SOFTWARE_MSG}" 0 0 0 \
        "${options[@]}")"; then
      (( category_num++ ))
    else
      (( category_num-- ))
    fi
  done
  log "AUR/optional packages selected: $(tr <<<"${software[*]}" ' ' '\n' |
    sort | uniq | tr '\n' ' ')"

  # Add supplemental packages, etc., as appropriate
  if grep -Eq 'lutris|bottles|playonlinux' <<<"${software[@]}"; then
    BASE_PACKAGES+="${WINE_PACKAGES}"
  fi
  if grep -q 'steam' <<<"${software[@]}"; then
    BASE_PACKAGES+='steam-native-runtime '
  fi
  if grep -q 'drascula' <<<"${software[@]}"; then
    software[0]+=' drascula-audio'
  fi
  if grep -q 'ibus' <<<"${software[@]}" &&
      ! grep -q 'cjk' <<<"${software[@]}" &&
      ! grep -q 'cjk' <<<"${BASE_PACKAGES}"; then
    BASE_PACKAGES+='noto-fonts-cjk '
  fi
  if grep -q 'mangohud' <<<"${software[@]}"; then
    software[0]+=' lib32-mangohud'
  fi
  if grep -q 'virtualbox' <<<"${software[@]}"; then
    BASE_PACKAGES+='virtualbox-host-modules-arch '
  fi
  if grep -q 'libvirt' <<<"${software[@]}"; then
    BASE_PACKAGES+='qemu '
  fi
  if grep -q 'insync' <<<"${software[@]}"; then
    case "${DESKTOP_ENV}" in
      kde-plasma) software[0]+=' insync-dolphin' ;;
      gnome) software[0]+=' insync-nautilus' ;;
      cinnamon) software[0]+=' insync-nemo' ;;
      xfce) software[0]+=' insync-thunar' ;;
    esac
  fi
  if grep -q 'timeshift' <<<"${software[@]}" && "${BTRFS_ROOT}"; then
    software[0]+=' timeshift-autosnap'
  fi
  if grep -q 'firefox' <<<"${software[@]}"; then
    case "${LOCALE}" in
      ach_*) BASE_PACKAGES+='firefox-i18n-ach ' ;; # Acholi
      af_*) BASE_PACKAGES+='firefox-i18n-af ' ;; # Afrikaans
      an_*) BASE_PACKAGES+='firefox-i18n-an ' ;; # Aragonese
      ar_*) BASE_PACKAGES+='firefox-i18n-ar ' ;; # Arabic
      ast_*) BASE_PACKAGES+='firefox-i18n-ast ' ;; # Asturianu
      az_*) BASE_PACKAGES+='firefox-i18n-az ' ;; # Azerbaijani
      be_*) BASE_PACKAGES+='firefox-i18n-be ' ;; # Belarusian
      bg_*) BASE_PACKAGES+='firefox-i18n-bg ' ;; # Bulgarian
      bn_*) BASE_PACKAGES+='firefox-i18n-bn ' ;; # Bengali
      br_*) BASE_PACKAGES+='firefox-i18n-br ' ;; # Breton
      bs_*) BASE_PACKAGES+='firefox-i18n-bs ' ;; # Bosnian
      ca_*val*) BASE_PACKAGES+='firefox-i18n-ca-valencia ' ;; # Catalan (Val.)
      ca_*) BASE_PACKAGES+='firefox-i18n-ca ' ;; # Catalan
      cak_*) BASE_PACKAGES+='firefox-i18n-cak ' ;; # Maya Kaqchikel
      cs_*) BASE_PACKAGES+='firefox-i18n-cs ' ;; # Czech
      cy_*) BASE_PACKAGES+='firefox-i18n-cy ' ;; # Welsh
      da_*) BASE_PACKAGES+='firefox-i18n-da ' ;; # Danish
      de_*) BASE_PACKAGES+='firefox-i18n-de ' ;; # German
      dsb_*) BASE_PACKAGES+='firefox-i18n-dsb ' ;; # Sorbian (Lower)
      el_*) BASE_PACKAGES+='firefox-i18n-el ' ;; # Greek
      en_CA*) BASE_PACKAGES+='firefox-i18n-en-gb ' ;; # English (Canada)
      en_US*) BASE_PACKAGES+='firefox-i18n-en-us ' ;; # English (United States)
      en_*) BASE_PACKAGES+='firefox-i18n-en-gb ' ;; # English (Great Britain)
      eo_*) BASE_PACKAGES+='firefox-i18n-eo ' ;; # Esperanto
      es_AR*) BASE_PACKAGES+='firefox-i18n-es-ar ' ;; # Spanish (Argentina)
      es_CL*) BASE_PACKAGES+='firefox-i18n-es-cl ' ;; # Spanish (Chile)
      es_MX*) BASE_PACKAGES+='firefox-i18n-es-mx ' ;; # Spanish (Mexico)
      es_*) BASE_PACKAGES+='firefox-i18n-es-es ' ;; # Spanish (Spain)
      et_*) BASE_PACKAGES+='firefox-i18n-et ' ;; # Estonian
      eu_*) BASE_PACKAGES+='firefox-i18n-eu ' ;; # Basque
      fa_*) BASE_PACKAGES+='firefox-i18n-fa ' ;; # Persian
      ff_*) BASE_PACKAGES+='firefox-i18n-ff ' ;; # Fulah
      fi_*) BASE_PACKAGES+='firefox-i18n-fi ' ;; # Finnish
      fr_*) BASE_PACKAGES+='firefox-i18n-fr ' ;; # French
      fy_*) BASE_PACKAGES+='firefox-i18n-fy-nl ' ;; # Frisian
      ga_*) BASE_PACKAGES+='firefox-i18n-ga-ie ' ;; # Irish
      gd_*) BASE_PACKAGES+='firefox-i18n-gd ' ;; # Gaelic (Scottish)
      gl_*) BASE_PACKAGES+='firefox-i18n-gl ' ;; # Galician
      gn_*|gug_*) BASE_PACKAGES+='firefox-i18n-gn ' ;; # Guarani
      gu_*) BASE_PACKAGES+='firefox-i18n-gu-in ' ;; # Gujarati
      he_*) BASE_PACKAGES+='firefox-i18n-he ' ;; # Hebrew
      hi_*) BASE_PACKAGES+='firefox-i18n-hi-in ' ;; # Hindi
      hr_*) BASE_PACKAGES+='firefox-i18n-hr ' ;; # Croatian
      hsb_*) BASE_PACKAGES+='firefox-i18n-hsb ' ;; # Sorbian (Upper)
      hu_*) BASE_PACKAGES+='firefox-i18n-hu ' ;; # Hungarian
      hy_*) BASE_PACKAGES+='firefox-i18n-hy-am ' ;; # Armenian
      ia_*) BASE_PACKAGES+='firefox-i18n-ia ' ;; # Interlingua
      id_*) BASE_PACKAGES+='firefox-i18n-id ' ;; # Indonesian
      is_*) BASE_PACKAGES+='firefox-i18n-is ' ;; # Icelandic
      it_*) BASE_PACKAGES+='firefox-i18n-it ' ;; # Italian
      ja_*) BASE_PACKAGES+='firefox-i18n-ja ' ;; # Japanese
      ka_*) BASE_PACKAGES+='firefox-i18n-ka ' ;; # Georgian
      kab_*) BASE_PACKAGES+='firefox-i18n-kab ' ;; # Kabyle, Taqbaylit, etc.
      kk_*) BASE_PACKAGES+='firefox-i18n-kk ' ;; # Kazakh
      km_*) BASE_PACKAGES+='firefox-i18n-km ' ;; # Khmer
      kn_*) BASE_PACKAGES+='firefox-i18n-kn ' ;; # Kannada
      ko_*) BASE_PACKAGES+='firefox-i18n-ko ' ;; # Korean
      lij_*) BASE_PACKAGES+='firefox-i18n-lij ' ;; # Ligurian
      lt_*) BASE_PACKAGES+='firefox-i18n-lt ' ;; # Lithuanian
      lv_*) BASE_PACKAGES+='firefox-i18n-lv ' ;; # Latvian
      mk_*) BASE_PACKAGES+='firefox-i18n-mk ' ;; # Macedonian
      mr_*) BASE_PACKAGES+='firefox-i18n-mr ' ;; # Marathi
      ms_*) BASE_PACKAGES+='firefox-i18n-ms ' ;; # Malay
      my_*) BASE_PACKAGES+='firefox-i18n-my ' ;; # Burmese
      nb_*) BASE_PACKAGES+='firefox-i18n-nb-no ' ;; # Norwegian (Bokmål)
      ne_*) BASE_PACKAGES+='firefox-i18n-ne-np ' ;; # Nepali
      nl_*) BASE_PACKAGES+='firefox-i18n-nl ' ;; # Dutch
      nn_*) BASE_PACKAGES+='firefox-i18n-nn-no ' ;; # Norwegian (Nynorsk)
      oc_*) BASE_PACKAGES+='firefox-i18n-oc ' ;; # Occitan
      pa_*) BASE_PACKAGES+='firefox-i18n-pa-in ' ;; # Punjabi
      pl_*) BASE_PACKAGES+='firefox-i18n-pl ' ;; # Polish
      pt_BR*) BASE_PACKAGES+='firefox-i18n-pt-br ' ;; # Portuguese (Brazil)
      pt_*) BASE_PACKAGES+='firefox-i18n-pt-pt ' ;; # Portuguese (Portugal)
      rm_*) BASE_PACKAGES+='firefox-i18n-rm ' ;; # Romansh
      ro_*) BASE_PACKAGES+='firefox-i18n-ro ' ;; # Romanian
      ru_*) BASE_PACKAGES+='firefox-i18n-ru ' ;; # Russian
      si_*) BASE_PACKAGES+='firefox-i18n-si ' ;; # Sinhala
      sk_*) BASE_PACKAGES+='firefox-i18n-sk ' ;; # Slovak
      sl_*) BASE_PACKAGES+='firefox-i18n-sl ' ;; # Slovenian
      son_*) BASE_PACKAGES+='firefox-i18n-son ' ;; # Songhai
      sq_*) BASE_PACKAGES+='firefox-i18n-sq ' ;; # Albanien
      sr_*) BASE_PACKAGES+='firefox-i18n-sr ' ;; # Serbian
      sv_*) BASE_PACKAGES+='firefox-i18n-sv-se ' ;; # Swedish
      ta_*) BASE_PACKAGES+='firefox-i18n-ta ' ;; # Tamil
      te_*) BASE_PACKAGES+='firefox-i18n-te ' ;; # Telugu
      th_*) BASE_PACKAGES+='firefox-i18n-th ' ;; # Thai
      tl_*) BASE_PACKAGES+='firefox-i18n-tl ' ;; # Tagolog
      tr_*) BASE_PACKAGES+='firefox-i18n-tr ' ;; # Turkish
      trs_*) BASE_PACKAGES+='firefox-i18n-trs ' ;; # Chicahuaxtla Triqui
      uk_*) BASE_PACKAGES+='firefox-i18n-uk ' ;; # Ukranian
      ur_*) BASE_PACKAGES+='firefox-i18n-ur ' ;; # Urdu
      uz_*) BASE_PACKAGES+='firefox-i18n-uz ' ;; # Uzbek
      vi_*) BASE_PACKAGES+='firefox-i18n-vi ' ;; # Vietnamese
      xh_*) BASE_PACKAGES+='firefox-i18n-xh ' ;; # Xhosa
      *_CN*|zh_SG*) BASE_PACKAGES+='firefox-i18n-zh-cn ' ;; # Simplified Chinese
      zh_*|yue_*|*_TW*) BASE_PACKAGES+='firefox-i18n-zh-tw ' ;; # Trad. Chinese
    esac
  fi

  # Add selected and supplemental software to the AUR/optional list and sort it
  AUR_AND_OPTIONAL_PACKAGES+="${software[*]} "
  AUR_AND_OPTIONAL_PACKAGES="$(tr <<<"${AUR_AND_OPTIONAL_PACKAGES}" ' ' '\n' |
    sort | uniq | tr '\n' ' ')"
  log "Full AUR/optional package list: ${AUR_AND_OPTIONAL_PACKAGES}"
}

################################################################################
# Give the user a final chance to cancel installation, then clean up the list of
# base packages and install them via pacstrap. If pacstrap fails, upload log
# file text to termbin and present the resulting URL before exiting.
#
# Globals: INSTALL_CONFIRM, BASE_PACKAGES, PACSTRAP_ERROR_MSG, etc.
# Arguments: None
################################################################################
install_base() {
  TITLE="${INSTALLATION_TITLE}"
  local log_url

  # Confirm user wants to begin installing packages
  until yesno "${INSTALL_CONFIRM}" "${YES}" "${NO}" --defaultno; do
    if yesno "${EXIT_CONFIRM}" "${YES}" "${NO}" --defaultno; then
      log "User cancelled installation (errors logged: ${ERRORS_LOGGED})"
      return_to_shell_prompt
    fi
  done

  # Ensure system clock is accurate (if done earlier, annoying messages appear)
  timedatectl set-ntp true

  # Clean and sort base package list
  BASE_PACKAGES="$(tr <<<"${BASE_PACKAGES}" ' ' '\n' | sort | uniq |
    tr '\n' ' ')"
  log "Base package list: ${BASE_PACKAGES}"

  # Update keyring (if out of date)
  log "Updating Arch Linux keyring..."
  dragonsay "Updating Arch Linux keyring..."
  pacman-key --init 2> >(tee -a "${LOG_FILE}")
  while ! pacman -Sy archlinux-keyring --needed --noconfirm \
      2> >(tee -a "${LOG_FILE}") && try_again "Keyring update failed"; do
    continue
  done

  # Begin installation
  log "Installing base packages..."
  dragonsay "Installing base packages..."
  while true; do
    if pacstrap /mnt ${BASE_PACKAGES} 2> >(tee -a "${LOG_FILE}"); then
      log "Base installation completed successfully"
      break
    elif ! try_again "Pacstrap failed"; then
      log "Uplodaing log to termbin... (errors logged: ${ERRORS_LOGGED})"
      log_url="$(nc termbin.com 9999 <"${LOG_FILE}")"
      log "Log uploaded to termbin: ${log_url}"
      message "${PACSTRAP_ERROR_MSG} ${log_url}"
      return_to_shell_prompt
    fi
  done
}

################################################################################
# Configure the freshly-installed GDL system.
#
# Globals: SYSTEM_AUTO_ENCRYPTED, BASE_PACKAGES, UEFI, BOOT_OR_ESP_MNT, DRIVE,
#   BOOT_OR_ESP, BTRFS_MOUNT_OPTIONS, SWAP_SIZE, HOSTNAME, PASSWORD, SSL_KEY,
#   LOCALE, KEYMAP, TIME_ZONE, VM_TYPE, DISPLAY_MANAGER, DESKTOP_ENV
# Arguments: None
################################################################################
configure_system() {
  local pw fstab='/mnt/etc/fstab' grub='/mnt/etc/default/grub' \
    grub_theme='/boot/grub/themes/gdl' extra='/usr/share/gdl/extra'

  log "Configuring system..."
  dragonsay "Configuring system..."

  # Initial fstab config
  genfstab -U /mnt >>"${fstab}" && log "* Generated fstab"

  # GRUB config
  mkdir -p /mnt"${grub_theme}"
  cp -rT "${extra}"/grub /mnt"${grub_theme}"
  if mount | grep -q ' /mnt/boot type [^b]' ||
      (! mount | grep -q ' /mnt/boot ' && ! "${BTRFS_ROOT}"); then
    sed -i 's/GRUB_DEFAULT=0/GRUB_DEFAULT=saved/' "${grub}"
    sed -i 's/#GRUB_SAVEDEFAULT/GRUB_SAVEDEFAULT/' "${grub}"
  fi
  sed -i 's/GRUB_TIMEOUT=5/GRUB_TIMEOUT=3/' "${grub}"
  sed -i "s/GRUB_GFXM.*/GRUB_GFXMODE=1920x1080,1366x768,auto/" "${grub}"
  sed -i "s:#GRUB_COLOR_N.*:GRUB_COLOR_NORMAL=\"red/black\":" "${grub}"
  sed -i "s:#GRUB_COLOR_H.*:GRUB_COLOR_HIGHLIGHT=\"yellow/black\":" "${grub}"
  sed -i "s:#GRUB_THEME.*:GRUB_THEME=\"${grub_theme}/theme.txt\":" "${grub}"
  if "${SYSTEM_AUTO_ENCRYPTED}"; then
    sed -i "s!quiet!cryptdevice=/dev/lvm/lvroot:root:allow-discards \
root=/dev/mapper/root transparent_hugepage=never!" "${grub}"
  else
    sed -i 's/quiet/transparent_hugepage=never/' "${grub}"
  fi
  if grep -q 'nvidia' <<<"${BASE_PACKAGES}"; then
    sed -i '/GRUB_CMDLINE_LINUX_DEFAULT=/s/.$/ nvidia-drm.modeset=1"/;s/" /"/' \
      "${grub}"
  fi
  while true; do
    if "${UEFI}" && arch-chroot /mnt grub-install --target=x86_64-efi \
        --efi-directory="${BOOT_OR_ESP_MNT}" --bootloader-id=GRUB; then
      mkdir /mnt"${BOOT_OR_ESP_MNT}"/EFI/BOOT &&
        cp /mnt"${BOOT_OR_ESP_MNT}"/EFI/GRUB/grubx64.efi \
        /mnt"${BOOT_OR_ESP_MNT}"/EFI/BOOT/bootx64.efi # required in rare cases
      log "* Installed GRUB (UEFI)"
      break
    elif ! "${UEFI}" && arch-chroot /mnt grub-install /dev/"${DRIVE}"; then
      log "* Installed GRUB (BIOS)"
      break
    else
      try_again "GRUB installation failed" || break
    fi
  done

  # NVIDIA GPU config
  if grep -q 'nvidia' <<<"${BASE_PACKAGES}"; then
    sed -i 's/^MODULES=(/&nvidia nvidia_modeset nvidia_uvm nvidia_drm /' \
      /mnt/etc/mkinitcpio.conf
    echo -e 'options nvidia-drm modeset=1\nblacklist nouveau' \
      >/mnt/etc/modprobe.d/nvidia.conf
    sed -i 's:^FILES=(:&/etc/modprobe.d/nvidia.conf :;s/ )/)/' \
      /mnt/etc/mkinitcpio.conf
    mkdir /mnt/etc/pacman.d/hooks
    # https://wiki.archlinux.org/index.php/NVIDIA#Pacman_hook
    echo -e "[Trigger]\nOperation=Install\nOperation=Upgrade\nOperation=Remove\
\nType=Package\nTarget=nvidia\nTarget=linux\n\n[Action]\nDescription=Update \
NVIDIA module in initcpio\nDepends=mkinitcpio\nWhen=PostTransaction\nNeeds\
Targets\nExec=/bin/sh -c 'while read -r trg; do case \$trg in linux) exit 0; \
esac; done; /usr/bin/mkinitcpio -P'\n" >/mnt/etc/pacman.d/hooks/nvidia.hook
    log "* Enabled NVIDIA DRM (Direct Rendering Manager)"
    if lspci | grep 'VGA' | grep -Eq 'Intel|ATI|AMD'; then
      echo 'GAMEMODERUNEXEC=prime-run' >>/mnt/etc/environment
      log "* Configured GameMode to always enable NVIDIA PRIME render offload"
    fi
  fi

  # Btrfs config
  if mount | grep -q 'type btrfs'; then
    sed -i 's/^MODULES=(/&btrfs /;s/ )/)/' /mnt/etc/mkinitcpio.conf &&
      log "* Configured system for Btrfs"
  fi

  # XFS config
  if mount | grep -q 'type xfs'; then
    sed -i 's/^MODULES=(/&xfs /;s/ )/)/' /mnt/etc/mkinitcpio.conf &&
      log "* Configured system for XFS"
  fi

  # NVMe config
  if mount | grep -q 'nvme'; then
    sed -i 's/^MODULES=(/&nvme /;s/ )/)/' /mnt/etc/mkinitcpio.conf &&
      log "* Configured system for NVMe"
  fi

  # Additional fstab, crypttab, and mkinitcpio config
  if "${SYSTEM_AUTO_ENCRYPTED}"; then
    if "${UEFI}"; then
      echo "/dev/${BOOT_OR_ESP} ${BOOT_OR_ESP_MNT} vfat rw,relatime,fmask=0022,\
dmask=0022,codepage=437,iocharset=utf8,shortname=mixed,utf8,errors=remount-ro \
0 2" >"${fstab}"
    else
      echo "/dev/${BOOT_OR_ESP} ${BOOT_OR_ESP_MNT} ext4 defaults 0 2" \
        >"${fstab}"
    fi
    if "${BTRFS_ROOT}"; then
      echo "/dev/mapper/root / btrfs ${BTRFS_MOUNT_OPTIONS},subvol=@ 0 0
/dev/mapper/root /home btrfs ${BTRFS_MOUNT_OPTIONS},subvol=@home 0 0
/dev/mapper/root /var/log btrfs ${BTRFS_MOUNT_OPTIONS},subvol=@var@log 0 0
/dev/mapper/root /var/cache btrfs ${BTRFS_MOUNT_OPTIONS},subvol=@var@cache 0 0"\
        >>"${fstab}"
    else
      echo "/dev/mapper/root / ${FS} defaults 0 1" >>"${fstab}"
    fi
    echo "/dev/mapper/tmp /tmp tmpfs defaults 0 0" >>"${fstab}"
    echo "tmp /dev/lvm/tmp /dev/urandom tmp,cipher=aes-xts-plain64,size=256" \
      >>/mnt/etc/crypttab
    if (( SWAP_SIZE > 0 )); then
      echo "/dev/mapper/swap none swap defaults 0 0" >>"${fstab}"
      echo "swap /dev/lvm/swap /dev/urandom \
swap,cipher=aes-xts-plain64,size=256" >>/mnt/etc/crypttab
    fi
    sed -i "s/^HOOKS=.*/HOOKS=(base udev autodetect keyboard keymap console\
font modconf block encrypt lvm2 filesystems fsck)/" /mnt/etc/mkinitcpio.conf
    log "* Configured system for encryption"
  else # not auto-encrypted
    sed -i "s/^HOOKS=.*/HOOKS=(base udev autodetect keyboard keymap \
consolefont modconf block lvm2 filesystems fsck)/" /mnt/etc/mkinitcpio.conf
  fi
  sed -i 's/	/ /g' "${fstab}" # remove tabs
  sed -i 's/ \+/ /g' "${fstab}" # remove extraneous spaces
  sed -Ei '/btrfs|xfs/s/0 [^0]$/0 0/' "${fstab}" # remove fsck for btrfs/xfs
  while true; do
    if arch-chroot /mnt mkinitcpio -P; then
      log "* Created new initramfs"
      break
    else
      try_again "Failed to create new initramfs" || break
    fi
  done

  # Locale config
  sed -i "/#${LOCALE}/s/#//" /mnt/etc/locale.gen
  sed -i '/#en_US.UTF-8/s/#//' /mnt/etc/locale.gen
  echo "LANG=${LOCALE}" >/mnt/etc/locale.conf
  arch-chroot /mnt locale-gen
  if [[ "${LOCALE}" =~ zh_|yue_|ja_ ]]; then
    sed -i 's/%A, %B %-e, %Y/%Y年%B%-e日/' \
      "${extra}"/lightdm/lightdm-gtk-greeter.conf
    sed -i 's/%-l:%M:%S %p, %A, %B %-e, %Y/%Y年%B%-e日 %A%p%I:%M:%S/' \
      "${extra}"/xfce/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-panel.xml
    sed -i 's/%A, %B %-e/%Y年%B%-e日/' "${extra}"/skel/.config/gdl-config-script
    sed -i 's/clock-show-weekday true/clock-show-weekday false/' \
      "${extra}"/skel/.config/gdl-config-script
  fi
  log "* Set system locale: ${LOCALE}"

  # Keyboard config
  echo "KEYMAP=${KEYMAP}" >/mnt/etc/vconsole.conf
  echo -e "Section \"InputClass\"\nIdentifier \"system-keyboard\"\nMatchIs\
Keyboard \"on\"\nOption \"XkbLayout\" \"${KEYMAP}\"\nEndSection" \
    >/mnt/etc/X11/xorg.conf.d/00-keyboard.conf
  arch-chroot /mnt localectl set-x11-keymap "${KEYMAP}"
  log "* Set system keymap: ${KEYMAP}"

  # Time zone and hardware clock config
  ln -sf /usr/share/zoneinfo/"${TIME_ZONE}" /mnt/etc/localtime &&
    log "* Set system time zone: ${TIME_ZONE}"
  arch-chroot /mnt hwclock --systohc && log "* Generated /etc/adjtime"

  # Here be daemons...
  log "* Configuring systemd services..."

  # VM config
  case "${VM_TYPE}" in
    qemu) enable_service qemu-guest-agent.service ;;
    oracle) enable_service vboxservice.service ;;
    vmware)
      cat /mnt/proc/version >/mnt/etc/arch-release
      enable_service vmtoolsd.service
      enable_service vmware-vmblock-fuse.service
      mkdir -pv /mnt/etc/init.d/rc{0..6}.d
      ;;
  esac

  # Network, firewall, and bluetooth config
  enable_service NetworkManager.service
  arch-chroot /mnt ufw enable
  enable_service ufw.service
  if lsusb | grep -qi 'bluetooth' || dmesg | grep -qi 'bluetooth'; then
    enable_service bluetooth.service
  fi

  # Display manager (login manager) config
  [[ -d /mnt/etc/lightdm ]] && cp -rT "${extra}"/lightdm /mnt/etc/lightdm
  if [[ "${DESKTOP_ENV}" == 'kde-plasma' ]]; then
    mkdir /mnt/etc/sddm.conf.d
    echo -e "[Autologin]\nRelogin=false\nSession=\nUser=\n\n[General]\nHaltComm\
and=/usr/bin/systemctl poweroff\nRebootCommand=/usr/bin/systemctl reboot\n\n[Th\
eme]\nCurrent=breeze\n\n[Users]\nMaximumUid=60513\nMinimumUid=1000" \
      >/mnt/etc/sddm.conf.d/kde_settings.conf
    sed -i "s:background.*:background=/usr/share/backgrounds/gdl/\
gds-drake-dark-1920x1080.jpg:" /mnt/usr/share/sddm/themes/breeze/theme.conf
    [[ -f /mnt/etc/lightdm/lightdm-gtk-greeter.conf ]] &&
      sed -i 's/Matcha-dark-aliz/Breeze-Dark/ ; s/Surfn-Numix/BeautyLine/' \
        /mnt/etc/lightdm/lightdm-gtk-greeter.conf
  fi
  enable_service "${DISPLAY_MANAGER}".service

  # CPU frequency scaling
  enable_service cpupower.service

  # Periodic (weekly) TRIM for any attached drives that support 'discard'
  enable_service fstrim.timer

  # CUPS printing system
  enable_service cups.service

  # Desktop config
  cp -rT "${extra}/${DESKTOP_ENV}" "${extra}"/skel
  case "${DESKTOP_ENV}" in
    kde-plasma)
      arch-chroot /mnt pacman -S appstream --noconfirm # fix Discover issue
      sed -i 's/Opacity=.*/Opacity=0.84/' /mnt/usr/share/konsole/*.colorscheme
      echo 'Opacity=0.84' >>/mnt/usr/share/konsole/Linux.colorscheme
      until curl -o /mnt/install-matchama.sh \
          https://gitlab.com/cscs/matchama-kde/raw/master/install.sh &&
          arch-chroot /mnt bash install-matchama.sh; do
        try_again "Failed to download and install Matchama KDE theme" || break
      done
      rm /mnt/install-matchama.sh
      sed -i 's/Papirus-Maia/BeautyLine/' "/mnt/usr/share/plasma/\
look-and-feel/com.gitlab.cscs.matchama/contents/defaults"
      sed -i 's/Papirus-Dark-Maia/BeautyLine/' "/mnt/usr/share/plasma/\
look-and-feel/com.gitlab.cscs.matchama-dark/contents/defaults"
      ;;
    cinnamon) tar xf "${extra}"/tar/cinnamon.local.tar.xz -C "${extra}"/skel ;;
    xfce) mv "${extra}"/skel/toggle-touchpad /mnt/usr/local/bin ;;
  esac
  if grep -q 'ibus' <<<"${AUR_AND_OPTIONAL_PACKAGES}"; then
    echo -e "export GTK_IM_MODULE=ibus\nexport QT_IM_MODULE=ibus\nexport \
XMODIFIERS=@im=ibus\nibus-daemon -drxR" >>"${extra}"/skel/.xprofile
    if [[ "${DESKTOP_ENV}" == 'kde-plasma' ]]; then
      sed -i 's:-drxR:& --panel=/usr/lib/kimpanel-ibus-panel:' \
        "${extra}"/skel/.xprofile
      echo -e "\n[Containments][2][Applets][25]\nimmutability=1
plugin=org.kde.plasma.kimpanel" \
        >>"${extra}"/skel/.config/plasma-org.kde.plasma.desktop-appletsrc
      sed -i 's/;6;/&25;/' \
        "${extra}"/skel/.config/plasma-org.kde.plasma.desktop-appletsrc
    fi
  fi
  mkdir -p /mnt/usr/share/backgrounds/gdl
  cp -rT "${extra}"/wallpapers /mnt/usr/share/backgrounds/gdl
  cp -rT "${extra}"/icons /mnt/usr/share/pixmaps
  cp -rT "${extra}"/skel /mnt/etc/skel
  sed -i 's/Inherits.*/Inherits=Breeze_Amber/' \
    /mnt/usr/share/icons/default/index.theme
  log "* Configured DE and default user settings"

  # Pacman config
  rm /mnt/var/lib/pacman/db.lck
  sed -i 's/#Color/Color\nILoveCandy/' /mnt/etc/pacman.conf
  sed -i 's/#VerbosePkgLists/VerbosePkgLists/' /mnt/etc/pacman.conf
  sed -i 's/#ParallelDownloads/ParallelDownloads/' /mnt/etc/pacman.conf
  sed -zi 's/#\[multilib]\n#Include/[multilib]\nInclude/' /mnt/etc/pacman.conf
  log "* Configured pacman"

  # Hostname config
  echo "${HOSTNAME}" >/mnt/etc/hostname
  echo -e "127.0.0.1 localhost\n::1 localhost\n127.0.1.1 \
${HOSTNAME}.localdomain ${HOSTNAME}" >>/mnt/etc/hosts
  log "* Set system hostname: ${HOSTNAME}"

  # Root user config
  cp -rT /mnt/etc/skel /mnt/root
  cp -rT "${extra}"/root /mnt/root
  cp "${extra}"/icons/gdl.png /mnt/root/.face
  pw="$(echo "${PASSWORD}" | openssl enc -aes-256-cbc -a -d -salt -pbkdf2 \
    -iter 1000 -pass pass:"${SSL_KEY}")"
  printf "%s\n%s" "${pw}" "${pw}" | arch-chroot /mnt passwd root
  unset pw

  # Decrease swappiness
  echo 'vm.swappiness=10' >/mnt/etc/sysctl.d/99-swappiness.conf

  # Ensure proper MIDI support for certain media players
  ln -s libfluidsynth.so.3 /mnt/usr/lib/libfluidsynth.so.2
  mkdir -p /mnt/usr/share/sounds/sf2
  ln -s /usr/share/soundfonts/FluidR3_GM.sf2 /mnt/usr/share/sounds/sf2/

  # Add a group for GameMode to ensure it can "renice" processes
  arch-chroot /mnt groupadd -g 2000 gamemode
}

################################################################################
# Enable a given systemd service within the newly-installed system.
#
# Globals: None
# Arguments: Name of the desired systemd service.
################################################################################
enable_service() {
  if [[ -n "$1" ]] && arch-chroot /mnt systemctl enable "$1"; then
    log "  - Enabled '$1'"
  else
    log_error "Failed to enable '$1'"
  fi
}

################################################################################
# Install AUR helper 'yay' (yay-bin) and use it to install all AUR/optional
# packages. If any package fails, provide the option to try again (with the
# exception of a few theme packages that GDL can provide manually).
#
# Globals: AUR_AND_OPTIONAL_PACKAGES, LOG_FILE, ERROR
# Arguments: None
################################################################################
install_additional_software() {
  local pw uuid package failed_packages='' packages_to_manually_install=''

  # Create a temporary user for installing and using 'yay' (AUR helper)
  log "Installing AUR helper 'yay' (yay-bin)..."
  dragonsay "Setting up AUR support..."
  pw="$(</dev/urandom tr -dc "@#*%&_A-Z-a-z-0-9" | head -c16)"
  mkdir /mnt/yaytemp
  chmod 777 /mnt/yaytemp
  arch-chroot /mnt useradd -rNM -d /yaytemp -s /usr/bin/nologin yaybuilder
  arch-chroot /mnt sh -c "echo -e '${pw}\n${pw}\n' | passwd yaybuilder"
  echo 'yaybuilder ALL=(ALL:ALL) NOPASSWD: ALL
root ALL=(yaybuilder) NOPASSWD: ALL' >/mnt/etc/sudoers.d/yaybuilder

  # Install 'yay'
  while true; do
    if arch-chroot /mnt sh -c "cd /yaytemp &&
        sudo -u yaybuilder git clone https://aur.archlinux.org/yay-bin.git &&
        cd yay-bin && sudo -u yaybuilder makepkg -si --noconfirm"; then
      log "Installing AUR/optional packages..."
      break
    elif ! try_again "Failed to install AUR helper 'yay'"; then
      packages_to_manually_install="${AUR_AND_OPTIONAL_PACKAGES}"
      AUR_AND_OPTIONAL_PACKAGES=''
      break
    fi
  done

  # Install AUR/optional packages
  while [[ -n "${AUR_AND_OPTIONAL_PACKAGES}" ]]; do
    failed_packages=''
    for package in ${AUR_AND_OPTIONAL_PACKAGES}; do
      log "* Installing '${package}'..."
      dragonsay "Installing ${package}..."
      if ! arch-chroot /mnt sudo -u yaybuilder yay -Syu "${package}" --needed \
          --noconfirm; then
        log_error "Installation of '${package}' failed"
        if [[ "${package}" == 'matcha-gtk-theme' ||
              "${package}" == 'breeze-amber-cursor-theme' ||
              "${package}" == 'xcursor-breeze' ||
              "${package}" == 'beautyline' ]]; then
          packages_to_manually_install+="${package} "
        else
          failed_packages+="${package} "
        fi
      elif [[ "${package}" == 'timeshift' ]]; then
        enable_service cronie.service
        if "${BTRFS_ROOT}"; then
          enable_service grub-btrfs.path
          cp /mnt/etc/timeshift/default.json /mnt/etc/timeshift/timeshift.json
          sed -i 's/"do_first_run" : "true"/"do_first_run" : "false"/' \
            /mnt/etc/timeshift/timeshift.json
          sed -i "s/\"btrfs_mode\" : \"false\",/\"btrfs_mode\" : \"true\",\n  \
\"btrfs_use_qgroup\" : \"true\",\n  \"date_format\" : \"%Y-%m-%d %H:%M:%S\",/" \
            /mnt/etc/timeshift/timeshift.json
          sed -i 's/"schedule_daily" : "false"/"schedule_daily" : "true"/' \
            /mnt/etc/timeshift/timeshift.json
          sed -i 's/"schedule_hourly" : "false"/"schedule_hourly" : "true"/' \
            /mnt/etc/timeshift/timeshift.json
          sed -i 's/"schedule_boot" : "false"/"schedule_boot" : "true"/' \
            /mnt/etc/timeshift/timeshift.json
          if "${SYSTEM_AUTO_ENCRYPTED}"; then
            uuid="$(lsblk -no UUID /dev/lvm/lvroot | tr -d '[:space:]')"
            sed -i "s/t_device_uuid.*/t_device_uuid\" : \"${uuid:0:36}\",/" \
              /mnt/etc/timeshift/timeshift.json
            sed -i "s/p_device_uuid.*/p_device_uuid\" : \"${uuid:36:36}\",/" \
              /mnt/etc/timeshift/timeshift.json
          else
            uuid="$(lsblk -no UUID /dev/${ROOT})"
            sed -i "s/p_device_uuid.*/p_device_uuid\" : \"${uuid}\",/" \
              /mnt/etc/timeshift/timeshift.json
          fi
          if [[ -z "${uuid}" ]]; then
            log_error "Failed to set root device UUID for Timeshift"
          else
            arch-chroot /mnt timeshift --list # to complete timeshift config
          fi
        fi
      elif [[ "${package}" == 'timeshift-autosnap' ]]; then
        sed -i 's/ {created before upgrade}$//' /mnt/etc/timeshift-autosnap.conf
      fi
    done
    if [[ -n "${failed_packages}" ]]; then
      try_again "$(wc -w <<<"${failed_packages}") package(s) failed to \
install: ${failed_packages}" || break
    fi
    AUR_AND_OPTIONAL_PACKAGES="${failed_packages}"
  done

  # Provide missing theme files and log failed packages
  for package in ${packages_to_manually_install}; do
    case "${package}" in
      matcha-gtk-theme)
        tar xf /usr/share/gdl/extra/tar/matcha.tar.xz -C \
          /mnt/usr/share/themes &&
          log "* Matcha dark themes added manually"
        ;;
      breeze-amber-cursor-theme)
        tar xf /usr/share/gdl/extra/tar/breeze-amber.tar.xz -C \
          /mnt/usr/share/icons &&
          log "* Breeze Amber cursor theme added manually"
        ;;
      xcursor-breeze)
        tar xf /usr/share/gdl/extra/tar/breeze.tar.xz -C \
          /mnt/usr/share/icons &&
          log "* Breeze and Breeze Snow cursor themes added manually"
        ;;
      beautyline)
        tar xf /usr/share/gdl/extra/tar/beautyline.tar.xz -C \
          /mnt/usr/share/icons &&
          log "* BeautyLine icons added manually"
        ;;
      *) failed_packages+="${package} " ;;
    esac
  done
  if [[ -n "${failed_packages}" ]]; then
    log "$(wc -w <<<"${failed_packages}") failed package(s): ${failed_packages}"
  else
    log "All packages successfully installed"
  fi

  # Clean things up
  log "Cleaning up..."
  arch-chroot /mnt sudo -u yaybuilder yay -Yc --noconfirm
  arch-chroot /mnt userdel -f yaybuilder
  rm /mnt/etc/passwd- /mnt/etc/sudoers.d/yaybuilder
  rm -r /mnt/yaytemp
  arch-chroot /mnt fc-cache -f # (re)build font information cache files

  # Update GRUB config
  while true; do
    if arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg; then
      log "GRUB configuration updated"
      break
    else
      try_again "Failed to update GRUB configuration" || break
    fi
  done
}

################################################################################
# Add the previously-defined user to the newly-installed system.
#
# Globals: FULL_NAME, USERNAME, PASSWORD, SSL_KEY, BASE_PACKAGES
# Arguments: None
# Outputs: Number of errors detected.
################################################################################
add_user() {
  local pw

  dragonsay "Adding user '${USERNAME}'..."
  if [[ -z "${FULL_NAME}" ]] && ! arch-chroot /mnt useradd -mG \
      audio,network,power,storage,optical,gamemode -s /bin/bash \
      "${USERNAME}"; then
    log_error "Failed to add user '${USERNAME}'"
    return 1
  elif [[ -n "${FULL_NAME}" ]] && ! arch-chroot /mnt useradd -mG \
      audio,network,power,storage,optical,gamemode -c "${FULL_NAME}" -s \
      /bin/bash "${USERNAME}"; then
    log_error "Failed to add user '${USERNAME}' (${FULL_NAME})"
    return 1
  fi
  pw="$(echo "${PASSWORD}" | openssl enc -aes-256-cbc -a -d -salt -pbkdf2 \
    -iter 1000 -pass pass:"${SSL_KEY}")"
  if ! printf "%s\n%s" "${pw}" "${pw}" |
      arch-chroot /mnt passwd "${USERNAME}"; then
    unset pw
    log_error "Failed to set password for user '${USERNAME}'"
    return 1
  fi
  unset pw
  sed -i '/%wheel ALL=(ALL:ALL) ALL/s/^# //' /mnt/etc/sudoers
  arch-chroot /mnt usermod -aG wheel "${USERNAME}"

  # Provide default user image
  cp /mnt/etc/skel/.face /mnt/var/lib/AccountsService/icons/"${USERNAME}"
  echo -e "[User]\nIcon=/var/lib/AccountsService/icons/${USERNAME}
SystemAccount=false" >/mnt/var/lib/AccountsService/users/"${USERNAME}"

  log "User added: ${USERNAME}"
}

################################################################################
# Custom 'dialog' function. Unless extraneous text should be reduced, a
# backtitle is included which may also show remaining battery capacity. Output
# is directed to STDOUT ('dialog' defaults to STDERR otherwise).
#
# Globals: TITLE, BACKTITLE, DEFAULT_BACKTITLE, BATTERY, REDUCE_EXTRANEOUS_TEXT
# Arguments: The desired text plus additional 'dialog' options.
################################################################################
dialog() {
  sleep 0.1 # to help avoid accidental keyboard input carryover
  if "${REDUCE_EXTRANEOUS_TEXT}"; then
    /usr/bin/dialog --stdout --colors --title " ${TITLE} " "$@"
  else
    BACKTITLE="${DEFAULT_BACKTITLE}"
    if [[ -n "${BATTERY}" ]]; then
      BACKTITLE+=" | Battery: $(cat "${BATTERY}"/capacity)%"
    fi
    /usr/bin/dialog --stdout --colors --backtitle "${BACKTITLE}" --title \
      " ${TITLE} " "$@"
  fi
}

################################################################################
# Present a message in an 'ok' dialog box.
#
# Globals: OK
# Arguments: The desired message text.
################################################################################
message() {
  dialog --ok-button "${OK}" --msgbox "\n$1" 0 0
}

################################################################################
# Present a message in a 'yes/no' dialog box.
#
# Globals: None
# Arguments: The desired body text plus 'yes' and 'no' button texts. If a fourth
#   argument is provided, the dialog box will use '--defaultno'.
################################################################################
yesno() {
  local body="$1" yes_button="$2" no_button="$3"

  if (( $# == 4 )); then
    dialog --defaultno --yes-label "${yes_button}" --no-label "${no_button}" \
      --yesno "\n${body}" 0 0
  else
    dialog --yes-label "${yes_button}" --no-label "${no_button}" \
      --yesno "\n${body}" 0 0
  fi

  return $?
}

################################################################################
# Present a dialog box with a "gauge" (loading bar) that gradually fills up as
# background processes are completed.
#
# Globals: None
# Arguments: The desired text to display above the loading bar.
################################################################################
load_bar() {
  {
    local -i progress=1

    # shellcheck disable=SC2009
    while [[ -n $! ]] && ps | grep -q $!; do
      sleep 0.1
      echo "${progress}"
      if (( progress < 100 )); then
        (( ++progress ))
      fi
    done
    echo 100
    sleep 0.6 # provide a bit more time for reading text before moving on
  } | dialog --gauge "\n$1" 9 79 0
}

################################################################################
# Present (and log) a given error message and prompt the user to choose whether
# to attempt the task again. This is used in "emergencies" during installation,
# such as when a package fails to install (internet issues, etc.).
#
# Globals: BOLD_RED, WHITE, COLOR_RESET
# Arguments: A description of the error.
# Outputs: Returns '0' if the user wants to try again, '1' otherwise.
################################################################################
try_again() {
  local try

  log_error "$1"
  echo -e "${BOLD_RED}ERROR: ${WHITE}$1${COLOR_RESET}"
  while true; do
    echo -en "Try again? (y/n) " && read -r try
    if [[ "${try}" =~ ^[Yy] ]]; then
      log "Trying again..."
      return 0
    elif [[ "${try}" =~ ^[Nn] ]]; then
      log "Giving up..."
      return 1
    fi
  done
}

################################################################################
# Present a message as if spoken by an ASCII dragon via 'cowsay' (or simply echo
# the message if extraneous text should be reduced).
#
# Globals: REDUCE_EXTRANEOUS_TEXT, ERRORS_LOGGED
# Arguments: The text to be presented. A second argument of '--check-errors'
#   compels the dragon to attack an ASCII cow if errors have been detected.
################################################################################
dragonsay() {
  sleep 0.6 # provide a bit more time for reading previous text
  clear
  if "${REDUCE_EXTRANEOUS_TEXT}"; then
    echo -e "$1\n"
  elif [[ "$2" == '--check-errors' ]] && (( ERRORS_LOGGED > 0 )); then
    cowsay -f dragon-and-cow "$1"
  else
    cowsay -f dragon "$1"
  fi
  sleep 0.6 # provide a bit more time for reading current text
}

################################################################################
# Append a given string (or stdin) to the log file.
#
# Globals: LOG_FILE
# Arguments: A string of text (or piped command output).
################################################################################
log() {
  local output

  if [[ -n "$1" ]]; then # manual logging
    echo "[$(date '+%H:%M:%S')]: $1" >>"${LOG_FILE}"
  else # stdin
    echo >>"${LOG_FILE}"
    while read -r output; do
      echo "${output}" >>"${LOG_FILE}"
    done
    echo >>"${LOG_FILE}"
  fi
}

################################################################################
# Append custom 'lsblk' output to the log file.
#
# Globals: None
# Arguments: None
################################################################################
log_lsblk() {
  lsblk -o NAME,SIZE,TYPE,MOUNTPOINTS,FSTYPE,FSVER,FSUSE% |
    grep -v '/run/archiso/' | log
}

################################################################################
# Append an error message to the log file and increment the error tally.
#
# Globals: ERRORS_LOGGED
# Arguments: A string containing a description of the error.
################################################################################
log_error() {
  log "ERROR: $1"
  (( ++ERRORS_LOGGED ))
}

################################################################################
# Facilitate the installation of Golden Drake Linux.
#
# Globals: ABOUT_GDL_TITLE, ABOUT_GDL_MSG, OK, INSTALL_COMPLETE_MSG,
#   INSTALL_COMPLETE_HELP, LOG_FILE, ERRORS_LOGGED
# Arguments: None
# Outputs: Number of errors logged during this run of the installer. (The log
#   file is also copied to the new system's '/root' directory.)
################################################################################
main() {
  initialize
  set_installer_language
  set_keymap
  TITLE="${ABOUT_GDL_TITLE}"
  dialog --ok-button "${OK}" --msgbox "\n${ABOUT_GDL_MSG}" 23 80
  check_internet_connection
  set_locale
  set_time_zone
  prepare_drives
  set_hostname
  set_user
  prepare_base
  select_additional_software
  install_base
  configure_system
  install_additional_software
  add_user
  log "GDL installation complete (errors logged: ${ERRORS_LOGGED})"
  arch-chroot /mnt df -Th | log
  cp "${LOG_FILE}" /mnt/root
  dragonsay "${INSTALL_COMPLETE_MSG}"
  echo -e "${INSTALL_COMPLETE_HELP}"

  return "${ERRORS_LOGGED}"
}

main
