#!/bin/bash
#
# Golden Drake Linux (GDL): an Arch installer for gamers and game developers!
# Copyright (C) 2020-2021 Golden Drake Studios: goldendrakestudios.com
# Forked originally from the Anarchy installer: anarchyinstaller.gitlab.io

source libgdl.sh
source /etc/gdl.conf
source "${LANG_FILE}"

initialize() {
  if [ "$(id -u)" -ne 0 ]; then
    dragonsay "Sorry, human: gdl requires root privileges (e.g., sudo)."
    exit 1
  elif [ ! -f "${LOG_FILE}" ]; then
    # First (automatic) launch of the installer; create log file
    touch "${LOG_FILE}"
    # Customize the installer's pacman.conf
    sed -i 's/^#Color$/Color/' /etc/pacman.conf
    sed -i 's/^#CheckSpace$/CheckSpace/' /etc/pacman.conf
    sed -i '/^#VerbosePkgLists$/ a ILoveCandy' /etc/pacman.conf
    sed -i '/\[multilib]$/ {
      N
      /Include/s/#//g}' /etc/pacman.conf
    clear
    # Welcome the user, then exit to command prompt so they can run other
    # commands (if desired) before jumping into the installation process
    dragonsay "${intro_msg}"
    echo -e "${shell_prompt_msg2}"
    exit
  fi
  log "Initializing installer"
  trap force_quit SIGINT # Execute trap when Ctrl+C is pressed (SIGINT)
  systemctl start NetworkManager.service
  for library in /usr/lib/gdl/*; do
    source "${library}"
  done
}

set_language() {
  op_title="Language Selection"
  local language
  language="$(dialog --stdout --no-cancel --menu "\n${set_language_msg}" \
    20 60 10 \
    "English" "-" \
    "Bulgarian" "Български" \
    "Dutch" "Nederlands" \
    "French" "Français" \
    "German" "Deutsch" \
    "Greek" "Greek" \
    "Hungarian" "Magyar" \
    "Indonesian" "bahasa Indonesia" \
    "Italian" "Italiano" \
    "Latvian" "Latviešu" \
    "Lithuanian" "Lietuvių" \
    "Polish" "Polski" \
    "Portuguese" "Português" \
    "Portuguese-Brazilian" "Português do Brasil" \
    "Romanian" "Română" \
    "Russian" "Russian" \
    "Spanish" "Español" \
    "Swedish" "Svenska")"
  case "${language}" in
  "English")
    LANG_FILE="${GDL_DIR}/lang/english.conf" ;;
  "Bulgarian")
    LANG_FILE="${GDL_DIR}/lang/bulgarian.conf" lib='bg' bro='bg' ;;
  "Dutch")
    LANG_FILE="${GDL_DIR}/lang/dutch.conf" lib='nl' bro='nl' ;;
  "French")
    LANG_FILE="${GDL_DIR}/lang/french.conf" lib='fr' bro='fr' ;;
  "German")
    LANG_FILE="${GDL_DIR}/lang/german.conf" lib='de' bro='de' ;;
  "Greek")
    LANG_FILE="${GDL_DIR}/lang/greek.conf" lib='el' bro='el' ;;
  "Hungarian")
    LANG_FILE="${GDL_DIR}/lang/hungarian.conf" lib='hu' bro='hu' ;;
  "Indonesian")
    LANG_FILE="${GDL_DIR}/lang/indonesia.conf" lib='id' bro='id' ;;
  "Italian")
    LANG_FILE="${GDL_DIR}/lang/italian.conf" lib='it' bro='it' ;;
  "Latvian")
    LANG_FILE="${GDL_DIR}/lang/latvian.conf" lib='lv' bro='lv' ;;
  "Lithuanian")
    LANG_FILE="${GDL_DIR}/lang/lithuanian.conf" lib='lt' bro='lt' ;;
  "Polish")
    LANG_FILE="${GDL_DIR}/lang/polish.conf" lib='pl' bro='pl' ;;
  "Portuguese")
    LANG_FILE="${GDL_DIR}/lang/portuguese.conf" lib='pt' bro='pt-pt' ;;
  "Portuguese-Brazilian")
    LANG_FILE="${GDL_DIR}/lang/portuguese-br.conf" lib='pt-br' bro='pt-br' ;;
  "Romanian")
    LANG_FILE="${GDL_DIR}/lang/romanian.conf" lib='ro' bro='ro' ;;
  "Russian")
    LANG_FILE="${GDL_DIR}/lang/russian.conf" lib='ru' bro='ru' ;;
  "Spanish")
    LANG_FILE="${GDL_DIR}/lang/spanish.conf" lib='es' bro='es-es' ;;
  "Swedish")
    LANG_FILE="${GDL_DIR}/lang/swedish.conf" lib='sv' bro='sv-se' ;;
  esac
  source "${LANG_FILE}"
  RELOAD='true'
  log "Set language to: ${language}"
}

set_keyboard_layout() {
  op_title="${key_op_msg}"
  while (true); do
    keyboard="$(dialog --stdout --no-cancel --ok-button "${ok}" \
      --menu "\n${keys_msg}" 18 60 10 \
      "us" "United States" \
      "uk" "United Kingdom" \
      "sv" "Swedish" \
      "slovene" "Slovenian" \
      "ru" "Russian" \
      "ro" "Romanian" \
      "pt-latin9" "Portugal" \
      "it" "Italian" \
      "hu" "Hungarian" \
      "fr" "French" \
      "es" "Spanish" \
      "el" "Greek" \
      "de" "German" \
      "${other}" "${other}-keymaps")"
    source "${LANG_FILE}"
    if [ "${keyboard}" = "${other}" ]; then
      keyboard="$(dialog --stdout --ok-button "${ok}" --cancel-button \
        "${cancel}" --menu "\n${keys_msg}" 19 60 10 ${key_maps})"
      if [ "$?" -eq 0 ]; then
        break
      fi
    else
      break
    fi
  done
  localectl set-keymap "${keyboard}"
  loadkeys "${keyboard}"
  log "Set keymap to: ${keyboard}"
}

update_mirrors() {
  check_connection
  op_title="${mirror_op_msg}"
  local edit_mirrors
  edit_mirrors="$(dialog --stdout --no-cancel --ok-button "${ok}" \
    --menu "\n${mirror_msg0}" 12 60 3 \
    "${cancel_mirrors}" "->" \
    "${update_mirrors_msg}" "->" \
    "${manual_mirrors}" "->")"
  case "${edit_mirrors}" in
  "${update_mirrors_msg}") # update mirrors automatically via reflector
    clear
    dragonsay "Updating mirrors..." |& tee -a "${LOG_FILE}"
    reflector --verbose --latest 20 --sort rate --save /etc/pacman.d/mirrorlist
    ;;
  "${manual_mirrors}") # update mirrors manually via text editor
    local editor
    if editor="$(dialog --stdout --ok-button "${ok}" \
        --menu "\n${mirror_editor_msg}" 12 60 3 \
        "nano" "${nano_msg}" \
        "vim" "${vim_msg}" \
        "${cancel}" "->")" && [ "${editor}" != "${cancel}" ]; then
      "${editor}" /etc/pacman.d/mirrorlist
    fi
    ;;
  esac
}

set_locale() {
  op_title="${locale_op_msg}"
  while (true); do
    LOCALE="$(dialog --stdout --no-cancel --ok-button "${ok}" \
      --menu "\n${locale_msg}" 18 60 11 \
      "de_DE.UTF-8" "German" \
      "el_GR.UTF-8" "Greek" \
      "en_AU.UTF-8" "English (Australia)" \
      "en_CA.UTF-8" "English (Canada)" \
      "en_GB.UTF-8" "English (UK)" \
      "en_US.UTF-8" "English (US)" \
      "es_ES.UTF-8" "Spanish (Spain)" \
      "es_MX.UTF-8" "Spanish (Mexico)" \
      "fr_FR.UTF-8" "French" \
      "hu_HU.UTF-8" "Hungarian" \
      "it_IT.UTF-8" "Italian" \
      "lv_LV.UTF-8" "Latvian" \
      "pt_BR.UTF-8" "Portuguese (Brazil)" \
      "pt_PT.UTF-8" "Portuguese (Portugal)" \
      "ro_RO.UTF-8" "Romanian" \
      "ru_RU.UTF-8" "Russian" \
      "sv_SE.UTF-8" "Swedish" \
      "${other}" "${other}-locale")"
    if [ "${LOCALE}" = "${other}" ]; then
      LOCALE="$(dialog --stdout --ok-button "${ok}" --cancel-button "${cancel}"\
        --menu "\n${locale_msg}" 18 60 11 ${localelist})"
      if [ "$?" -eq "0" ]; then
        break
      fi
    else
      break
    fi
  done
  log "Set locale to: ${LOCALE}"
}

set_zone() {
  op_title="${zone_op_msg}"
  while (true); do
    ZONE="$(dialog --stdout --no-cancel --ok-button "${ok}" \
      --menu "\n${zone_msg0}" 18 60 11 ${zonelist})"
    if (find /usr/share/zoneinfo -maxdepth 1 -type d | sed -n -e 's!^.*/!!p' |
        grep "${ZONE}" &>/dev/null); then
      sublist="$(find /usr/share/zoneinfo/"${ZONE}" -maxdepth 1 |
        sed -n -e 's!^.*/!!p' | sort | sed 's/$/ -/g' | grep -v "${ZONE}")"
      SUBZONE="$(dialog --stdout --ok-button "${ok}" --cancel-button "${back}" \
        --menu "\n${zone_msg1}" 18 60 11 ${sublist})"
      if [ "$?" -eq "0" ]; then
        if (find /usr/share/zoneinfo/"${ZONE}" -maxdepth 1 -type d |
            sed -n -e 's!^.*/!!p' | grep "${SUBZONE}" &>/dev/null); then
          sublist="$(find /usr/share/zoneinfo/"${ZONE}"/"${SUBZONE}" \
            -maxdepth 1 | sed -n -e 's!^.*/!!p' | sort | sed 's/$/ -/g' |
            grep -v "${SUBZONE}")"
          SUB_SUBZONE="$(dialog --stdout --ok-button "${ok}" --cancel-button \
            "${back}" --menu "\n${zone_msg1}" 15 60 7 ${sublist})"
          if [ "$?" -eq "0" ]; then
            ZONE="${ZONE}/${SUBZONE}/${SUB_SUBZONE}"
            break
          fi
        else
          ZONE="${ZONE}/${SUBZONE}"
          break
        fi
      fi
    else
      break
    fi
  done
  log "Set time zone to: ${ZONE}"
}

prepare_drives() {
  op_title="${part_op_msg}"
  log "Block devices before 'prepare_drives':"
  lsblk | log
  if (df | grep /mnt &>/dev/null); then
    umount -R /mnt |& log
  fi
  until "${MOUNTED}"; do
    PART=$(dialog --stdout --no-cancel --ok-button "${ok}" --menu \
      "\n${part_msg}" 15 64 4 \
      "${method_auto}" "-" \
      "${method_auto_encrypt}" "-" \
      "${method_manual}" "-")
    if [ "$?" -gt "0" ]; then
      continue
    elif [ "${PART}" != "${method_manual}" ]; then
      dev_menu="              Device    Size    Type"
      if "${SCREEN_HEIGHT_SUFFICIENT}"; then
        echo "dialog --colors --backtitle \"${backtitle}\" --title \" ${title} \
\" --ok-button \"${ok}\" --cancel-button \"${cancel}\" --stdout --menu \
\"\n${drive_msg}\n\n ${dev_menu}\" 16 60 5 \\" >"${tmp_menu}"
      else
        echo "dialog --stdout --colors --title \" ${title} \" --ok-button \
\"${ok}\" --cancel-button \"${cancel}\" --menu \"\n${drive_msg}\n\n \
${dev_menu}\" 16 60 5 \\" >"${tmp_menu}"
      fi
      lsblk -nio NAME,SIZE,TYPE | grep -E "disk|raid[0-9]+$" |
        sed 's/[^[:alnum:]_., ]//g' | column -t | sort -k 1,1 | uniq |
        awk '{print "\""$1"\"""  ""\"| "$2" | "$3"     \""" \\"}' |
        column -t >>"${tmp_menu}"
      DRIVE=$(bash "${tmp_menu}")
      rm "${tmp_menu}"
      if [ -n "${DRIVE}" ]; then
        if (grep <<<"${DRIVE}" -E "nvme.*|mmc.*|md.*" &>/dev/null); then
          PART_PREFIX="p"
        fi
        drive_byte=$(lsblk -nibo NAME,SIZE | grep -w "${DRIVE}" |
          awk '{print $2}')
        drive_mib=$((drive_byte / 1024 / 1024))
        drive_gigs=$((drive_mib / 1024))
        log "Drive size in MiB: ${drive_mib}"
        fs_select
        if (efivar -l &>/dev/null); then
          if (yesno "${efi_msg0}" "${yes}" "${no}"); then
            GPT='true'
            UEFI='true'
            log "UEFI boot activated"
          fi
        fi
        if ! "${UEFI}"; then
          if (yesno "${gpt_msg}" "${yes}" "${no}" 1); then
            GPT='true'
            log "GPT partition scheme activated"
          fi
        fi
        source "${LANG_FILE}"
        if "${UEFI}"; then
          drive_var="${drive_var3}"
        fi
        if (yesno "${drive_var}" "${write}" "${cancel}" 1); then
          sgdisk --zap-all /dev/"${DRIVE}" |& log
          wipefs -a /dev/"${DRIVE}" |& log
          log "Device formatted: /dev/${DRIVE}"
        else
          unset PART
        fi
      else
        continue
      fi
    fi
    case "${PART}" in
    "${method_auto}")
      auto_part
      if ! "${MOUNTED}"; then
        message "${part_err_msg}"
      fi
      ;;
    "${method_auto_encrypt}")
      auto_encrypt
      if ! "${MOUNTED}"; then
        message "${part_err_msg}"
      fi
      ;;
    "${method_manual}")
      points=$(echo -e "${points_orig}\n${custom} ${custom}-mountpoint")
      part_menu
      ;;
    esac
  done
  log "Block devices after 'prepare_drives':"
  lsblk | log
}

auto_part() {
  op_title="${partload_op_msg}"
  clear
  if "${GPT}"; then
    if "${UEFI}"; then
      echo -e "n\n\n\n512M\nef00\nn\n\n\n\n\nw\ny" | gdisk /dev/"${DRIVE}" |&
        tee -a "${LOG_FILE}"
      BOOT="${DRIVE}${PART_PREFIX}1"
      ROOT="${DRIVE}${PART_PREFIX}2"
    else
      echo -e "o\ny\nn\n1\n\n+212M\n\nn\n2\n\n+1M\nEF02\nn\n3\n\n\n\nw\ny" |
        gdisk /dev/"${DRIVE}" |& tee -a "${LOG_FILE}"
      BOOT="${DRIVE}${PART_PREFIX}1"
      ROOT="${DRIVE}${PART_PREFIX}3"
    fi
  else
    echo -e "o\nn\np\n1\n\n+212M\nn\np\n2\n\n\nw" | fdisk /dev/"${DRIVE}" |&
      tee -a "${LOG_FILE}"
    BOOT="${DRIVE}${PART_PREFIX}1"
    ROOT="${DRIVE}${PART_PREFIX}2"
  fi
  log "Created boot partition: ${BOOT}"
  log "Created root partition: ${ROOT}"
  if "${UEFI}"; then
    sgdisk --zap-all /dev/"${BOOT}" |& tee -a "${LOG_FILE}"
    wipefs -a /dev/"${BOOT}" |& tee -a "${LOG_FILE}"
    mkfs.vfat -F32 /dev/"${BOOT}" |& tee -a "${LOG_FILE}"
    esp_part="${BOOT}"
    esp_mnt='/boot'
    log "ESP partition set to: ${esp_part}"
    log "ESP mount point set to: ${esp_mnt}"
    log "Created boot filesystem: vfat"
  else
    sgdisk --zap-all /dev/"${BOOT}" |& tee -a "${LOG_FILE}"
    wipefs -a /dev/"${BOOT}" |& tee -a "${LOG_FILE}"
    mkfs.ext4 -O \^64bit /dev/"${BOOT}" |& tee -a "${LOG_FILE}"
    log "Boot mount point set to: /boot"
    log "Created boot filesystem: ext4"
  fi
  sgdisk --zap-all /dev/"${ROOT}" |& tee -a "${LOG_FILE}"
  wipefs -a /dev/"${ROOT}" |& tee -a "${LOG_FILE}"
  mkfs."${FS}" /dev/"${ROOT}" |& tee -a "${LOG_FILE}"
  log "Created root filesystem: ${FS}"
  mount /dev/"${ROOT}" /mnt |& tee -a "${LOG_FILE}"
  if [ "$?" -eq "0" ]; then
    log "Root filesystem mounted at /mnt"
    mkdir /mnt/boot |& tee -a "${LOG_FILE}"
    mount /dev/"${BOOT}" /mnt/boot |& tee -a "${LOG_FILE}"
    if [ "$?" -eq "0" ]; then
      log "Boot filesystem mounted at /mnt/boot"
      MOUNTED='true'
    else
      log "ERROR: Mounting /dev/${BOOT} at /mnt/boot failed in 'auto_part'"
      lsblk | log
    fi
  else
    log "ERROR: Mounting /dev/${ROOT} at /mnt failed in 'auto_part'"
    lsblk | log
  fi
  sleep 2
}

auto_encrypt() {
  op_title="${partload_op_msg}"
  local input='a' input_check='b'
  if (yesno "${encrypt_var0}" "${yes}" "${no}" 1); then
    while [ "${input}" != "${input_check}" ]; do
      input=$(dialog --stdout --no-cancel --clear --insecure --passwordbox \
        "\n${encrypt_var1}" 12 55)
      input_check=$(dialog --stdout --no-cancel --clear --insecure \
        --passwordbox "\n${encrypt_var2}" 12 55)
      if [ -z "${input}" ]; then
        message "${passwd_msg0}"
        input_check="check"
      elif [ "${input}" != "${input_check}" ]; then
        message "${passwd_msg1}"
      fi
    done
  else
    return
  fi
  clear
  if "${GPT}"; then
    if "${UEFI}"; then
      echo -e "n\n\n\n512M\nef00\nn\n\n\n\n\nw\ny" | gdisk /dev/"${DRIVE}" |&
        tee -a "${LOG_FILE}"
      BOOT="${DRIVE}${PART_PREFIX}1"
      ROOT="${DRIVE}${PART_PREFIX}2"
    else
      echo -e "o\ny\nn\n1\n\n+512M\n\nn\n2\n\n+1M\nEF02\nn\n3\n\n\n\nw\ny" |
        gdisk /dev/"${DRIVE}" |& tee -a "${LOG_FILE}"
      BOOT="${DRIVE}${PART_PREFIX}1"
      ROOT="${DRIVE}${PART_PREFIX}3"
    fi
  else
    echo -e "o\nn\np\n1\n\n+512M\nn\np\n2\n\n\nw" | fdisk /dev/"${DRIVE}" |&
      tee -a "${LOG_FILE}"
    BOOT="${DRIVE}${PART_PREFIX}1"
    ROOT="${DRIVE}${PART_PREFIX}2"
  fi
  log "Created boot partition: ${BOOT}"
  log "Created root partition: ${ROOT}"
  sgdisk --zap-all /dev/"${ROOT}" |& tee -a "${LOG_FILE}"
  sgdisk --zap-all /dev/"${BOOT}" |& tee -a "${LOG_FILE}"
  wipefs -a /dev/"${ROOT}" |& tee -a "${LOG_FILE}"
  wipefs -a /dev/"${BOOT}" |& tee -a "${LOG_FILE}"
  log "Wiped boot partition"
  log "Wiped root partition"
  lvm pvcreate /dev/"${ROOT}" |& tee -a "${LOG_FILE}"
  lvm vgcreate lvm /dev/"${ROOT}" |& tee -a "${LOG_FILE}"
  log "Created physical root volume: /dev/${ROOT}"
  lvm lvcreate -L 500M -n tmp lvm |& tee -a "${LOG_FILE}"
  lvm lvcreate -l 100%FREE -n lvroot lvm |& tee -a "${LOG_FILE}"
  log "Created logical root volume: lvroot"
  log "Created logical tmp filesystem: tmp"
  printf "%s" "${input}" |
    cryptsetup luksFormat -c aes-xts-plain64 -s 512 /dev/lvm/lvroot - |&
    tee -a "${LOG_FILE}"
  printf "%s" "${input}" | cryptsetup open --type luks /dev/lvm/lvroot root - |&
    tee -a "${LOG_FILE}"
  log "Encrypted logical volume: lvroot"
  unset input input_check
  wipefs -a /dev/mapper/root |& tee -a "${LOG_FILE}"
  mkfs."${FS}" /dev/mapper/root |& tee -a "${LOG_FILE}"
  log "Created root filesystem: ${FS}"
  if "${UEFI}"; then
    mkfs.vfat -F32 /dev/"${BOOT}" |& tee -a "${LOG_FILE}"
    esp_part="/dev/${BOOT}"
    esp_mnt='/boot'
    log "Created boot filesystem: vfat"
  else
    mkfs.ext4 -O \^64bit /dev/"${BOOT}" |& tee -a "${LOG_FILE}"
    log "Created boot filesystem: ext4"
  fi
  mount /dev/mapper/root /mnt |& tee -a "${LOG_FILE}"
  if [ "$?" -eq "0" ]; then
    log "Mounted root filesystem: /mnt"
    mkdir /mnt/boot |& tee -a "${LOG_FILE}"
    mount /dev/"${BOOT}" /mnt/boot |& tee -a "${LOG_FILE}"
    if [ "$?" -eq "0" ]; then
      log "Mounted boot filesystem: /mnt/boot"
      MOUNTED='true'
      ENCRYPTED='true'
    else
      log "ERROR: Mounting /dev/${BOOT} at /mnt/boot failed in 'auto_encrypt'"
      lsblk | log
    fi
  else
    log "ERROR: Mounting /dev/mapper/root at /mnt failed in 'auto_encrypt'"
    lsblk | log
  fi
  sleep 2
}

part_menu() {
  op_title="${manual_op_msg}"
  unset part
  dev_menu="     Device  Size   Used   FS   Mount  Type"
  device_list=$(lsblk -no NAME,SIZE,TYPE,FSTYPE |
    grep -Ev "${USB}|loop[0-9]+|sr[0-9]+|fd[0-9]+" |
    sed 's/[^[:alnum:]_., -]//g' | column -t | sort -k 1,1 | uniq)
  device_count=$(wc <<<"${device_list}" -l)
  if "${SCREEN_HEIGHT_SUFFICIENT}"; then
    echo "dialog --stdout --extra-button --extra-label \"${write}\" --colors \
--backtitle \"${backtitle}\" --title \" ${op_title} \" --ok-button \"${edit}\" \
--cancel-button \"${cancel}\" --menu \"\n${manual_part_msg}\n\n ${dev_menu}\" \
21 68 9 \\" >"${tmp_menu}"
  else
    echo "dialog --stdout --extra-button --extra-label \"${write}\" --colors \
--title \" ${title} \" --ok-button \"${edit}\" --cancel-button \"${cancel}\" \
--menu \"\n${manual_part_msg}\n\n ${dev_menu}\" 20 68 8 \\" >"${tmp_menu}"
  fi
  int=1
  empty_value="----"
  until [ "${int}" -gt "${device_count}" ]; do
    device=$(awk <<<"${device_list}" '{print $1}' | awk "NR==${int}")
    dev_size=$(grep <<<"${device_list}" -w "${device}" | awk '{print $2}')
    dev_type=$(grep <<<"${device_list}" -w "${device}" | awk '{print $3}')
    dev_fs=$(grep <<<"${device_list}" -w "${device}" | awk '{print $4}')
    dev_mnt=$(df | grep -w "${device}" | awk '{print $6}' | sed 's/mnt\/\?//')
    if (grep <<<"${dev_mnt}" "/" &>/dev/null); then
      dev_used=$(df -T | grep -w "${device}" | awk '{print $6}')
    fi
    test -z "${dev_fs}" || test "${dev_fs}" = "linux_raid_member" &&
      dev_fs=${empty_value}
    test -z "${dev_used}" && dev_used=${empty_value}
    test -z "${dev_mnt}" && dev_mnt=${empty_value}
    parent_device=$(lsblk -dnro PKNAME /dev/"${device/-//}")
    if [ -z "${parent_device}" ]; then
      dev_type=$(grep <<<"${device_list}" -w "${device}" | awk '{print $3}')
    else
      dev_type=$(fdisk -lo Device,Type /dev/"${parent_device}" |
        grep -w "${device}" | cut -d ' ' -f 2- |
        sed -e 's/^[[:space:]]*//;s/[[:space:]]*$//;s/ /_/g')
    fi
    echo "\"${device}\" \"${dev_size} ${dev_used} ${dev_fs} ${dev_mnt} \
${dev_type}\" \\" >>"${tmp_list}"
    int=$((int + 1))
  done
  column <"${tmp_list}" -t >>"${tmp_menu}"
  echo "\"${done_msg}\" \"${write}\"" >>"${tmp_menu}"
  echo "if [ \"\$?\" -eq \"3\" ]; then clear ; echo \"${done_msg}\" ; fi" \
    >>"${tmp_menu}"
  part=$(bash "${tmp_menu}" | sed 's/^\s\+//g;s/\s\+$//g')
  if (grep <<<"${part}" "${done_msg}" &>/dev/null); then
    part="${done_msg}"
  fi
  rm "${tmp_menu}" "${tmp_list}"
  part_class
}

part_class() {
  op_title="${edit_op_msg}"
  if [ -z "${part}" ]; then
    unset DRIVE ROOT
    return
  else
    part_size=$(grep <<<"${device_list}" -w "${part}" | awk '{print $2}')
    part_type=$(grep <<<"${device_list}" -w "${part}" | awk '{print $3}')
    part_fs=$(grep <<<"${device_list}" -w "${part}" | awk '{print $4}')
    part_mount=$(df | grep -w "${part}" | awk '{print $6}' | sed 's/mnt\/\?//')
  fi
  if [ "${part_type}" = "lvm" ]; then
    part=${part/-//}
  fi
  if [ "${part_fs}" = "linux_raid_member" ]; then # do nothing
    part_menu
  elif [ "${part_type}" = "disk" ] ||
      ( (grep -E "raid[0-9]+" <<<"${part_type}" &>/dev/null) &&
      [ -z "${part_fs}" ]); then # facilitate disk partitioning
    source "${LANG_FILE}"
    if (df | grep -w "${part}" | grep /mnt &>/dev/null); then
      if (yesno "${mount_warn_var}" "${edit}" "${cancel}" 1); then
        points=$(echo -e "${points_orig}\n${custom} ${custom}-mountpoint")
        umount -R /mnt |& log
        MOUNTED='false'
        unset DRIVE
        select_util
        clear
        ${UTIL} /dev/"${part}"
        clear
      fi
    elif (yesno "${manual_part_var3}" "${edit}" "${cancel}"); then
      select_util
      clear
      ${UTIL} /dev/"${part}"
      clear
    fi
    part_menu
  elif [ "${part}" = "${done_msg}" ]; then # user is done
    if ! "${MOUNTED}"; then
      message "${root_err_msg1}"
      part_menu
    else
      if [ -z "${BOOT}" ]; then
        BOOT="${ROOT}"
      fi
      final_part=$( (
        df -h | grep /mnt | awk '{print $1,$2,$6 "\\n"}' | sed 's/mnt\/\?//'
      ) | column -t)
      final_count=$(wc <<<"${final_part}" -l)
      part_menu="${partition}  ${size}  ${mountpoint}"
      if (yesno "${write_confirm_msg}\n\n${part_menu}\n\n${final_part} \
\n${write_confirm}" "${write}" "${cancel}" 1); then
        if (efivar -l &>/dev/null); then
          if (fdisk -l | grep "EFI" &>/dev/null); then
            if (yesno "${efi_man_msg}" "${yes}" "${no}"); then
              if [ "$(fdisk -l | grep -c "EFI")" -gt "1" ]; then
                efint=1
                while (true); do
                  if [ "$(fdisk -l | grep "EFI" |
                      awk "NR==${efint} {print \$1}")" = "" ]; then
                    log "ERROR: Multiple EFI partitions found but not mounted"
                    lsblk | log
                    message "${efi_err_msg1}"
                    part_menu
                  fi
                  esp_part=$(fdisk -l | grep "EFI" |
                    awk "NR==${efint} {print \$1}")
                  esp_mnt=$(df -T | grep "${esp_part}" | awk '{print $7}' |
                    sed 's|/mnt||')
                  if (df -T | grep "${esp_part}" &>/dev/null); then
                    break
                  else
                    efint=$((efint + 1))
                  fi
                done
              else
                esp_part=$(fdisk -l | grep "EFI" | awk '{print $1}')
                if ! (df -T | grep "${esp_part}" &>/dev/null); then
                  source "${LANG_FILE}"
                  if (yesno "${efi_mnt_var}" "${yes}" "${no}"); then
                    if ! (mountpoint /mnt/boot &>/dev/null); then
                      mkdir /mnt/boot |& log
                      mount "${esp_part}" /mnt/boot |& log
                    else
                      log "ERROR: Mount point already present at /mnt/boot"
                      message "${efi_err_msg}"
                      part_menu
                    fi
                  else
                    part_menu
                  fi
                else
                  esp_mnt=$(df -T | grep "${esp_part}" | awk '{print $7}' |
                    sed 's|/mnt||')
                fi
              fi
              source "${LANG_FILE}"
              if ! (df -T | grep "${esp_part}" | grep "vfat" &>/dev/null); then
                if (yesno "${vfat_var}" "${yes}" "${no}"); then
                  clear
                  umount -R "${esp_mnt}" |& tee -a "${LOG_FILE}"
                  mkfs.vfat -F32 "${esp_part}" |& tee -a "${LOG_FILE}"
                  mount "${esp_part}" "${esp_mnt}" |& tee -a "${LOG_FILE}"
                  UEFI='true'
                  sleep 2
                else
                  part_menu
                fi
              else
                UEFI='true'
                export esp_part esp_mnt
              fi
            fi
          fi
        fi
        if "${ENABLE_BTRFS}" &&
            ! (df | grep "/mnt/boot\|/mnt/boot/efi" &>/dev/null); then
          FS="btrfs"
          source "${LANG_FILE}"
          message "${fs_err_var}"
          part_menu
        fi
        return
      else
        part_menu
      fi
    fi
  else # user selected a specific partition or md device with a filesystem
    source "${LANG_FILE}" &>/dev/null
    if [ -z "${ROOT}" ]; then
      case "${part_size}" in
      [1-9]T | [4-9]G | [1-9][0-9]*[GT] | [4-9].*[GT] | [4-9],*[GT])
        if (yesno "${root_var}" "${yes}" "${no}" 1); then
          fs_select
          if [ "$?" -gt "0" ]; then
            part_menu
          fi
          source "${LANG_FILE}"
          if (yesno "${root_confirm_var}" "${write}" "${cancel}" 1); then
            clear
            sgdisk --zap-all /dev/"${part}" |& tee -a "${LOG_FILE}"
            wipefs -a /dev/"${part}" |& tee -a "${LOG_FILE}"
            mkfs."${FS}" /dev/"${part}" |& tee -a "${LOG_FILE}"
            mount /dev/"${part}" /mnt |& tee -a "${LOG_FILE}"
            if [ "$?" -eq "0" ]; then
              MOUNTED='true'
              ROOT="${part}"
              if [ "${part_type}" = "lvm" ]; then
                lvm_pv=$(lvdisplay -m | grep -A 20 /dev/"${part}" |
                  grep "Physical volume" | sed 's/^\s\+//g;s/\s\+/ /g' |
                  cut -d ' ' -f 3)
                DRIVE=$(lsblk -dnro PKNAME "${lvm_pv}")
              else
                DRIVE=$(lsblk -dnro PKNAME /dev/"${part}")
              fi
              sleep 2
            else
              log "ERROR: Mount/unmount failure"
              lsblk | log
              message "${part_err_msg1}"
              return
            fi
          fi
        else
          part_menu
        fi
        ;;
      *)
        message "${root_err_msg}"
        ;;
      esac
    elif [ -n "${part_mount}" ]; then
      if (yesno "${manual_part_var0}" "${edit}" "${back}" 1); then
        if [ "${part}" = "${ROOT}" ]; then
          if (yesno "${manual_part_var2}" "${yes}" "${no}" 1); then
            MOUNTED='false'
            unset ROOT DRIVE
            umount -R /mnt |& log
          fi
        elif (yesno "${manual_part_var1}" "${yes}" "${no}" 1); then
          umount /mnt/"${part_mount}" |& log
          rm -r /mnt/"${part_mount:?}" |& log
          points=$(echo -e "${part_mount}   mountpoint>\n${points}")
        fi
      fi
    elif (yesno "${manual_new_part_var}" "${edit}" "${back}"); then
      mnt=$(dialog --stdout --ok-button "${ok}" --cancel-button "${cancel}" \
        --menu "\n${mnt_var0}" 15 60 6 ${points})
      if [ "$?" -gt "0" ]; then
        part_menu
      fi
      if [ "${mnt}" = "${custom}" ]; then
        while (true); do
          mnt=$(dialog --stdout --ok-button "${ok}" --cancel-button "${cancel}"\
            --inputbox "\n${custom_msg}" 10 50 "/")
          if [ "$?" -gt "0" ]; then
            part_menu
            break
          elif (grep <<<"${mnt}" "[\[\$\!\'\"\`\\|%&#@()+=<>~;:?.,^{}]\|]" \
              &>/dev/null); then
            message "${custom_err_msg0}"
          elif (grep <<<"${mnt}" "^[/]$" &>/dev/null); then
            message "${custom_err_msg1}"
          else
            break
          fi
        done
      fi
      if (yesno "${part_frmt_msg}" "${yes}" "${no}" 1); then
        if [ "${mnt}" = "/boot/EFI" ] || [ "${mnt}" = "/boot/efi" ]; then
          BTRFS='false'
        fi
        if (fdisk -l | grep "${part}" | grep "EFI" &>/dev/null); then
          VFAT='true'
        fi
        fs_select
        if [ "$?" -gt "0" ]; then
          part_menu
        fi
        FRMT='true'
      else
        FRMT='false'
      fi
      if [ "${mnt}" = "/boot" ] || [ "${mnt}" = "/boot/EFI" ] ||
         [ "${mnt}" = "/boot/efi" ]; then
        BOOT="${part}"
      fi
      source "${LANG_FILE}"
      points=$(echo "${points}" | grep -v "${mnt}")
      if "${FRMT}"; then
        if (yesno "${part_confirm_var}" "${write}" "${cancel}" 1); then
          clear
          sgdisk --zap-all /dev/"${part}" |& tee -a "${LOG_FILE}"
          wipefs -a /dev/"${part}" |& tee -a "${LOG_FILE}"
          case "${FS}" in
          vfat)
            mkfs.vfat -F32 /dev/"${part}" |& tee -a "${LOG_FILE}"
            ;;
          *)
            mkfs."${FS}" /dev/"${part}" |& tee -a "${LOG_FILE}"
            ;;
          esac
          sleep 2
        else
          part_menu
        fi
      fi
      mkdir -p /mnt/"${mnt}" |& log
      mount /dev/"${part}" /mnt/"${mnt}" |& log
      if [ "$?" -gt "0" ]; then
        log "ERROR: Mounting /dev/${part} at /mnt/${mnt} failed"
        lsblk | log
        message "${part_err_msg2}"
      fi
    fi
    part_menu
  fi
}

fs_select() {
  if "${VFAT}"; then
    FS=$(dialog --stdout --menu "\n${vfat_msg}" 11 65 1 "vfat" "${fs_fat}")
    if [ "$?" -gt "0" ]; then
      part_menu
    fi
    VFAT='false'
  elif "${BTRFS}"; then
    FS=$(dialog --stdout --no-cancel --menu "\n${fs_msg}" 12 60 7 \
      "ext4" "${fs_ext4}" \
      "btrfs" "${fs_btrfs}" \
      "xfs" "${fs_xfs}")
  else
    FS=$(dialog --stdout --no-cancel --menu "\n${fs_msg}" 12 60 6 \
      "ext4" "${fs_ext4}" \
      "xfs" "${fs_xfs}")
    BTRFS='true'
  fi
  if [ "${FS}" = "btrfs" ]; then
    ENABLE_BTRFS='true'
  elif [ "${FS}" = "xfs" ]; then
    ENABLE_XFS='true'
  fi
}

select_util() {
  UTIL=$(dialog --stdout --menu "\n${vfat_msg}" 14 65 3 \
    "cfdisk" "${part_util0}" \
    "fdisk" "${part_util1}" \
    "gdisk" "${part_util2}")
  if [ "$?" -gt "0" ]; then
    part_menu
  fi
}

prepare_base() {
  op_title="${install_op_msg}"
  BASE_PACKAGES+="${UCODE} "
  if "${WIFI_AVAILABLE}" ||
      (yesno "${wifi_option_msg}" "${yes}" "${no}" 1); then
    BASE_PACKAGES+="wireless_tools wpa_supplicant "
    log "Added wireless utilities"
  fi
  if "${BLUETOOTH_AVAILABLE}"; then
    BASE_PACKAGES+="blueman bluez bluez-utils pulseaudio-bluetooth "
    log "Added bluetooth support"
  fi
  if "${LAPTOP}" || (yesno "${touchpad_msg}" "${yes}" "${no}"); then
    BASE_PACKAGES+="xf86-input-libinput "
    log "Added touchpad support"
  fi
  if (yesno "${os_prober_msg}" "${yes}" "${no}" 1); then
    BASE_PACKAGES+="os-prober "
    log "Added os-prober"
  fi
  if "${UEFI}"; then
    BASE_PACKAGES+="efibootmgr "
    log "Added efibootmgr"
  fi

  # Graphics and VM packages
  local additional_packages
  source "${LANG_FILE}"
  if "${VM}"; then
    case "${virt}" in
    qemu)
      additional_packages="spice-vdagent"
      log "Added QEMU guest utils"
      ;;
    vbox)
      additional_packages="virtualbox-guest-utils "
      log "Added VirtualBox guest utils"
      ;;
    vmware)
      additional_packages="xf86-video-vmware xf86-input-vmmouse open-vm-tools
        net-tools gtkmm"
      log "Added VMware guest utils"
      ;;
    hyper-v)
      additional_packages="xf86-video-fbdev"
      log "Added HyperV guest utils"
      ;;
    *)
      additional_packages="xf86-video-fbdev"
      log "Added generic VM guest utils"
      ;;
    esac
  else
    if "${NVIDIA}"; then
      additional_packages=$(dialog --stdout --ok-button "${ok}" \
        --cancel-button "${cancel}" --menu "\n${graphics_msg}" 18 60 6 \
        "${default}" "${graphics_default}" \
        "nvidia" "${graphics_nvidia}" \
        "xf86-video-nouveau" "${graphics_nouveau}" \
        "xf86-video-intel" "${graphics_intel}" \
        "xf86-video-vesa" "${graphics_vesa}") \
        "xf86-video-ati" "${graphics_ati}" \
        "xf86-video-amdgpu" "${graphics_amd}"
    else
      additional_packages=$(dialog --stdout --ok-button "${ok}" \
        --cancel-button "${cancel}" --menu "\n${graphics_msg}" 17 60 5 \
        "${default}" "${graphics_default}" \
        "xf86-video-ati" "${graphics_ati}" \
        "xf86-video-amdgpu" "${graphics_amd}" \
        "xf86-video-intel" "${graphics_intel}" \
        "xf86-video-nouveau" "${graphics_nouveau}" \
        "xf86-video-vesa" "${graphics_vesa}")
    fi
    if [ -z "${additional_packages}" ] ||
       [ "${additional_packages}" = "${default}" ]; then
      additional_packages="${DEFAULT_GRAPHICS_DRIVER}"
    fi
    if [ "${additional_packages}" = "nvidia" ]; then
      additional_packages+=" nvidia-libgl nvidia-utils lib32-nvidia-utils
        nvidia-settings nvidia-prime nvidia-dkms"
      NVIDIA_DRM='true'
    elif [ "${additional_packages}" = "xf86-video-ati" ] ||
         [ "${additional_packages}" = "xf86-video-amdgpu" ]; then
      additional_packages+=" vulkan-radeon lib32-vulkan-radeon"
    elif [ "${additional_packages}" = "xf86-video-intel" ]; then
      additional_packages+=" vulkan-intel lib32-vulkan-intel
        lib32-libva-intel-driver"
    fi
    log "Graphics driver selected"
  fi
  BASE_PACKAGES+="${additional_packages} "
}

set_hostname() {
  op_title="${host_op_msg}"
  while (true); do
    # Prompt for hostname
    NEW_HOSTNAME=$(dialog --ok-button "${ok}" --no-cancel --inputbox \
      "\n${host_msg}" 12 55 "golden" --stdout | sed 's/ //g')
    # Check for a starting number or any unallowed characters
    if (grep <<<"${NEW_HOSTNAME}" \
        "^[0-9]\|[\[\$\!\'\"\`\\|%&#@()+=<>~;:/?.,^{}]\|]" &>/dev/null); then
      message "${host_err_msg}"
    else
      break
    fi
  done
}

set_user() {
  op_title="${user_op_msg}"
  while (true); do
    # Prompt for username
    NEW_USERNAME=$(dialog --stdout --cancel-button "${cancel}" --ok-button \
      "${ok}" --inputbox "\n${user_msg1}" 12 55)
    if [ "$?" -gt "0" ]; then
      break
    elif [ -z "${NEW_USERNAME}" ]; then
      message "${user_err_msg2}"
    elif (grep <<<"${NEW_USERNAME}" "^[0-9]\|[A-Z]\|[]:/?#@\!\$&'()*+,;=%[]" \
        &>/dev/null); then
      message "${user_err_msg}"
    else
      log "Username set: ${NEW_USERNAME}"
      while (true); do
        # Prompt for full name
        NEW_USER_FULL_NAME=$(dialog --stdout --cancel-button "${cancel}" \
          --ok-button "${ok}" --inputbox "\n${user_msg2}" 12 55)
        if [ "$?" != "0" ]; then
          break
        elif (grep <<<"${NEW_USER_FULL_NAME}" "," &>/dev/null); then
          message "${full_name_err_msg}"
        else
          # Prompt for password ('root' will use the same password)
          set_password
          break
        fi
      done
      break
    fi
  done
}

set_password() {
  op_title="${passwd_op_msg}"
  source "${LANG_FILE}"
  local input='a' input_check='b'
  while [ "${input}" != "${input_check}" ]; do
    input=$(dialog --stdout --no-cancel --clear --insecure --passwordbox \
      "\n${user_var0}" 11 55)
    input_check=$(dialog --stdout --no-cancel --clear --insecure --passwordbox \
      "\n${user_var1}" 11 55)
    if [ -z "${input}" ]; then
      message "${passwd_msg0}"
      input_check="check"
    elif [ "${input}" != "${input_check}" ]; then
      message "${passwd_msg1}"
    fi
  done
  NEW_PW="$(echo "${input}" | openssl enc -aes-256-cbc -a -salt -pbkdf2 \
    -iter 1000 -pass pass:"${ssl_key}")"
  unset input input_check
  log "Password set for user: ${NEW_USERNAME}"
  op_title="${user_op_msg}"
}

select_additional_software() {
  local software=""

  # Misc. Games
  op_title="Misc. ${games_software_title}"
  software+=$(dialog --stdout --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "lutris" "${software_lutris}" OFF \
    "steam" "${software_steam}" OFF \
    "itch" "(AUR) ${software_itch}" OFF \
    "legendary" "(AUR) ${software_legendary}" OFF \
    "playonlinux" "${software_playonlinux}" OFF \
    "libretro" "${software_libretro}" OFF \
    "dosbox" "${software_dosbox}" OFF \
    "scummvm" "${software_scummvm}" OFF)" "
  if (grep <<<"${software}" "lutris" &>/dev/null); then
    BASE_PACKAGES+="${LUTRIS_PACKAGES} " # install with base
  fi
  if (grep <<<"${software}" "steam" &>/dev/null); then
    BASE_PACKAGES+="steam steam-native-runtime " # install with base
  fi

  # Action Games
  op_title="Action ${games_software_title}"
  software+=$(dialog --stdout --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "supertux" "${software_supertux}" OFF \
    "frogatto" "${software_frogatto}" OFF \
    "alex4" "${software_alex4}" OFF \
    "asciiportal" "${software_asciiportal}" OFF \
    "mari0" "${software_mari0}" OFF \
    "xonotic" "${software_xonotic}" OFF \
    "warsow" "${software_warsow}" OFF \
    "sauerbraten" "${software_sauerbraten}" OFF \
    "assaultcube-reloaded" "(AUR) ${software_assaultcube_reloaded}" OFF \
    "openarena" "(AUR) ${software_openarena}" OFF \
    "astromenace" "${software_astromenace}" OFF \
    "chromium-bsu" "${software_chromium_bsu}" OFF \
    "starfighter" "(AUR) ${software_starfighter}" OFF \
    "teeworlds" "${software_teeworlds}" OFF \
    "bzflag" "(AUR) ${software_bzflag}" OFF)" "

  # Adventure Games
  op_title="Adventure ${games_software_title}"
  software+=$(dialog --stdout --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "bass" "${software_bass}" OFF \
    "fotaq" "(AUR) ${software_fotaq}" OFF \
    "lure" "(AUR) ${software_lure}" OFF \
    "drascula" "(AUR) ${software_drascula}" OFF \
    "zsdx" "(AUR) ${software_zsdx}" OFF \
    "sdlpop" "(AUR) ${software_sdlpop}" OFF \
    "zork1" "(AUR) ${software_zork1}" OFF \
    "zork2" "(AUR) ${software_zork2}" OFF \
    "zork3" "(AUR) ${software_zork3}" OFF \
    "open-adventure" "(AUR) ${software_open_adventure}" OFF)" "
  if (grep <<<"${software}" "drascula"); then
    software+="drascula-audio "
  fi

  # Roleplaying Games (RPGs)
  op_title="Roleplaying ${games_software_title} (RPGs)"
  software+=$(dialog --stdout --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "openmw" "${software_openmw}" OFF \
    "openmw-tes3mp" "(AUR) ${software_openmw_tes3mp}" OFF \
    "daggerfall-unity-aur-bin" "(AUR) ${software_daggerfall_unity_aur_bin}" OFF\
    "freedroidrpg" "${software_freedroidrpg}" OFF \
    "flare-game" "(AUR) ${software_flare_game}" OFF \
    "naev" "${software_naev}" OFF \
    "rogue" "${software_rogue}" OFF \
    "angband" "${software_angband}" OFF \
    "umoria" "(AUR) ${software_umoria}" OFF \
    "nethack" "${software_nethack}" OFF \
    "tome4" "(AUR) ${software_tome4}" OFF \
    "stone-soup" "${software_stone_soup}" OFF \
    "cataclysm-dda-tiles" "${software_cataclysm_dda_tiles}" OFF \
    "doomrl" "(AUR) ${software_doomrl}" OFF \
    "planeshift" "(AUR) ${software_planeshift}" OFF \
    "runescape-launcher" "(AUR) ${software_runescape_launcher}" OFF \
    "runelite" "(AUR) ${software_runelite}" OFF \
    "manaplus" "${software_manaplus}" OFF)" "

  # Strategy Games
  op_title="Strategy ${games_software_title}"
  software+=$(dialog --stdout --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "0ad" "${software_0ad}" OFF \
    "widelands" "${software_widelands}" OFF \
    "megaglest" "${software_megaglest}" OFF \
    "warzone2100" "${software_warzone2100}" OFF \
    "boswars" "(AUR) ${software_boswars}" OFF \
    "curseofwar" "${software_curseofwar}" OFF \
    "pingus" "${software_pingus}" OFF \
    "wesnoth" "${software_wesnoth}" OFF \
    "hedgewars" "${software_hedgewars}" OFF \
    "warmux" "(AUR) ${software_warmux}" OFF \
    "freeciv" "${software_freeciv}" OFF \
    "singularity" "${software_singularity}" OFF)" "

  # Racing Games
  op_title="Racing ${games_software_title}"
  software+=$(dialog --stdout --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "supertuxkart" "${software_supertuxkart}" OFF \
    "extremetuxracer" "${software_extremetuxracer}" OFF \
    "armagetronad" "${software_armagetronad}" OFF \
    "gltron" "(AUR) ${software_gltron}" OFF \
    "torcs" "(AUR) ${software_torcs}" OFF)" "

  # Simulation/Construction/Management Games
  op_title="Simulation/Construction/Management ${games_software_title}"
  software+=$(dialog --stdout --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "dwarffortress" "${software_dwarffortress}" OFF \
    "lincity-ng" "${software_lincity_ng}" OFF \
    "simutrans" "${software_simutrans}" OFF \
    "flightgear" "(AUR) ${software_flightgear}" OFF \
    "minetest" "${software_minetest}" OFF \
    "minecraft-launcher" "(AUR) ${software_minecraft_launcher}" OFF)" "

  # Development/Programming Software
  op_title="Game Dev & ${programming_software_title}"
  software+=$(dialog --stdout --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "godot" "${software_godot}" OFF \
    "love" "${software_love}" OFF \
    "solarus" "(AUR) ${software_solarus}" OFF \
    "spring" "${software_spring}" OFF \
    "unityhub" "(AUR) ${software_unityhub}" OFF \
    "unreal-engine" "(AUR) ${software_unreal_engine}" OFF \
    "tiled" "${software_tiled}" OFF \
    "android-studio" "(AUR) ${software_android_studio}" OFF \
    "allegro" "${software_allegro}" OFF \
    "python-pygame" "${software_python_pygame}" OFF \
    "panda3d" "(AUR) ${software_panda3d}" OFF \
    "pygtk" "(AUR) ${software_pygtk}" OFF \
    "scratch" "${software_scratch}" OFF \
    "atom" "${software_atom}" OFF \
    "code" "${software_code}" OFF \
    "geany" "${software_geany}" OFF \
    "emacs" "${software_emacs}" OFF)" "

  # Graphics/Drawing/Modeling Software
  op_title="${graphics_software_title}"
  software+=$(dialog --stdout --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "gimp" "${software_gimp}" OFF \
    "inkscape" "${software_inkscape}" OFF \
    "blender" "${software_blender}" OFF \
    "goxel" "(AUR) ${software_goxel}" OFF \
    "magicavoxel" "(AUR) ${software_magicavoxel}" OFF \
    "libresprite" "(AUR) ${software_libresprite}" OFF \
    "aseprite" "(AUR) ${software_aseprite}" OFF \
    "mtpaint" "${software_mtpaint}" OFF \
    "mypaint" "${software_mypaint}" OFF \
    "krita" "${software_krita}" OFF)" "

  # Multimedia Software
  op_title="${multimedia_software_title}"
  software+=$(dialog --stdout --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "obs-studio" "${software_obs_studio}" OFF \
    "openshot" "${software_openshot}" OFF \
    "kdenlive" "${software_kdenlive}" OFF \
    "simplescreenrecorder" "${software_simplescreenrecorder}" OFF \
    "youtube-dl" "${software_youtube_dl}" OFF \
    "vlc" "${software_vlc}" OFF \
    "spotify" "(AUR) ${software_spotify}" OFF \
    "audacity" "${software_audacity}" OFF \
    "lmms" "${software_lmms}" OFF \
    "pulseaudio-equalizer" "${software_pulseaudio_equalizer}" OFF)" "

  # Internet Software
  op_title="${internet_software_title}"
  software+=$(dialog --stdout --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "firefox" "${software_firefox}" OFF \
    "chromium" "${software_chromium}" OFF \
    "google-chrome" "(AUR) ${software_google_chrome}" OFF \
    "opera" "${software_opera}" OFF \
    "brave-bin" "(AUR) ${software_brave_bin}" OFF \
    "discord" "${software_discord}" OFF \
    "slack-desktop" "(AUR) ${software_slack_desktop}" OFF \
    "hexchat" "${software_hexchat}" OFF \
    "transmission-gtk" "${software_transmission_gtk}" OFF \
    "piavpn-bin" "(AUR) ${software_piavpn_bin}" OFF \
    "w3m" "${software_w3m}" OFF \
    "lynx" "${software_lynx}" OFF \
    "minitube" "${software_minitube}" OFF \
    "filezilla" "${software_filezilla}" OFF \
    "evolution" "${software_evolution}" OFF \
    "thunderbird" "${software_thunderbird}" OFF)" "
  if (grep <<<"${software}" "firefox" &>/dev/null) && [ -n "${bro}" ]; then
    software+="firefox-i18n-${bro} "
  fi
  if (grep <<<"${software}" "thunderbird" &>/dev/null) && [ -n "${bro}" ] &&
      [ "${bro}" != "lv" ]; then
    software+="thunderbird-i18n-${bro} "
  fi

  # Fonts and Language Input
  op_title="${fonts_and_language_input_software_title}, etc."
  software+=$(dialog --stdout --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "bdf-unifont" "${software_bdf_unifont}" OFF \
    "noto-fonts-cjk" "${software_noto_fonts_cjk}" OFF \
    "ibus-libpinyin" "${software_ibus_libpinyin}" OFF \
    "ibus-anthy" "${software_ibus_anthy}" OFF \
    "ibus-hangul" "${software_ibus_hangul}" OFF)" "
  if (grep <<<"${software}" "ibus" &>/dev/null); then
    echo -e "export GTK_IM_MODULE=ibus\nexport QT_IM_MODULE=ibus\nexport \
XMODIFIERS=@im=ibus\nibus-daemon -drx" >>"${GDL_DIR}"/extra/skel/.xprofile
  fi

  # Utilities
  op_title="${utilities_software_title}"
  software+=$(dialog --stdout --no-cancel --ok-button "${ok}" --checklist \
    "\n${software_msg}" 0 0 0 \
    "htop" "${software_htop}" OFF \
    "gtop" "${software_gtop}" OFF \
    "bashtop" "${software_bashtop}" OFF \
    "mangohud" "(AUR) ${software_mangohud}" OFF \
    "gparted" "${software_gparted}" OFF \
    "gnome-disk-utility" "${software_gnome_disk_utility}" OFF \
    "baobab" "${software_baobab}" OFF \
    "innoextract" "${software_innoextract}" OFF \
    "tmux" "${software_tmux}" OFF \
    "ranger" "${software_ranger}" OFF \
    "virtualbox" "${software_virtualbox}" OFF \
    "vmware-workstation" "(AUR) ${software_vmware_workstation}" OFF \
    "insync" "(AUR) ${software_insync}" OFF \
    "pcloud-drive" "(AUR) ${software_pcloud_drive}" OFF \
    "timeshift" "(AUR) ${software_timeshift}" OFF \
    "luckybackup" "(AUR) ${software_luckybackup}" OFF \
    "authy" "(AUR) ${software_authy}" OFF \
    "clamav" "${software_clamav}" OFF \
    "bleachbit" "${software_bleachbit}" OFF)" "
  if (grep <<<"${software}" "mangohud" &>/dev/null); then
    software+="lib32-mangohud "
  fi

  # Add selected software to package list
  download=$(echo "${software}" | sed 's/\"//g' | tr ' ' '\n' | nl |
    sort -u -k2 | sort -n | cut -f2- | sed 's/$/ /g' | tr -d '\n')
  download_list=$(echo "${download}" | sed -e 's/^[ \t]*//')
  log "Adding selected software: ${download_list}"
  AUR_AND_OPTIONAL_PACKAGES+="${download_list} "
}

install_base() {
  op_title="${install_op_msg}"
  local menu_choice
  while [ "${menu_choice}" != "${install}" ]; do
    menu_choice="$(dialog --stdout --no-cancel --menu \
      "\n${install_confirmation_msg}" 11 60 2 \
      "${install}" "${install_msg}" \
      "${exit_installer}" "${exit_installer_msg}")"
    if [ "${menu_choice}" = "${exit_installer}" ]; then
      if (yesno "${exit_confirmation_msg}" "${yes}" "${no}"); then
        log "User chose to exit installer: installation cancelled"
        clear
        dragonsay "${shell_prompt_msg1}"
        echo -e "${shell_prompt_msg2}"
        exit
      fi
    fi
  done
  if [ -n "${lib}" ]; then
    BASE_PACKAGES+="libreoffice-fresh-${lib} "
  fi
  if "${ENABLE_BTRFS}"; then
    BASE_PACKAGES+="grub-btrfs "
  fi
  BASE_PACKAGES=$(tr <<<"${BASE_PACKAGES}" " " "\n" | sort | uniq | tr "\n" " ")
  clear
  dragonsay "Installing base packages..." |& tee -a "${LOG_FILE}"
  pacman -Sy
  pacstrap /mnt ${BASE_PACKAGES} |& tee -a "${LOG_FILE}"
  if [ "$?" -eq "0" ]; then
    INSTALLATION_COMPLETE='true'
    log "Completed base installation"
  else
    report_error
    clear
    dragonsay "${shell_prompt_msg1}"
    echo -e "${shell_prompt_msg2}"
    exit 1
  fi
  genfstab -U -p /mnt >>/mnt/etc/fstab |& tee -a "${LOG_FILE}"
  log "Generated fstab"
  grub_config
  log "Configured grub"
}

grub_config() {
  local grub='/mnt/etc/default/grub'
  local theme_dir='/boot/grub/themes/gdl'
  mkdir -p /mnt"${theme_dir}"
  cp -r "${GDL_DIR}"/extra/grub-theme/* /mnt"${theme_dir}"
  sed -i 's/GRUB_DEFAULT=0/GRUB_DEFAULT=saved/' "${grub}"
  sed -i 's/GRUB_TIMEOUT=5/GRUB_TIMEOUT=3/' "${grub}"
  sed -i "s:#GRUB_COLOR_N.*$:GRUB_COLOR_NORMAL=\"red/black\":" "${grub}"
  sed -i "s:#GRUB_COLOR_H.*$:GRUB_COLOR_HIGHLIGHT=\"yellow/black\":" "${grub}"
  sed -i "s:#GRUB_BACK.*$:GRUB_BACKGROUND=\"${theme_dir}/background.png\":" \
    "${grub}"
  sed -i "s:#GRUB_THEME.*$:GRUB_THEME=\"${theme_dir}/theme.txt\":" "${grub}"
  sed -i 's/#GRUB_SAVEDEFAULT="true"/GRUB_SAVEDEFAULT="true"/' "${grub}"
  if "${ENCRYPTED}"; then
    sed -i "s!quiet!cryptdevice=/dev/lvm/lvroot:root:allow-discards \
root=/dev/mapper/root transparent_hugepage=never!" "${grub}"
  else
    sed -i 's/quiet/transparent_hugepage=never/' "${grub}"
  fi
  if "${NVIDIA_DRM}"; then
    sed -i '/GRUB_CMDLINE_LINUX_DEFAULT=/ s/.$/ nvidia-drm.modeset=1"/;s/" /"/'\
      "${grub}"
  fi
  if "${UEFI}"; then
    arch-chroot /mnt grub-install --efi-directory="${esp_mnt}" \
      --target=x86_64-efi --bootloader-id=boot |& tee -a "${LOG_FILE}"
    cp /mnt/"${esp_mnt}"/EFI/boot/grubx64.efi \
      /mnt/"${esp_mnt}"/EFI/boot/bootx64.efi
    if ! "${ENCRYPTED}"; then
      arch-chroot /mnt mkinitcpio -p linux |& tee -a "${LOG_FILE}"
    fi
  else
    arch-chroot /mnt grub-install /dev/"${DRIVE}" |& tee -a "${LOG_FILE}"
  fi
  arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg |& tee -a "${LOG_FILE}"
}

configure_system() {
  if "${NVIDIA_DRM}"; then
    sed -i \
      '/^MODULES=/ s/.$/ nvidia nvidia_modeset nvidia_uvm nvidia_drm )/;s/" /"/'
    sed -i 's!FILES=""!FILES="/etc/modprobe.d/nvidia.conf"!' \
      /mnt/etc/mkinitcpio.conf
    echo "options nvidia_drm modeset=1" >/mnt/etc/modprobe.d/nvidia.conf
    if (grep <<<"${BASE_PACKAGES}" "nvidia" &>/dev/null); then
      echo "blacklist nouveau" >>/mnt/etc/modprobe.d/nvidia.conf
    fi
    if [ ! -d /mnt/etc/pacman.d/hooks ]; then
      mkdir /mnt/etc/pacman.d/hooks
    fi
    # https://wiki.archlinux.org/index.php/NVIDIA#Pacman_hook
    echo -e "[Trigger]\nOperation=Install\nOperation=Upgrade\nOperation=Remove\
\nType=Package\nTarget=nvidia\nTarget=linux\n\n[Action]\nDescription=Update \
Nvidia module in initcpio\nDepends=mkinitcpio\nWhen=PostTransaction\nNeeds\
Targets\nExec=/bin/sh -c 'while read -r trg; do case \$trg in linux) exit 0; \
esac; done; /usr/bin/mkinitcpio -P'\n" >/mnt/etc/pacman.d/hooks/nvidia.hook
    if ! "${ENCRYPTED}"; then
      arch-chroot /mnt mkinitcpio -p linux |& tee -a "${LOG_FILE}"
    fi
    log "Enabled Nvidia DRM (Direct Rendering Manager)"
  fi

  if "${ENABLE_XFS}"; then
    sed -i '/^MODULES=/ s/.$/ xfs )/;s/" /"/' /mnt/etc/mkinitcpio.conf
    if ! "${ENCRYPTED}"; then
      arch-chroot /mnt mkinitcpio -p linux |& tee -a "${LOG_FILE}"
    fi
    log "Configured system for xfs"
  fi

  if (grep -E <<<"${BOOT}" "nvme.*" &>/dev/null); then
    sed -i '/^MODULES=/ s/.$/ nvme )/;s/" /"/' /mnt/etc/mkinitcpio.conf
    if ! "${ENCRYPTED}"; then
      arch-chroot /mnt mkinitcpio -p linux |& tee -a "${LOG_FILE}"
    fi
    log "Configured system for nvme"
  fi

  if "${ENCRYPTED}" && "${UEFI}"; then
    echo "/dev/${BOOT} ${esp_mnt} vfat rw,relatime,fmask=0022,dmask=0022,\
codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro 0 2" \
      >/mnt/etc/fstab
  elif "${ENCRYPTED}"; then
    echo "/dev/${BOOT} /boot ext4 defaults 0 2" >/mnt/etc/fstab
  fi

  if "${ENCRYPTED}"; then
    echo "/dev/mapper/root / ${FS} defaults 0 1" >>/mnt/etc/fstab
    echo "/dev/mapper/tmp /tmp tmpfs defaults 0 0" >>/mnt/etc/fstab
    echo "tmp /dev/lvm/tmp /dev/urandom tmp,cipher=aes-xts-plain64,size=256" \
      >>/mnt/etc/crypttab
    sed -i 's/^HOOKS=.*/HOOKS="base udev autodetect keyboard keymap consolefont\
modconf block encrypt lvm2 filesystems fsck"/' /mnt/etc/mkinitcpio.conf
    arch-chroot /mnt mkinitcpio -p linux |& tee -a "${LOG_FILE}"
    log "Configured system for encryption"
  else
    sed -i 's/^HOOKS=.*/HOOKS="base udev autodetect keyboard keymap consolefont\
modconf block lvm2 filesystems fsck"/' /mnt/etc/mkinitcpio.conf
    arch-chroot /mnt mkinitcpio -p linux |& tee -a "${LOG_FILE}"
    log "Configured system with default mkinitcpio hooks"
  fi

  sed -i -e "s/#${LOCALE}/${LOCALE}/" /mnt/etc/locale.gen
  echo LANG="${LOCALE}" >/mnt/etc/locale.conf
  arch-chroot /mnt locale-gen
  log "Set system locale: ${LOCALE}"

  if [ "${keyboard}" != "${default}" ]; then
    echo "KEYMAP=${keyboard}" >/mnt/etc/vconsole.conf
    echo -e "Section \"InputClass\"\nIdentifier \"system-keyboard\"\nMatchIs\
Keyboard \"on\"\nOption \"XkbLayout\" \"${keyboard}\"\nEndSection" \
      >/mnt/etc/X11/xorg.conf.d/00-keyboard.conf
    arch-chroot /mnt localectl set-x11-keymap "${keyboard}"
    log "Set system keymap: ${keyboard}"
  fi

  arch-chroot /mnt ln -sf /usr/share/zoneinfo/"${ZONE}" /etc/localtime
  log "Set system time zone: ${ZONE}"

  arch-chroot /mnt ufw enable # firewall
  enable_service ufw.service
  enable_service NetworkManager.service
  if "${BLUETOOTH_AVAILABLE}"; then
    enable_service bluetooth.service
  fi

  if "${VM}"; then
    case "${virt}" in
    vbox)
      enable_service vboxservice.service
      ;;
    vmware)
      cat /mnt/proc/version >/mnt/etc/arch-release
      enable_service vmtoolsd.service
      enable_service vmware-vmblock-fuse.service
      mkdir /mnt/etc/init.d
      for x in {0..6}; do mkdir -p /mnt/etc/init.d/rc"${x}".d; done
      ;;
    esac
  fi

  arch-chroot /mnt fc-cache -f # build font information cache files
  cp "${GDL_DIR}"/extra/gdl.png /mnt/usr/share/pixmaps
  cp "${GDL_DIR}"/extra/gdl.png /mnt/usr/share/icons
  cp -r "${GDL_DIR}"/extra/Breeze_Amber /mnt/usr/share/icons
  cp -rT "${GDL_DIR}"/extra/wallpapers /mnt/usr/share/backgrounds/xfce
  cp -rT "${GDL_DIR}"/extra/skel /mnt/etc/skel
  cp -rT "${GDL_DIR}"/extra/root /mnt/root
  cp /mnt/etc/skel/.bash_profile /mnt/root/
  cp /mnt/etc/skel/.vimrc /mnt/root/
  cp "${GDL_DIR}"/extra/gdl.png /mnt/root/.face
  log "Configured desktop environment"

  cp -rT "${GDL_DIR}"/extra/lightdm /mnt/etc/lightdm
  enable_service lightdm.service
  enable_service dhcpcd.service
  enable_service cpupower.service
  enable_service fstrim.timer # periodic (weekly) TRIM for all supported drives

  if [ -f /mnt/var/lib/pacman/db.lck ]; then
    rm /mnt/var/lib/pacman/db.lck &>/dev/null
  fi

  # Ensure proper MIDI support for certain GStreamer-based media players
  mkdir -p /mnt/usr/share/sounds/sf2
  arch-chroot /mnt sh -c "ln -s /usr/share/soundfonts/FluidR3_GM.sf2 \
    /usr/share/sounds/sf2/"

  sed -i 's/^#Color$/Color/' /mnt/etc/pacman.conf
  sed -i 's/^#CheckSpace$/CheckSpace/' /mnt/etc/pacman.conf
  sed -i 's/^#VerbosePkgLists$/VerbosePkgLists/' /mnt/etc/pacman.conf
  sed -i '/^VerbosePkgLists$/ a ILoveCandy' /mnt/etc/pacman.conf
  sed -i '/\[multilib]$/ {
    N
    /Include/s/#//g}' /mnt/etc/pacman.conf
  log "Customized pacman.conf"

  echo "${NEW_HOSTNAME}" >/mnt/etc/hostname
  log "Hostname set: ${NEW_HOSTNAME}"
  local pw
  pw="$(echo "${NEW_PW}" | openssl enc -aes-256-cbc -a -d -salt -pbkdf2 -iter \
    1000 -pass pass:"${ssl_key}")"
  printf "%s\n%s" "${pw}" "${pw}" | arch-chroot /mnt passwd root
  unset pw
  log "Password set for user: root"
}

install_additional_software() {
  # Create a special temporary user for installing and using yay (AUR helper)
  dragonsay "Setting up AUR support..." |& tee -a "${LOG_FILE}"
  log "Creating temporary user: 'yaybuilder'"
  local pw
  pw=$(< /dev/urandom tr -dc "@#*%&_A-Z-a-z-0-9" | head -c16)
  arch-chroot /mnt mkdir -v yaytemp
  arch-chroot /mnt chmod 777 yaytemp
  arch-chroot /mnt useradd -rNM -d /yaytemp -s /usr/bin/nologin yaybuilder
  arch-chroot /mnt sh -c "echo -e '${pw}\n${pw}\n' | passwd yaybuilder"
  log "Adding 'yaybuilder' to sudoers.d"
  arch-chroot /mnt sh -c "echo 'yaybuilder ALL=(ALL) NOPASSWD: ALL' |
    tee /etc/sudoers.d/yaybuilder"
  arch-chroot /mnt sh -c "echo 'root ALL=(yaybuilder) NOPASSWD: ALL' |
    tee -a /etc/sudoers.d/yaybuilder"

  # Install yay, update, then install additional packages using yay
  log "Installing yay (AUR helper)"
  arch-chroot /mnt sh -c "cd yaytemp &&
    sudo -u yaybuilder git clone https://aur.archlinux.org/yay-bin.git &&
    cd yay-bin && sudo -u yaybuilder makepkg -si --noconfirm" |&
    tee -a "${LOG_FILE}"
  arch-chroot /mnt sudo -u yaybuilder yay -Syu --noconfirm |&
    tee -a "${LOG_FILE}"
  AUR_AND_OPTIONAL_PACKAGES=$(tr <<<"${AUR_AND_OPTIONAL_PACKAGES}" " " "\n" |
    sort | uniq | tr "\n" " ")
  dragonsay "Installing additional software..." |& tee -a "${LOG_FILE}"
  for package in ${AUR_AND_OPTIONAL_PACKAGES}; do
    arch-chroot /mnt sudo -u yaybuilder yay -S "${package}" --needed \
      --noconfirm |& tee -a "${LOG_FILE}"
  done
  log "Finished installing additional software"

  # Clean things up
  log "Cleaning up..."
  arch-chroot /mnt sudo -u yaybuilder yay -Yc --noconfirm |&
    tee -a "${LOG_FILE}"
  arch-chroot /mnt userdel -f yaybuilder |& tee -a "${LOG_FILE}"
  log "User 'yaybuilder' deleted"
  arch-chroot /mnt rm /etc/passwd-
  arch-chroot /mnt rm /etc/sudoers.d/yaybuilder
  arch-chroot /mnt rm -r yaytemp
  log "Cleanup complete"
}

add_user() {
  if [ "${NEW_USER_FULL_NAME}" = "" ]; then
    arch-chroot /mnt useradd -m -G audio,network,power,storage,optical -s \
      /bin/bash "${NEW_USERNAME}"
  else
    arch-chroot /mnt useradd -m -G audio,network,power,storage,optical -c \
      "${NEW_USER_FULL_NAME}" -s /bin/bash "${NEW_USERNAME}"
  fi
  local pw
  pw="$(echo "${NEW_PW}" | openssl enc -aes-256-cbc -a -d -salt -pbkdf2 -iter \
    1000 -pass pass:"${ssl_key}")"
  printf "%s\n%s" "${pw}" "${pw}" | arch-chroot /mnt passwd "${NEW_USERNAME}"
  unset pw
  sed -i '/%wheel ALL=(ALL) ALL/s/^#//' /mnt/etc/sudoers
  arch-chroot /mnt usermod -a -G wheel "${NEW_USERNAME}"
  # Add shortcut for installing Battle.net if Lutris was installed
  if (grep <<<"${BASE_PACKAGES}" "lutris" &>/dev/null); then
    mkdir /mnt/home/"${NEW_USERNAME}"/Desktop
    echo -e "[Desktop Entry]\nVersion=1.0\nType=Link\nName=Install Battle.net
Comment=Install the Blizzard Battle.net app via Lutris\nIcon=user-bookmarks
URL=lutris:blizzard-battlenet-standard" \
      >/mnt/home/"${NEW_USERNAME}"/Desktop/blizzard.desktop
    arch-chroot /mnt chown -R "${NEW_USERNAME}:${NEW_USERNAME}" \
      /home/"${NEW_USERNAME}"/Desktop
  fi
  log "User added: ${NEW_USERNAME}"
}

final_system_check() {
  # Check if system is installed
  if "${INSTALLATION_COMPLETE}"; then
    clear
    dragonsay "${install_complete_msg1}" |& tee -a "${LOG_FILE}"
    cp "${LOG_FILE}" /mnt/root
    echo -e "${install_complete_msg2}"
    exit
  else
    # Warn user install incomplete, prompt for reboot
    op_title="${default_op_msg}"
    if (yesno "${install_incomplete_msg}" "${yes}" "${no}"); then
      clear
      umount -R /mnt
      reboot
      exit
    fi
  fi
}

main() {
  initialize
  set_language
  set_keyboard_layout
  op_title="${about_gdl_title}"
  dialog --ok-button "${ok}" --msgbox "\n${about_gdl_msg}" 24 80
  update_mirrors
  set_locale
  set_zone
  prepare_drives
  prepare_base
  set_hostname
  set_user
  select_additional_software
  install_base
  configure_system
  install_additional_software
  add_user
  final_system_check
}

main
